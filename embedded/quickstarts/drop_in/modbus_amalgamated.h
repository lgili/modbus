
/*
 * modbus_amalgamated.h - generated drop-in header
 *
 * This file is generated by scripts/amalgamate.py.
 * It contains the public Modbus API required for the baseline RTU client
 * configuration so that embedded projects can integrate without the full
 * repository layout.
 *
 * Generation timestamp: 2025-10-06T21:10:32+00:00
 */
#ifndef MODBUS_AMALGAMATED_H
#define MODBUS_AMALGAMATED_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* ===== Begin modbus/include/modbus/mb_types.h ===== */
/**
 * @file mb_types.h
 * @brief Common fixed-width and utility types for the Modbus library.
 *
 * This header centralises the type aliases and lightweight macros we rely on
 * across the codebase.  Keeping them in a single translation unit makes it
 * easier to reason about ABI constraints and freestanding targets that may
 * not ship with the full C library.
 */

#ifndef MODBUS_MB_TYPES_H
#define MODBUS_MB_TYPES_H

#include <limits.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/* -------------------------------------------------------------------------- */
/* Fixed width aliases                                                        */
/* -------------------------------------------------------------------------- */

typedef int8_t   mb_i8;
typedef uint8_t  mb_u8;
typedef int16_t  mb_i16;
typedef uint16_t mb_u16;
typedef int32_t  mb_i32;
typedef uint32_t mb_u32;
typedef int64_t  mb_i64;
typedef uint64_t mb_u64;

typedef size_t    mb_size_t;
typedef ptrdiff_t mb_ptrdiff_t;
typedef uintptr_t mb_uintptr_t;
typedef intptr_t  mb_intptr_t;

/* Monotonic millisecond timestamp used by the FSM and watchdog logic. */
typedef mb_u64 mb_time_ms_t;

/* -------------------------------------------------------------------------- */
/* Compile-time helpers                                                       */
/* -------------------------------------------------------------------------- */

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
#  define MB_STATIC_ASSERT(expr, msg) _Static_assert((expr), msg)
#else
#  define MB_STATIC_ASSERT(expr, msg) typedef char mb_static_assert_[(expr) ? 1 : -1]
#endif

#define MB_COUNTOF(arr) (sizeof(arr) / sizeof((arr)[0]))

/* Attribute helpers -------------------------------------------------------- */

#if defined(__GNUC__) || defined(__clang__)
#  define MB_PACKED __attribute__((__packed__))
#  define MB_LIKELY(x)   __builtin_expect(!!(x), 1)
#  define MB_UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define MB_PACKED
#  define MB_LIKELY(x)   (x)
#  define MB_UNLIKELY(x) (x)
#endif

#define MB_IS_POWER_OF_TWO(value) (((value) != 0U) && (((value) & ((value) - 1U)) == 0U))

#define MB_ALIGN_UP(value, align) \
	(((value) + ((align) - 1U)) & ~((align) - 1U))

/* Basic sanity checks ------------------------------------------------------ */

MB_STATIC_ASSERT(sizeof(mb_u8) == 1,  "mb_u8 must be 8 bits");
MB_STATIC_ASSERT(sizeof(mb_u16) == 2, "mb_u16 must be 16 bits");
MB_STATIC_ASSERT(sizeof(mb_u32) == 4, "mb_u32 must be 32 bits");
MB_STATIC_ASSERT(sizeof(mb_u64) == 8, "mb_u64 must be 64 bits");

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_MB_TYPES_H */
/* ===== End modbus/include/modbus/mb_types.h ===== */

/* ===== Begin modbus/include/modbus/conf.h ===== */
/**
 * @file modbus_conf.h
 * @brief Configuration header for the Modbus library.
 *
 * This file contains compile-time configuration options, macros, and default
 * values that can be adjusted for different environments or constraints.
 * Users or integrators may modify these definitions before building the library
 * to customize its behavior.
 *
 * These settings should be included before any other modbus headers, ensuring
 * all modules see the same configuration.
 *
 * Author:
 * Date: 2024-12-20
 */

#ifndef MODBUS_CONF_H
#define MODBUS_CONF_H

#ifndef MB_CONF_BUILD_CLIENT
#define MB_CONF_BUILD_CLIENT 1
#endif

#ifndef MB_CONF_BUILD_SERVER
#define MB_CONF_BUILD_SERVER 0
#endif

#ifndef MB_CONF_TRANSPORT_RTU
#define MB_CONF_TRANSPORT_RTU 1
#endif

#ifndef MB_CONF_TRANSPORT_ASCII
#define MB_CONF_TRANSPORT_ASCII 0
#endif

#ifndef MB_CONF_TRANSPORT_TCP
#define MB_CONF_TRANSPORT_TCP 0
#endif

#define MB_CONF_PROFILE_TINY   0
#define MB_CONF_PROFILE_LEAN   1
#define MB_CONF_PROFILE_FULL   2
#define MB_CONF_PROFILE_CUSTOM 3

#ifndef MB_CONF_PROFILE
#define MB_CONF_PROFILE MB_CONF_PROFILE_LEAN
#endif

#ifndef MB_CONF_ENABLE_FC01
#define MB_CONF_ENABLE_FC01 1
#endif

#ifndef MB_CONF_ENABLE_FC02
#define MB_CONF_ENABLE_FC02 1
#endif

#ifndef MB_CONF_ENABLE_FC03
#define MB_CONF_ENABLE_FC03 1
#endif

#ifndef MB_CONF_ENABLE_FC04
#define MB_CONF_ENABLE_FC04 1
#endif

#ifndef MB_CONF_ENABLE_FC05
#define MB_CONF_ENABLE_FC05 1
#endif

#ifndef MB_CONF_ENABLE_FC06
#define MB_CONF_ENABLE_FC06 1
#endif

#ifndef MB_CONF_ENABLE_FC07
#define MB_CONF_ENABLE_FC07 1
#endif

#ifndef MB_CONF_ENABLE_FC0F
#define MB_CONF_ENABLE_FC0F 1
#endif

#ifndef MB_CONF_ENABLE_FC10
#define MB_CONF_ENABLE_FC10 1
#endif

#ifndef MB_CONF_ENABLE_FC11
#define MB_CONF_ENABLE_FC11 1
#endif

#ifndef MB_CONF_ENABLE_FC16
#define MB_CONF_ENABLE_FC16 1
#endif

#ifndef MB_CONF_ENABLE_FC17
#define MB_CONF_ENABLE_FC17 1
#endif

#ifndef MB_CONF_DIAG_ENABLE_COUNTERS
#define MB_CONF_DIAG_ENABLE_COUNTERS 1
#endif

#ifndef MB_CONF_DIAG_ENABLE_TRACE
#define MB_CONF_DIAG_ENABLE_TRACE 0
#endif

#ifndef MB_CONF_DIAG_TRACE_DEPTH
#define MB_CONF_DIAG_TRACE_DEPTH 64
#endif

#define LOG_ENABLED
/**
 * @brief Maximum size of holding registers array in the server.
 */
#ifndef MAX_SIZE_HOLDING_REGISTERS
#define MAX_SIZE_HOLDING_REGISTERS 64
#endif

/**
 * @brief Maximum address for holding registers.
 */
#ifndef MAX_ADDRESS_HOLDING_REGISTERS
#define MAX_ADDRESS_HOLDING_REGISTERS 65535
#endif

/**
 * @brief Maximum number of registers that can be read or written at once.
 */
#ifndef MODBUS_MAX_READ_WRITE_SIZE
#define MODBUS_MAX_READ_WRITE_SIZE 0x07D0
#endif

/**
 * @brief Maximum device info packages in server mode.
 */
#ifndef MAX_DEVICE_PACKAGES
#define MAX_DEVICE_PACKAGES 5
#endif

/**
 * @brief Maximum length of each device info package.
 */
#ifndef MAX_DEVICE_PACKAGE_VALUES
#define MAX_DEVICE_PACKAGE_VALUES 8
#endif

/**
 * @brief Default Modbus baudrate (for RTU).
 */
#ifndef MODBUS_BAUDRATE
#define MODBUS_BAUDRATE 19200
#endif

/**
 * @brief Size of receive and transmit buffers.
 */
#ifndef MODBUS_RECEIVE_BUFFER_SIZE
#define MODBUS_RECEIVE_BUFFER_SIZE 256
#endif

#ifndef MODBUS_SEND_BUFFER_SIZE
#define MODBUS_SEND_BUFFER_SIZE 256
#endif

#ifndef MASTER_DEFAULT_TIMEOUT_MS
#define MASTER_DEFAULT_TIMEOUT_MS  1000
#endif

/**
 * @brief Maximum number of simultaneous Modbus TCP connections handled by helper utilities.
 */
#ifndef MB_TCP_MAX_CONNECTIONS
#define MB_TCP_MAX_CONNECTIONS 4
#endif

/**
 * @brief If you want to enable or disable certain functions, you can define
 * macros here. For example:
 * #define ENABLE_BOOTLOADER 1
 */

/* Add more configurations as needed */

typedef enum mb_conf_client_poll_phase {
	MB_CONF_CLIENT_POLL_PHASE_ENTER = 0,
	MB_CONF_CLIENT_POLL_PHASE_AFTER_TRANSPORT,
	MB_CONF_CLIENT_POLL_PHASE_AFTER_STATE,
	MB_CONF_CLIENT_POLL_PHASE_EXIT
} mb_conf_client_poll_phase_t;

typedef enum mb_conf_server_poll_phase {
	MB_CONF_SERVER_POLL_PHASE_ENTER = 0,
	MB_CONF_SERVER_POLL_PHASE_AFTER_TRANSPORT,
	MB_CONF_SERVER_POLL_PHASE_AFTER_STATE,
	MB_CONF_SERVER_POLL_PHASE_EXIT
} mb_conf_server_poll_phase_t;

#ifndef MB_CONF_CLIENT_POLL_HOOK
#define MB_CONF_CLIENT_POLL_HOOK(client_ptr, phase) do { (void)(client_ptr); (void)(phase); } while (0)
#endif

#ifndef MB_CONF_SERVER_POLL_HOOK
#define MB_CONF_SERVER_POLL_HOOK(server_ptr, phase) do { (void)(server_ptr); (void)(phase); } while (0)
#endif

#endif /* MODBUS_CONF_H */
/* ===== End modbus/include/modbus/conf.h ===== */

/* ===== Begin modbus/include/modbus/mb_err.h ===== */
/**
 * @file mb_err.h
 * @brief Central repository for Modbus error codes and helpers.
 *
 * This header consolidates the error enumeration and related utilities that
 * were previously scattered across legacy headers, providing a single source of
 * truth for status codes shared by the client, server and transport layers.
 */

#ifndef MODBUS_MB_ERR_H
#define MODBUS_MB_ERR_H

#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Unified Modbus error / status codes.
 *
 * The values preserve the legacy names used throughout the codebase so the
 * existing implementation keeps compiling while the headers get reorganized.
 */
typedef enum modbus_error {
    MODBUS_ERROR_NONE = 0,                /**< No error. */
    MODBUS_ERROR_INVALID_ARGUMENT = -1,   /**< Invalid argument provided. */
    MODBUS_ERROR_TIMEOUT = -2,            /**< Read/write timeout occurred. */
    MODBUS_ERROR_TRANSPORT = -3,          /**< Transport layer error. */
    MODBUS_ERROR_CRC = -4,                /**< CRC check failed. */
    MODBUS_ERROR_INVALID_REQUEST = -5,    /**< Received invalid request frame. */
    MODBUS_ERROR_OTHER_REQUESTS = -6,     /**< Received other types of requests. */
    MODBUS_OTHERS_REQUESTS = -7,          /**< Placeholder for additional request types. */
    MODBUS_ERROR_OTHER = -8,              /**< Other unspecified error. */
    MODBUS_ERROR_CANCELLED = -9,          /**< Operation was cancelled. */
    MODBUS_ERROR_NO_RESOURCES = -10,      /**< Requested resource could not be reserved. */

    /* Modbus exceptions (positive values) */
    MODBUS_EXCEPTION_ILLEGAL_FUNCTION = 1,            /**< Exception 1: Illegal function. */
    MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS = 2,        /**< Exception 2: Illegal data address. */
    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE = 3,          /**< Exception 3: Illegal data value. */
    MODBUS_EXCEPTION_SERVER_DEVICE_FAILURE = 4,       /**< Exception 4: Server device failure. */
    MODBUS_EXCEPTION_ACKNOWLEDGE = 5,                 /**< Exception 5: Acknowledge (processing). */
    MODBUS_EXCEPTION_SERVER_DEVICE_BUSY = 6,          /**< Exception 6: Server device busy. */
    MODBUS_EXCEPTION_NEGATIVE_ACKNOWLEDGE = 7,        /**< Exception 7: Negative acknowledge. */
    MODBUS_EXCEPTION_MEMORY_PARITY_ERROR = 8,         /**< Exception 8: Memory parity error. */
    MODBUS_EXCEPTION_GATEWAY_PATH_UNAVAILABLE = 10,   /**< Exception 10: Gateway path unavailable. */
    MODBUS_EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED = 11/**< Exception 11: Target device failed to respond. */
} modbus_error_t;

/**
 * @brief Convenience alias mirroring the historical ``modbus_error_t`` name.
 */
typedef modbus_error_t mb_err_t;

#ifdef MB_OK
#undef MB_OK
#endif
#define MB_OK                       MODBUS_ERROR_NONE
#define MB_ERR_INVALID_ARGUMENT     MODBUS_ERROR_INVALID_ARGUMENT
#define MB_ERR_TIMEOUT              MODBUS_ERROR_TIMEOUT
#define MB_ERR_TRANSPORT            MODBUS_ERROR_TRANSPORT
#define MB_ERR_CRC                  MODBUS_ERROR_CRC
#define MB_ERR_INVALID_REQUEST      MODBUS_ERROR_INVALID_REQUEST
#define MB_ERR_OTHER_REQUESTS       MODBUS_ERROR_OTHER_REQUESTS
#define MB_ERR_OTHER                MODBUS_ERROR_OTHER
#define MB_ERR_CANCELLED            MODBUS_ERROR_CANCELLED
#define MB_ERR_NO_RESOURCES         MODBUS_ERROR_NO_RESOURCES

#define MB_EX_ILLEGAL_FUNCTION      MODBUS_EXCEPTION_ILLEGAL_FUNCTION
#define MB_EX_ILLEGAL_DATA_ADDRESS  MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS
#define MB_EX_ILLEGAL_DATA_VALUE    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE
#define MB_EX_SERVER_DEVICE_FAILURE MODBUS_EXCEPTION_SERVER_DEVICE_FAILURE
#define MB_EX_ACKNOWLEDGE           MODBUS_EXCEPTION_ACKNOWLEDGE
#define MB_EX_SERVER_DEVICE_BUSY    MODBUS_EXCEPTION_SERVER_DEVICE_BUSY
#define MB_EX_NEGATIVE_ACKNOWLEDGE  MODBUS_EXCEPTION_NEGATIVE_ACKNOWLEDGE
#define MB_EX_MEMORY_PARITY_ERROR   MODBUS_EXCEPTION_MEMORY_PARITY_ERROR
#define MB_EX_GATEWAY_PATH_UNAVAILABLE MODBUS_EXCEPTION_GATEWAY_PATH_UNAVAILABLE
#define MB_EX_GATEWAY_TARGET_FAILED MODBUS_EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED

static inline bool mb_err_is_ok(mb_err_t err)
{
    return err == MB_OK;
}

const char *mb_err_str(mb_err_t err);

/**
 * @brief Determines if the given error code represents a Modbus exception.
 *
 * @param err Error code to inspect.
 * @return `true` when the code is a protocol exception (1–4), `false` otherwise.
 */
static inline bool mb_err_is_exception(modbus_error_t err)
{
    return (err == MODBUS_EXCEPTION_ILLEGAL_FUNCTION) ||
           (err == MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS) ||
           (err == MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE) ||
           (err == MODBUS_EXCEPTION_SERVER_DEVICE_FAILURE) ||
           (err == MODBUS_EXCEPTION_ACKNOWLEDGE) ||
           (err == MODBUS_EXCEPTION_SERVER_DEVICE_BUSY) ||
           (err == MODBUS_EXCEPTION_NEGATIVE_ACKNOWLEDGE) ||
           (err == MODBUS_EXCEPTION_MEMORY_PARITY_ERROR) ||
           (err == MODBUS_EXCEPTION_GATEWAY_PATH_UNAVAILABLE) ||
           (err == MODBUS_EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED);
}

/* Backward-compatible helpers ------------------------------------------------ */

static inline bool modbus_error_is_exception(modbus_error_t err)
{
    return mb_err_is_exception(err);
}

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_MB_ERR_H */
/* ===== End modbus/include/modbus/mb_err.h ===== */

/* ===== Begin modbus/include/modbus/transport_if.h ===== */
/**
 * @file transport_if.h
 * @brief Minimal, non-blocking transport interface shared by client and server code.
 */

#ifndef MODBUS_TRANSPORT_IF_H
#define MODBUS_TRANSPORT_IF_H

// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/mb_types.h> (amalgamated)

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Result metadata for transport I/O operations.
 */
typedef struct {
    mb_size_t processed; /**< Number of bytes sent/received in the operation. */
} mb_transport_io_result_t;

/**
 * @brief Function pointer prototype for non-blocking send operations.
 */
typedef mb_err_t (*mb_transport_send_fn)(void *ctx, const mb_u8 *buf, mb_size_t len, mb_transport_io_result_t *out);

/**
 * @brief Function pointer prototype for non-blocking receive operations.
 */
typedef mb_err_t (*mb_transport_recv_fn)(void *ctx, mb_u8 *buf, mb_size_t cap, mb_transport_io_result_t *out);

/**
 * @brief Function pointer prototype returning a monotonic timestamp in milliseconds.
 */
typedef mb_time_ms_t (*mb_transport_now_fn)(void *ctx);

/**
 * @brief Optional cooperative-yield callback (may be `NULL`).
 */
typedef void (*mb_transport_yield_fn)(void *ctx);

/**
 * @brief Non-blocking transport interface description.
 */
typedef struct {
    void *ctx;                      /**< User-supplied context forwarded to callbacks. */
    mb_transport_send_fn send;      /**< Send callback (required). */
    mb_transport_recv_fn recv;      /**< Receive callback (required). */
    mb_transport_now_fn now;        /**< Monotonic time source (required). */
    mb_transport_yield_fn yield;    /**< Optional cooperative-yield hook (may be `NULL`). */
} mb_transport_if_t;

/**
 * @brief Performs a guarded send using the provided transport interface.
 */
static inline mb_err_t mb_transport_send(const mb_transport_if_t *iface,
                                         const mb_u8 *buf,
                                         mb_size_t len,
                                         mb_transport_io_result_t *out)
{
    if (!iface || !iface->send || !buf) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }
    return iface->send(iface->ctx, buf, len, out);
}

/**
 * @brief Performs a guarded receive using the provided transport interface.
 */
static inline mb_err_t mb_transport_recv(const mb_transport_if_t *iface,
                                         mb_u8 *buf,
                                         mb_size_t cap,
                                         mb_transport_io_result_t *out)
{
    if (!iface || !iface->recv || !buf || cap == 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }
    return iface->recv(iface->ctx, buf, cap, out);
}

/**
 * @brief Fetches the current monotonic timestamp in milliseconds.
 */
static inline mb_time_ms_t mb_transport_now(const mb_transport_if_t *iface)
{
    if (!iface || !iface->now) {
        return 0U;
    }
    return iface->now(iface->ctx);
}

/**
 * @brief Yields cooperatively to the underlying platform when supported.
 */
static inline void mb_transport_yield(const mb_transport_if_t *iface)
{
    if (iface && iface->yield) {
        iface->yield(iface->ctx);
    }
}

/**
 * @brief Computes the elapsed time in milliseconds since @p since.
 *
 * Returns zero when @p iface is NULL or the clock rolled backwards.
 */
static inline mb_time_ms_t mb_transport_elapsed_since(const mb_transport_if_t *iface,
                                                      mb_time_ms_t since)
{
    if (!iface) {
        return 0U;
    }

    const mb_time_ms_t now = mb_transport_now(iface);
    return (now >= since) ? (now - since) : 0U;
}

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_TRANSPORT_IF_H */
/* ===== End modbus/include/modbus/transport_if.h ===== */

/* ===== Begin modbus/include/modbus/transport.h ===== */
/**
 * @file modbus_transport.h
 * @brief Abstraction layer for Modbus transport operations.
 *
 * This header defines the structures and function pointers required to abstract
 * the underlying transport layer used by the Modbus library. The goal is to
 * allow different hardware or platform implementations (e.g., UART, TCP) to be
 * integrated seamlessly into the Modbus stack.
 *
 * Both Client and Server implementations can utilize this interface to send and
 * receive frames, as well as manage timing functions (for timeouts and
 * inter-character delays).
 *
 * Users of the library must provide implementations that match these
 * function pointers and set them into the Modbus context before initiating
 * protocol operations.
 * 
 * **Example functions that must be provided by the user:**
 *  - `read()`:  Blocking or non-blocking read of a specified number of bytes.
 *  - `write()`: Write a specified number of bytes.
 *  - `get_reference_msec()`: Get a timestamp (in ms) reference.
 *  - `measure_time_msec()`:  Measure elapsed time from a reference.
 *  - **Optional:**
 *      - `change_baudrate()`: Change the baud rate (for RTU).
 *      - `restart_uart()`: Restart the UART or underlying interface.
 *      - `write_gpio()`: Control GPIO pins (for RS485 DE/RE control).
 *
 * **Usage Example:**
 * ```c
 * #include "modbus_transport.h"
 * 
 * // Implement the required transport functions
 * int32_t uart_read(uint8_t *buf, uint16_t count) {
 *     // UART read implementation
 * }
 * 
 * int32_t uart_write(const uint8_t *buf, uint16_t count) {
 *     // UART write implementation
 * }
 * 
 * uint16_t get_current_msec(void) {
 *     // Return current timestamp in milliseconds
 * }
 * 
 * uint16_t measure_elapsed_time(uint16_t ref) {
 *     // Calculate elapsed time since reference
 * }
 * 
 * // Initialize transport
 * modbus_transport_t transport = {
 *     .transport = MODBUS_TRANSPORT_RTU,
 *     .read = uart_read,
 *     .write = uart_write,
 *     .get_reference_msec = get_current_msec,
 *     .measure_time_msec = measure_elapsed_time,
 *     .change_baudrate = NULL, // Optional
 *     .restart_uart = NULL,    // Optional
 *     .write_gpio = NULL,      // Optional
 *     .parse_bootloader_request = NULL, // Optional
 *     .arg = NULL              // User-specific data
 * };
 * ```
 * 
 * @author
 * Luiz Carlos Gili
 * 
 * @date
 * 2024-12-20
 *
 * @addtogroup ModbusTransport
 * @{
 */
 
#ifndef MODBUS_TRANSPORT_H
#define MODBUS_TRANSPORT_H

#include <stdint.h>
#include <stddef.h>

// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/transport_if.h> (amalgamated)

#ifdef __cplusplus
extern "C"{
#endif 

/**
 * @brief Enumeration of Modbus transport types.
 *
 * Currently supports RTU and TCP. Additional transport types can be added in the future.
 */
typedef enum {
    MODBUS_TRANSPORT_RTU = 1,    /**< RTU transport type */
    MODBUS_TRANSPORT_TCP = 2,    /**< TCP transport type */
    MODBUS_TRANSPORT_ASCII = 3   /**< ASCII transport type */
} modbus_transport_type_t;

/**
 * @brief Structure holding platform-specific function pointers for I/O and timing.
 *
 * Users must populate this structure with appropriate functions that implement the
 * read, write, timing, and (optionally) UART control operations. These functions
 * are utilized by both Client and Server instances of the Modbus stack.
 *
 * **Fields:**
 * - `transport`: Specifies the type of transport (RTU or TCP).
 * - `read`: Function pointer for reading data from the transport.
 * - `write`: Function pointer for writing data to the transport.
 * - `get_reference_msec`: Function pointer to retrieve a reference timestamp in milliseconds.
 * - `measure_time_msec`: Function pointer to measure elapsed time since a reference timestamp.
 * - `change_baudrate`: (Optional) Function pointer to change the baud rate (RTU only).
 * - `restart_uart`: (Optional) Function pointer to restart the UART or underlying interface.
 * - `write_gpio`: (Optional) Function pointer to control GPIO pins (e.g., RS485 DE/RE control).
 * - `parse_bootloader_request`: (Optional) Function pointer to parse bootloader requests.
 * - `arg`: User-defined argument pointer for storing platform-specific data or context.
 *
 * **Function Pointer Descriptions:**
 * - `read`: Should read up to `count` bytes into `buf`. Returns the number of bytes read, 
 *   0 to `count-1` if a timeout occurred (partial read), or a negative value if an error occurred.
 * - `write`: Should write `count` bytes from `buf`. Returns the number of bytes written or a negative value on error.
 * - `get_reference_msec`: Should return the current timestamp in milliseconds.
 * - `measure_time_msec`: Should return the elapsed time in milliseconds since the provided reference timestamp.
 * - `change_baudrate`: Should change the baud rate to the specified value. Returns the actual baud rate set.
 * - `restart_uart`: Should restart the UART or underlying interface. No return value.
 * - `write_gpio`: Should set the specified GPIO pin to the given value. Returns 0 on success, else an error code.
 * - `parse_bootloader_request`: Should parse incoming bootloader requests. Returns 0 on success, else an error code.
 *
 * **Notes:**
 * - Optional function pointers should be set to `NULL` if not applicable.
 * - The `arg` field can be used to pass additional context or state to the transport functions.
 */
typedef struct {
    modbus_transport_type_t transport; /**< Transport type (RTU or TCP). */

    /**
     * @brief Read function pointer.
     *
     * Reads `count` bytes into `buf`. Should return:
     * - The number of bytes actually read if successful.
     * - 0 to `count-1` if a timeout occurred (partial read).
     * - A negative value if a transport error occurred.
     *
     * @param buf   Buffer to store read data.
     * @param count Number of bytes to read.
     * @return int32_t Number of bytes read or error code.
     *
     * @example
     * ```c
     * int32_t uart_read(uint8_t *buf, uint16_t count) {
     *     // Implement UART read logic here
     * }
     * ```
     */
    int32_t (*read)(uint8_t *buf, uint16_t count);

    /**
     * @brief Write function pointer.
     *
     * Writes `count` bytes from `buf`. Should return:
     * - The number of bytes actually written if successful.
     * - A negative value if a transport error occurred.
     *
     * @param buf   Buffer containing data to write.
     * @param count Number of bytes to write.
     * @return int32_t Number of bytes written or error code.
     *
     * @example
     * ```c
     * int32_t uart_write(const uint8_t *buf, uint16_t count) {
     *     // Implement UART write logic here
     * }
     * ```
     */
    int32_t (*write)(const uint8_t *buf, uint16_t count);

    /**
     * @brief Retrieves a reference timestamp in milliseconds.
     *
     * Typically returns a millisecond counter since system startup. Used as a reference
     * for measuring intervals and handling timeouts.
     *
     * @return uint16_t Reference time in milliseconds.
     *
     * @example
     * ```c
     * uint16_t get_current_msec(void) {
     *     // Implement timestamp retrieval logic here
     * }
     * ```
     */
    uint16_t (*get_reference_msec)(void);

    /**
     * @brief Measures elapsed time in milliseconds from a given reference.
     *
     * Given a previously acquired timestamp from `get_reference_msec()`, returns
     * how many milliseconds have passed since that reference.
     *
     * @param ref Reference timestamp obtained from `get_reference_msec()`.
     * @return uint16_t Elapsed time in milliseconds.
     *
     * @example
     * ```c
     * uint16_t measure_elapsed_time(uint16_t ref) {
     *     // Implement elapsed time calculation logic here
     * }
     * ```
     */
    uint16_t (*measure_time_msec)(uint16_t ref);

    /**
     * @brief Optional function to change the baud rate.
     *
     * Only relevant for RTU transport. If not applicable, set to `NULL`.
     *
     * @param baudrate New baud rate to set.
     * @return uint16_t The actual baud rate set.
     *
     * @example
     * ```c
     * uint16_t change_uart_baudrate(uint16_t baudrate) {
     *     // Implement baud rate change logic here
     * }
     * ```
     */
    uint16_t (*change_baudrate)(uint16_t baudrate);

    /**
     * @brief Optional function to restart the UART or underlying interface.
     *
     * If not applicable, set to `NULL`.
     *
     * @example
     * ```c
     * void restart_uart_interface(void) {
     *     // Implement UART restart logic here
     * }
     * ```
     */
    void (*restart_uart)(void);

    /**
     * @brief Optional function to write to a GPIO pin (for RS485 DE/RE control).
     *
     * If not needed, set to `NULL`.
     *
     * @param gpio  GPIO pin identifier.
     * @param value Value to write to the pin (0 or 1).
     * @return uint8_t Status code (0 = success, else error).
     *
     * @example
     * ```c
     * uint8_t control_rs485_de_re(uint8_t gpio, uint8_t value) {
     *     // Implement GPIO control logic here
     * }
     * ```
     */
    uint8_t (*write_gpio)(uint8_t gpio, uint8_t value);

    /**
     * @brief Optional function to parse a bootloader request, if applicable.
     *
     * Specific to certain implementations. If not applicable, set to `NULL`.
     *
     * @param buffer      Pointer to the data buffer.
     * @param buffer_size Pointer to the buffer size (in/out).
     * @return uint8_t Status code (0 = success, else error).
     *
     * @example
     * ```c
     * uint8_t parse_bootloader_req(uint8_t *buffer, uint16_t *buffer_size) {
     *     // Implement bootloader request parsing logic here
     * }
     * ```
     */
    uint8_t (*parse_bootloader_request)(uint8_t *buffer, uint16_t *buffer_size);

    /**
     * @brief User-defined argument pointer.
     *
     * Can be used to store platform-specific data or context that the read/write
     * functions may require.
     *
     * @example
     * ```c
     * typedef struct {
     *     UART_HandleTypeDef uart_handle;
     *     GPIO_TypeDef *gpio_port;

     *     uint16_t gpio_pin;
     * } transport_context_t;
     * 
     * transport_context_t ctx = {
     *     .uart_handle = huart1,
     *     .gpio_port = GPIOA,
     *     .gpio_pin = GPIO_PIN_5
     * };
     * 
     * modbus_transport_t transport = {
     *     .transport = MODBUS_TRANSPORT_RTU,
     *     .read = uart_read,
     *     .write = uart_write,
     *     .get_reference_msec = get_current_msec,
     *     .measure_time_msec = measure_elapsed_time,
     *     .change_baudrate = change_uart_baudrate,
     *     .restart_uart = restart_uart_interface,
     *     .write_gpio = control_rs485_de_re,
     *     .parse_bootloader_request = NULL,
     *     .arg = &ctx
     * };
     * ```
     */
    void* arg;
} modbus_transport_t;

/**
 * @brief Binds a legacy transport descriptor to the lightweight interface.
 *
 * This helper wires the classic blocking callbacks into an ``mb_transport_if_t``
 * shim so newer code paths can rely on the non-blocking façade while existing
 * platforms keep the richer ``modbus_transport_t`` structure.
 *
 * @param[out] iface   Interface instance to populate.
 * @param[in]  legacy  Legacy transport descriptor to bridge.
 *
 * @return ``MODBUS_ERROR_NONE`` when the shim was installed successfully or an
 *         error code if the legacy descriptor is incomplete.
 */
mb_err_t modbus_transport_bind_legacy(mb_transport_if_t *iface, modbus_transport_t *legacy);

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_TRANSPORT_H */

/** @} */
/* ===== End modbus/include/modbus/transport.h ===== */

/* ===== Begin modbus/include/modbus/base.h ===== */
/**
 * @file base.h
 * @brief Common definitions for Modbus Master and Slave implementations.
 *
 * This header provides common enumerations, data structures, and type definitions
 * used by both Modbus Master and Slave implementations. It is designed to be
 * portable and flexible, without dependencies on specific hardware or protocol variants.
 *
 * **Key Features:**
 * - Defines Modbus error and exception codes.
 * - Provides a generic `modbus_context_t` structure for holding platform configuration,
 *   transport interfaces, and user-specific data.
 * - Includes data structures for managing holding registers and their callbacks.
 * - Contains utility macros and constants related to the Modbus protocol.
 *
 * **Usage:**
 * - Include this header in your Master or Slave code to access common Modbus definitions.
 * - Platform-dependent operations (I/O, timing) and higher-level states (FSM) are defined elsewhere.
 * - Example:
 *   ```c
 *   #include "base.h"
 *   
 *   void setup_modbus() {
 *       modbus_context_t ctx;
 *       // Initialize context and transport
 *       // ...
 *   }
 *   ```
 *
 * @author
 * Luiz Carlos Gili
 * 
 * @date
 * 2024-12-20
 *
 * @addtogroup ModbusCore
 * @{
 */

#ifndef MODBUS_BASE_H
#define MODBUS_BASE_H

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C"{
#endif

// #include <modbus/mb_types.h> (amalgamated)
// #include <modbus/conf.h> (amalgamated)
// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/transport.h> (amalgamated)
// #include <modbus/transport_if.h> (amalgamated)

/* -------------------------------------------------------------------------- */
/*                          Modbus Protocol Constants                         */
/* -------------------------------------------------------------------------- */

/**
 * @brief Modbus broadcast address.
 *
 * This address is used to send messages to all slaves on the network.
 */
#define MODBUS_BROADCAST_ADDRESS      0x00U

/**
 * @brief Modbus bootloader address.
 *
 * This address is reserved for bootloader operations.
 */
#define MODBUS_BOOTLOADER_ADDRESS     0xA5U

/**
 * @brief Utility macro to extract the low byte from a 16-bit value.
 *
 * @param d The 16-bit value.
 * @return The low byte of the value.
 *
 * @example
 * ```c
 * uint16_t value = 0x1234;
 * uint8_t low = GET_LOW_BYTE(value); // low = 0x34
 * ```
 */
#define GET_LOW_BYTE(d)       ((uint8_t)((d) & 0x00FFU))

/**
 * @brief Utility macro to extract the high byte from a 16-bit value.
 *
 * @param d The 16-bit value.
 * @return The high byte of the value.
 *
 * @example
 * ```c
 * uint16_t value = 0x1234;
 * uint8_t high = GET_HIGH_BYTE(value); // high = 0x12
 * ```
 */
#define GET_HIGH_BYTE(d)      ((uint8_t)(((d) >> 8U) & 0x00FFU))

/* -------------------------------------------------------------------------- */
/*                                Modbus Roles                                */
/* -------------------------------------------------------------------------- */

/**
 * @brief Enumeration defining the role of a Modbus instance.
 *
 * A single codebase can support both Client and Server roles by selecting the role
 * at runtime or compile time.
 */
typedef enum {
    MODBUS_ROLE_CLIENT = 0, /**< Client role */
    MODBUS_ROLE_SERVER  = 1  /**< Server role */
} modbus_role_t;

/* -------------------------------------------------------------------------- */
/*                         Variable and Register Handling                     */
/* -------------------------------------------------------------------------- */

/**
 * @brief Callback type for reading a Modbus variable (e.g., holding register).
 *
 * This callback should return the current value of the variable.
 *
 * @return The current value of the variable as a 16-bit integer.
 *
 * @example
 * ```c
 * int16_t read_temperature(void) {
 *     return current_temperature;
 * }
 * ```
 */
typedef int16_t (*modbus_read_callback_t)(void);

/**
 * @brief Callback type for writing a Modbus variable (e.g., holding register).
 *
 * The callback receives the new value and should write it to the variable if allowed.
 * It returns the value actually written, which may differ if necessary.
 *
 * @param new_value The new value to write to the variable.
 * @return The value that was actually written.
 *
 * @example
 * ```c
 * int16_t write_temperature(int16_t new_value) {
 *     if (new_value < MIN_TEMP || new_value > MAX_TEMP) {
 *         return current_temperature; // Do not change if out of range
 *     }
 *     current_temperature = new_value;
 *     return current_temperature;
 * }
 * ```
 */
typedef int16_t (*modbus_write_callback_t)(int16_t new_value);

/**
 * @brief Structure representing a Modbus variable (e.g., holding register).
 *
 * Each variable is identified by an address and can be read-only or read/write.
 * Optional read and write callbacks can be provided for custom logic.
 */
typedef struct {
    int16_t *variable_ptr;                     /**< Pointer to the variable in memory */
    modbus_read_callback_t read_callback;      /**< Optional callback for reading the variable */
    modbus_write_callback_t write_callback;    /**< Optional callback for writing the variable */
    bool read_only;                            /**< Indicates if the variable is read-only */
    uint16_t address;                          /**< Modbus address of this variable */
} variable_modbus_t;

/* -------------------------------------------------------------------------- */
/*                           Modbus Context Structure                         */
/* -------------------------------------------------------------------------- */

/**
 * @brief The Modbus context structure holds all necessary data for both Client and Server.
 *
 * **Fields:**
 * - `transport`: Platform-specific I/O and timing functions.
 * - `role`: Specifies whether the context is for a Client or Server.
 * - `rx_buffer`: Buffer for incoming data.
 * - `rx_count`: Number of bytes currently in the receive buffer.
 * - `rx_index`: Current index in the receive buffer.
 * - `tx_raw_buffer`: Raw buffer for outgoing data.
 * - `tx_index`: Current index in the transmit buffer.
 * - `tx_buffer`: Processed buffer for outgoing data.
 * - `rx_reference_time`: Timestamp for receiving data, used for handling timeouts.
 * - `tx_reference_time`: Timestamp for transmitting data, used for handling timeouts.
 * - `error_timer`: Timer for tracking errors.
 * - `user_data`: Pointer for user-specific context or data.
 *
 * **Usage:**
 * - Initialize this structure before using Modbus Client or Server functions.
 * - Populate `transport` with appropriate I/O and timing functions.
 * - Set `role` to `MODBUS_ROLE_MASTER` or `MODBUS_ROLE_SLAVE` based on usage.
 *
 * **Example:**
 * ```c
 * modbus_context_t ctx;
 * modbus_transport_init_mock(&ctx.transport);
 * ctx.role = MODBUS_ROLE_CLIENT;
 * ctx.user_data = &application_data;
 * ```
 */
typedef struct {
    modbus_transport_t transport;      /**< Platform-specific I/O and timing functions */
    mb_transport_if_t transport_iface; /**< Lightweight, non-blocking transport shim */

    modbus_role_t role;           /**< Client or Server role */

    uint8_t *rx_buffer;           /**< Buffer for incoming data */
    uint16_t rx_capacity;         /**< Capacity of the RX buffer */
    uint16_t rx_count;            /**< Number of bytes in the receive buffer */
    uint16_t rx_index;            /**< Current index in the receive buffer */

    uint8_t *rx_raw_buffer;       /**< Buffer for raw RX bytes */
    uint16_t rx_raw_capacity;     /**< Capacity of the raw RX buffer */

    uint8_t *tx_raw_buffer;       /**< Raw buffer for outgoing data */
    uint16_t tx_raw_capacity;     /**< Capacity of the raw TX buffer */
    uint16_t tx_raw_index;        /**< Current index in the raw transmit buffer */

    uint8_t *tx_buffer;           /**< Processed buffer for outgoing data */
    uint16_t tx_capacity;         /**< Capacity of the processed TX buffer */
    uint16_t tx_index;            /**< Current index in the processed buffer */

    mb_time_ms_t rx_reference_time;   /**< Timestamp for receiving data, used in timeouts */
    mb_time_ms_t tx_reference_time;   /**< Timestamp for transmitting data, used in timeouts */
    mb_time_ms_t error_timer;         /**< Timer for tracking errors */

    void *user_data;              /**< Pointer for user-specific context */

    struct {
        uint8_t rx[MODBUS_RECEIVE_BUFFER_SIZE];       /**< Default RX buffer storage */
        uint8_t rx_raw[MODBUS_RECEIVE_BUFFER_SIZE];   /**< Default raw RX buffer storage */
        uint8_t tx_raw[MODBUS_SEND_BUFFER_SIZE];      /**< Default raw TX buffer storage */
        uint8_t tx[MODBUS_SEND_BUFFER_SIZE];          /**< Default processed TX buffer storage */
    } internal_buffers;
} modbus_context_t;

static inline void modbus_context_use_internal_buffers(modbus_context_t *ctx)
{
    if (ctx == NULL) {
        return;
    }

    if (ctx->rx_buffer == NULL) {
        ctx->rx_buffer = ctx->internal_buffers.rx;
        ctx->rx_capacity = (uint16_t)MB_COUNTOF(ctx->internal_buffers.rx);
    }

    if (ctx->rx_raw_buffer == NULL) {
        ctx->rx_raw_buffer = ctx->internal_buffers.rx_raw;
        ctx->rx_raw_capacity = (uint16_t)MB_COUNTOF(ctx->internal_buffers.rx_raw);
    }

    if (ctx->tx_raw_buffer == NULL) {
        ctx->tx_raw_buffer = ctx->internal_buffers.tx_raw;
        ctx->tx_raw_capacity = (uint16_t)MB_COUNTOF(ctx->internal_buffers.tx_raw);
    }

    if (ctx->tx_buffer == NULL) {
        ctx->tx_buffer = ctx->internal_buffers.tx;
        ctx->tx_capacity = (uint16_t)MB_COUNTOF(ctx->internal_buffers.tx);
    }
}

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_BASE_H */

/** @} */
/* ===== End modbus/include/modbus/base.h ===== */

/* ===== Begin modbus/include/modbus/utils.h ===== */
/**
 * @file modbus_utils.h
 * @brief Utility functions for Modbus protocol operations.
 *
 * This header provides helper functions to safely read data from buffers,
 * as well as functions to sort and search arrays of Modbus variables.
 * Additionally, it includes functions to calculate CRC-16 checksums, which are
 * essential for ensuring data integrity in Modbus communications.
 *
 * **Key Features:**
 * - Safe reading of 8-bit and 16-bit unsigned integers from buffers.
 * - Sorting and searching utilities for arrays of `variable_modbus_t`.
 * - CRC-16 calculation using both bit-by-bit and table-driven approaches.
 *
 * **Usage:**
 * - Include this header in your Modbus Client or Server implementation to utilize
 *   the provided utility functions.
 * - Example:
 *   ```c
 *   #include "utils.h"
 *   
 *   void example_usage(const uint8_t *data, uint16_t size) {
 *       uint16_t index = 0;
 *       uint8_t value8;
 *       uint16_t value16;
 *       
 *       if (modbus_read_uint8(data, &index, size, &value8)) {
 *           // Successfully read an 8-bit value
 *       }
 *       
 *       if (modbus_read_uint16(data, &index, size, &value16)) {
 *           // Successfully read a 16-bit value
 *       }
 *   }
 *   ```
 * 
 * @note
 * - Ensure that the buffer provided to the read functions is properly allocated and contains sufficient data.
 * - The sorting function uses selection sort; for larger datasets, consider implementing a more efficient sorting algorithm.
 *
 * @author
 * Luiz Carlos Gili
 * 
 * @date
 * 2024-12-20
 *
 * @addtogroup ModbusUtils
 * @{
 */

#ifndef MODBUS_UTILS_H
#define MODBUS_UTILS_H

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>


#ifdef __cplusplus
extern "C"{
#endif 

// #include <modbus/base.h> (amalgamated)

/**
 * @def MODBUS_CONVERT_CHAR_INTERVAL_TO_MS
 * @brief Converts a character interval time from microseconds to milliseconds based on baud rate.
 *
 * This macro calculates the equivalent time in milliseconds for a given character interval
 * in microseconds (`TIME_US`) and a specified baud rate (`BAUDRATE`). It accounts for
 * the typical 11 bits per character in Modbus RTU (1 start bit, 8 data bits, 1 parity bit, 1 stop bit).
 *
 * @param TIME_US   Character interval time in microseconds.
 * @param BAUDRATE  Communication baud rate.
 * @return Calculated time in milliseconds.
 *
 * @example
 * ```c
 * #define TIME_US 100000 // 100 ms
 * #define BAUDRATE 19200
 * uint16_t interval_ms = MODBUS_CONVERT_CHAR_INTERVAL_TO_MS(TIME_US, BAUDRATE);
 * // interval_ms will be approximately 572 ms
 * ```
 */
#define MODBUS_CONVERT_CHAR_INTERVAL_TO_MS(TIME_US, BAUDRATE) \
        ((1000U * (TIME_US) * 11) / (BAUDRATE))

/**
 * @brief Safely reads an 8-bit unsigned integer from a buffer.
 *
 * This function checks if there is enough space in the buffer before reading
 * an 8-bit value. If reading would exceed the buffer size, it returns `false`.
 *
 * @param[in]  buffer       Pointer to the data buffer.
 * @param[in,out] index     Pointer to the current read index in the buffer. It is incremented by one on success.
 * @param[in]  buffer_size  Size of the buffer in bytes.
 * @param[out] value        Pointer to the variable where the read value will be stored.
 *
 * @return `true` if the value was successfully read, `false` if not enough data.
 *
 * @example
 * ```c
 * uint8_t data[] = {0x12, 0x34};
 * uint16_t idx = 0;
 * uint8_t val;
 * if (modbus_read_uint8(data, &idx, 2, &val)) {
 *     // val = 0x12
 * }
 * ```
 */
bool modbus_read_uint8(const uint8_t *buffer, uint16_t *index, uint16_t buffer_size, uint8_t *value);

/**
 * @brief Safely reads a 16-bit unsigned integer from a buffer (big-endian).
 *
 * This function checks if there is enough space in the buffer before reading
 * a 16-bit value. It reads two bytes from the buffer and combines them into
 * a 16-bit value, interpreting the first read byte as the high-order byte.
 *
 * @param[in]  buffer       Pointer to the data buffer.
 * @param[in,out] index     Pointer to the current read index in the buffer. It is incremented by two on success.
 * @param[in]  buffer_size  Size of the buffer in bytes.
 * @param[out] value        Pointer to the variable where the read 16-bit value will be stored.
 *
 * @return `true` if the value was successfully read, `false` if not enough data.
 *
 * @example
 * ```c
 * uint8_t data[] = {0x12, 0x34};
 * uint16_t idx = 0;
 * uint16_t val;
 * if (modbus_read_uint16(data, &idx, 2, &val)) {
 *     // val = 0x1234
 * }
 * ```
 */
bool modbus_read_uint16(const uint8_t *buffer, uint16_t *index, uint16_t buffer_size, uint16_t *value);

/**
 * @brief Sorts an array of Modbus variables by their address using selection sort.
 *
 * This function organizes the array of `variable_modbus_t` in ascending order
 * based on the `address` field. Selection sort is used due to its simplicity.
 *
 * @param[in,out] modbus_variables Array of Modbus variables to sort.
 * @param[in] length               Number of elements in the array.
 *
 * @note
 * - Selection sort has a time complexity of O(n²). For larger datasets, consider using more efficient sorting algorithms.
 *
 * @example
 * ```c
 * variable_modbus_t vars[3] = {
 *     {.address = 3},
 *     {.address = 1},
 *     {.address = 2}
 * };
 * modbus_selection_sort(vars, 3);
 * // vars now sorted by address: 1, 2, 3
 * ```
 */
void modbus_selection_sort(variable_modbus_t modbus_variables[], int length);

/**
 * @brief Performs a binary search on an array of Modbus variables sorted by address.
 *
 * Given a sorted array of `variable_modbus_t` (sorted by `address`), this function
 * searches for a given address using binary search. It returns the index of the matching
 * variable or -1 if the address is not found.
 *
 * @param[in] modbus_variables Sorted array of Modbus variables.
 * @param[in] low              Lowest index of the search range.
 * @param[in] high             Highest index of the search range.
 * @param[in] value            Address value to search for.
 *
 * @return The index of the variable with the matching address, or -1 if not found.
 *
 * @example
 * ```c
 * variable_modbus_t vars[3] = {
 *     {.address = 1},
 *     {.address = 2},
 *     {.address = 3}
 * };
 * int index = modbus_binary_search(vars, 0, 2, 2);
 * // index = 1
 * ```
 */
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
int modbus_binary_search(variable_modbus_t modbus_variables[], uint16_t low, uint16_t high, uint16_t value);
// NOLINTEND(bugprone-easily-swappable-parameters)

/**
 * @brief Extracts a 32-bit unsigned integer from two holding registers using ABCD order.
 */
uint32_t modbus_get_uint32_abcd(const uint16_t *registers);

/**
 * @brief Extracts a 32-bit unsigned integer from two holding registers using DCBA order.
 */
uint32_t modbus_get_uint32_dcba(const uint16_t *registers);

/**
 * @brief Extracts a 32-bit unsigned integer from two holding registers using BADC order.
 */
uint32_t modbus_get_uint32_badc(const uint16_t *registers);

/**
 * @brief Extracts a 32-bit unsigned integer from two holding registers using CDAB order.
 */
uint32_t modbus_get_uint32_cdab(const uint16_t *registers);

void modbus_set_uint32_abcd(uint32_t value, uint16_t *dest);
void modbus_set_uint32_dcba(uint32_t value, uint16_t *dest);
void modbus_set_uint32_badc(uint32_t value, uint16_t *dest);
void modbus_set_uint32_cdab(uint32_t value, uint16_t *dest);

int32_t modbus_get_int32_abcd(const uint16_t *registers);
int32_t modbus_get_int32_dcba(const uint16_t *registers);
int32_t modbus_get_int32_badc(const uint16_t *registers);
int32_t modbus_get_int32_cdab(const uint16_t *registers);

void modbus_set_int32_abcd(int32_t value, uint16_t *dest);
void modbus_set_int32_dcba(int32_t value, uint16_t *dest);
void modbus_set_int32_badc(int32_t value, uint16_t *dest);
void modbus_set_int32_cdab(int32_t value, uint16_t *dest);

float modbus_get_float_abcd(const uint16_t *registers);
float modbus_get_float_dcba(const uint16_t *registers);
float modbus_get_float_badc(const uint16_t *registers);
float modbus_get_float_cdab(const uint16_t *registers);

void modbus_set_float_abcd(float value, uint16_t *dest);
void modbus_set_float_dcba(float value, uint16_t *dest);
void modbus_set_float_badc(float value, uint16_t *dest);
void modbus_set_float_cdab(float value, uint16_t *dest);

/**
 * @brief Calculates the Modbus CRC-16 using a bit-by-bit algorithm.
 *
 * This function iterates over each byte in the given data buffer and updates the
 * CRC value accordingly. While less efficient than a table-driven approach, it
 * is straightforward and does not require a precomputed table.
 *
 * @param[in] data   Pointer to the data buffer for which to calculate CRC.
 * @param[in] length Number of bytes in the data buffer.
 *
 * @return The calculated CRC-16 value.
 *
 * @note
 * - Bit-by-bit CRC calculation is simple but may be slower for large data buffers.
 *
 * @example
 * ```c
 * uint8_t frame[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02};
 * uint16_t crc = modbus_calculate_crc(frame, 6);
 * // crc = 0xC5C9 (example value)
 * ```
 */
uint16_t modbus_calculate_crc(const uint8_t *data, uint16_t length);

/**
 * @brief Calculates the Modbus CRC-16 using a lookup table.
 *
 * This function uses a precomputed lookup table to calculate the Modbus CRC-16
 * more efficiently. It is generally faster than the bit-by-bit approach.
 *
 * @param[in] data   Pointer to the data buffer for which to calculate CRC.
 * @param[in] length Number of bytes in the data buffer.
 *
 * @return The calculated CRC-16 value.
 *
 * @note
 * - Lookup table CRC calculation is faster but requires additional memory for the table.
 * - Ensure that the CRC table is correctly initialized before using this function.
 *
 * @example
 * ```c
 * uint8_t frame[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02};
 * uint16_t crc = modbus_crc_with_table(frame, 6);
 * // crc = 0xC5C9 (example value)
 * ```
 */
uint16_t modbus_crc_with_table(const uint8_t *data, uint16_t length);

/**
 * @brief Validates the trailing Modbus CRC-16 in a frame.
 *
 * This helper verifies that the last two bytes of @p frame match the CRC of the
 * preceding bytes. The check uses the table-driven CRC implementation for
 * performance and accepts frames with at least two bytes reserved for the CRC
 * trailer. The CRC stored in the frame is expected in little-endian order
 * (least significant byte first), as defined by the Modbus specification.
 *
 * @param[in] frame   Pointer to the full Modbus frame (PDU/ADU) including CRC.
 * @param[in] length  Total frame length in bytes, including the CRC trailer.
 *
 * @return `true` if the frame pointer is valid, the length is >= 2, and the
 *         CRC matches the calculated value; `false` otherwise.
 */
bool modbus_crc_validate(const uint8_t *frame, uint16_t length);

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_UTILS_H */

/** @} */
/* ===== End modbus/include/modbus/utils.h ===== */

/* ===== Begin modbus/include/modbus/ringbuf.h ===== */
/**
 * @file ringbuf.h
 * @brief Single-producer / single-consumer ring buffer utilities.
 *
 * The ring buffer offers a lock-free queue for moving bytes between a
 * producer and a consumer running in different scheduling contexts (for
 * example ISR ↔ main loop).  The implementation keeps monotonically
 * increasing write/read cursors so wrap-around is handled via masking.
 *
 * The API is intentionally small: initialise the buffer with external
 * storage, push or pop bytes (optionally in bulk), and query the
 * occupancy.  The caller is responsible for providing any required
 * memory barriers when used across execution contexts.
 */

#ifndef MODBUS_RINGBUF_H
#define MODBUS_RINGBUF_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

// #include <modbus/mb_err.h> (amalgamated)

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Ring buffer descriptor.
 *
 * The structure keeps explicit cursors and the current occupancy.  The @p mask is
 * derived from @p capacity and is used to wrap the physical index into the provided
 * storage.
 */
typedef struct mb_ringbuf {
    uint8_t *buffer;      /**< Backing storage provided by the caller. */
    size_t   capacity;    /**< Total number of bytes that fit in @ref buffer. */
    size_t   mask;        /**< Cached (capacity - 1) for fast wrap-around. */
    size_t   head;        /**< Read cursor. */
    size_t   tail;        /**< Write cursor. */
    size_t   count;       /**< Number of bytes currently stored. */
} mb_ringbuf_t;

mb_err_t mb_ringbuf_init(mb_ringbuf_t *rb, uint8_t *storage, size_t capacity);
void     mb_ringbuf_reset(mb_ringbuf_t *rb);

size_t mb_ringbuf_capacity(const mb_ringbuf_t *rb);
size_t mb_ringbuf_size(const mb_ringbuf_t *rb);
size_t mb_ringbuf_free(const mb_ringbuf_t *rb);

bool mb_ringbuf_is_empty(const mb_ringbuf_t *rb);
bool mb_ringbuf_is_full(const mb_ringbuf_t *rb);

size_t mb_ringbuf_write(mb_ringbuf_t *rb, const uint8_t *data, size_t len);
size_t mb_ringbuf_read(mb_ringbuf_t *rb, uint8_t *out, size_t len);

bool mb_ringbuf_push(mb_ringbuf_t *rb, uint8_t byte);
bool mb_ringbuf_pop(mb_ringbuf_t *rb, uint8_t *out_byte);

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_RINGBUF_H */
/* ===== End modbus/include/modbus/ringbuf.h ===== */

/* ===== Begin modbus/include/modbus/mempool.h ===== */
/**
 * @file mempool.h
 * @brief Fixed-size block memory pool (no malloc required).
 */

#ifndef MODBUS_MEMPOOL_H
#define MODBUS_MEMPOOL_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/mb_types.h> (amalgamated)

#ifdef __cplusplus
extern "C" {
#endif

typedef struct mb_mempool {
    mb_u8     *storage;
    mb_size_t  block_size;
    mb_size_t  block_count;
    mb_size_t  free_count;
    void      *free_list;
} mb_mempool_t;

mb_err_t mb_mempool_init(mb_mempool_t *pool,
                         void *buffer,
                         mb_size_t block_size,
                         mb_size_t block_count);

void mb_mempool_reset(mb_mempool_t *pool);

void *mb_mempool_acquire(mb_mempool_t *pool);
mb_err_t mb_mempool_release(mb_mempool_t *pool, void *block);

mb_size_t mb_mempool_capacity(const mb_mempool_t *pool);
mb_size_t mb_mempool_free_count(const mb_mempool_t *pool);

bool mb_mempool_contains(const mb_mempool_t *pool, const void *block);

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_MEMPOOL_H */
/* ===== End modbus/include/modbus/mempool.h ===== */

/* ===== Begin modbus/include/modbus/log.h ===== */
/**
 * \file
 *
 * \brief Log: lightweight logging for embedded systems
 *
 * A quick intro by example:
 *
 *     #include "ulog.h"
 *
 *     // To use uLog, you must define a function to process logging messages.
 *     // It can write the messages to a console, to a file, to an in-memory
 *     // buffer: the choice is yours.  And you get to choose the format of
 *     // the message.  This example prints to the console.  One caveat: msg
 *     // is a static string and will be over-written at the next call to ULOG.
 *     // You may print it or copy it, but saving a pointer to it will lead to
 *     // confusion and astonishment.
 *     //
 *     void my_console_logger(ulog_level_t level, const char *msg) {
 *         printf("%s [%s]: %s\n",
 *             get_timestamp(),
 *             ulog_level_name(level),
 *             msg);
 *     }
 *
 *     int main() {
 *         LOG_INIT();
 *
 *         // log to the console messages that are WARNING or more severe.  You
 *         // can re-subscribe at any point to change the severity level.
 *         LOG_SUBSCRIBE(my_console_logger, LOG_WARNING);
 *
 *         // log to a file messages that are DEBUG or more severe
 *         LOG_SUBSCRIBE(my_file_logger, LOG_DEBUG);
 *
 *         int arg = 42;
 *         LOG_INFO("Arg is %d", arg);  // logs to file but not console
 *     }
 */

#ifndef LOG_H_
#define LOG_H_

#ifdef __cplusplus
extern "C" {
    #endif
// #include <modbus/conf.h> (amalgamated)

typedef enum {
  LOG_TRACE_LEVEL=100,
  LOG_DEBUG_LEVEL,
  LOG_INFO_LEVEL,
  LOG_WARNING_LEVEL,
  LOG_ERROR_LEVEL,
  LOG_CRITICAL_LEVEL,
  LOG_ALWAYS_LEVEL
} log_level_t;


// The following macros enable or disable uLog.  If `LOG_ENABLED` is
// defined at compile time, a macro such as `LOG_INFO(...)` expands
// into `log_message(LOG_INFO_LEVEL, ...)`.  If `LOG_ENABLED` is not
// defined, then the same macro expands into `do {} while(0)` and will
// not generate any code at all.  
//
// There are two ways to enable uLog: you can uncomment the following
// line, or -- if it is commented out -- you can add -DLOG_ENABLED to
// your compiler switches.
//#define LOG_ENABLED

#ifdef LOG_ENABLED
  #define LOG_INIT() log_init()
  #define LOG_SUBSCRIBE(a, b) log_subscribe(a, b)
  #define LOG_UNSUBSCRIBE(a) log_unsubscribe(a)
  #define LOG_LEVEL_NAME(a) log_level_name(a)
  #define LOG(...) log_message(__VA_ARGS__)
  #define LOG_TRACE(...) log_message(LOG_TRACE_LEVEL, __VA_ARGS__)
  #define LOG_DEBUG(...) log_message(LOG_DEBUG_LEVEL, __VA_ARGS__)
  #define LOG_INFO(...) log_message(LOG_INFO_LEVEL, __VA_ARGS__)
  #define LOG_WARNING(...) log_message(LOG_WARNING_LEVEL, __VA_ARGS__)
  #define LOG_ERROR(...) log_message(LOG_ERROR_LEVEL, __VA_ARGS__)
  #define LOG_CRITICAL(...) log_message(LOG_CRITICAL_LEVEL, __VA_ARGS__)
  #define LOG_ALWAYS(...) log_message(LOG_ALWAYS_LEVEL, __VA_ARGS__)
#else
  // uLog vanishes when disabled at compile time...
  #define LOG_INIT() do {} while(0)
  #define LOG_SUBSCRIBE(a, b) do {} while(0)
  #define LOG_UNSUBSCRIBE(a) do {} while(0)
  #define LOG_LEVEL_NAME(a) do {} while(0)
  #define LOG(s, f, ...) do {} while(0)
  #define LOG_TRACE(f, ...) do {} while(0)
  #define LOG_DEBUG(f, ...) do {} while(0)
  #define LOG_INFO(f, ...) do {} while(0)
  #define LOG_WARNING(f, ...) do {} while(0)
  #define LOG_ERROR(f, ...) do {} while(0)
  #define LOG_CRITICAL(f, ...) do {} while(0)
  #define LOG_ALWAYS(f, ...) do {} while(0)
#endif

typedef enum {
  LOG_ERR_NONE = 0,
  LOG_ERR_SUBSCRIBERS_EXCEEDED,
  LOG_ERR_NOT_SUBSCRIBED,
} log_err_t;

// define the maximum number of concurrent subscribers
#ifndef LOG_MAX_SUBSCRIBERS
#define LOG_MAX_SUBSCRIBERS 6
#endif
// maximum length of formatted log message
#ifndef LOG_MAX_MESSAGE_LENGTH
#define LOG_MAX_MESSAGE_LENGTH 120
#endif
/**
 * @brief: prototype for uLog subscribers.
 */
typedef void (*log_function_t)(log_level_t severity, char *msg);

void log_init(void);
log_err_t log_subscribe(log_function_t fn, log_level_t threshold);
log_err_t log_unsubscribe(log_function_t fn);
const char *log_level_name(log_level_t level);
void log_message(log_level_t severity, const char *fmt, ...);

#ifdef __cplusplus
}
#endif

#endif /* LOG_H_ */
/* ===== End modbus/include/modbus/log.h ===== */

/* ===== Begin modbus/include/modbus/mb_log.h ===== */
/**
 * @file mb_log.h
 * @brief Lightweight logging façade shared across the Modbus library.
 *
 * The module re-exports the underlying logging implementation through
 * Modbus-specific names so applications can configure sinks and thresholds
 * without depending on the internal headers.
 */

#ifndef MODBUS_MB_LOG_H
#define MODBUS_MB_LOG_H

// #include <modbus/log.h> (amalgamated)

#ifdef __cplusplus
extern "C" {
#endif

/* -------------------------------------------------------------------------- */
/* Public aliases                                                              */
/* -------------------------------------------------------------------------- */

typedef log_level_t mb_log_level_t;
typedef log_err_t mb_log_err_t;
typedef log_function_t mb_log_function_t;

#define MB_LOG_TRACE_LEVEL    LOG_TRACE_LEVEL
#define MB_LOG_DEBUG_LEVEL    LOG_DEBUG_LEVEL
#define MB_LOG_INFO_LEVEL     LOG_INFO_LEVEL
#define MB_LOG_WARNING_LEVEL  LOG_WARNING_LEVEL
#define MB_LOG_ERROR_LEVEL    LOG_ERROR_LEVEL
#define MB_LOG_CRITICAL_LEVEL LOG_CRITICAL_LEVEL
#define MB_LOG_ALWAYS_LEVEL   LOG_ALWAYS_LEVEL

#define MB_LOG_ERR_NONE               LOG_ERR_NONE
#define MB_LOG_ERR_SUBSCRIBERS_EXCEEDED LOG_ERR_SUBSCRIBERS_EXCEEDED
#define MB_LOG_ERR_NOT_SUBSCRIBED     LOG_ERR_NOT_SUBSCRIBED

#ifdef LOG_ENABLED
#define MB_LOG_ENABLED 1
#else
#define MB_LOG_ENABLED 0
#endif

/* -------------------------------------------------------------------------- */
/* Configuration                                                              */
/* -------------------------------------------------------------------------- */

#ifndef MB_LOG_ENABLE_STDIO
#define MB_LOG_ENABLE_STDIO 1
#endif

#ifndef MB_LOG_ENABLE_SEGGER_RTT
#define MB_LOG_ENABLE_SEGGER_RTT 0
#endif

#ifndef MB_LOG_DEFAULT_THRESHOLD
#define MB_LOG_DEFAULT_THRESHOLD MB_LOG_INFO_LEVEL
#endif

#ifndef MB_LOG_STDOUT_SYNC_FLUSH
#define MB_LOG_STDOUT_SYNC_FLUSH 1
#endif

#ifndef MB_LOG_RTT_CHANNEL
#define MB_LOG_RTT_CHANNEL 0
#endif

/* -------------------------------------------------------------------------- */
/* Logging macros (passthrough)                                               */
/* -------------------------------------------------------------------------- */

#define MB_LOG_INIT()        LOG_INIT()
#define MB_LOG_SUBSCRIBE(fn, threshold) LOG_SUBSCRIBE((fn), (threshold))
#define MB_LOG_UNSUBSCRIBE(fn)          LOG_UNSUBSCRIBE((fn))
#define MB_LOG_LEVEL_NAME(level)        LOG_LEVEL_NAME((level))

#define MB_LOG_TRACE(...)    LOG_TRACE(__VA_ARGS__)
#define MB_LOG_DEBUG(...)    LOG_DEBUG(__VA_ARGS__)
#define MB_LOG_INFO(...)     LOG_INFO(__VA_ARGS__)
#define MB_LOG_WARNING(...)  LOG_WARNING(__VA_ARGS__)
#define MB_LOG_ERROR(...)    LOG_ERROR(__VA_ARGS__)
#define MB_LOG_CRITICAL(...) LOG_CRITICAL(__VA_ARGS__)
#define MB_LOG_ALWAYS(...)   LOG_ALWAYS(__VA_ARGS__)


/* -------------------------------------------------------------------------- */
/* Convenience helpers                                                        */
/* -------------------------------------------------------------------------- */

void mb_log_bootstrap_defaults(void);

#if MB_LOG_ENABLE_STDIO
mb_log_err_t mb_log_subscribe_stdio(mb_log_level_t threshold);
#else
static inline mb_log_err_t mb_log_subscribe_stdio(mb_log_level_t threshold)
{
	(void)threshold;
	return LOG_ERR_NOT_SUBSCRIBED;
}
#endif

#if MB_LOG_ENABLE_SEGGER_RTT
mb_log_err_t mb_log_subscribe_rtt(mb_log_level_t threshold);
#else
static inline mb_log_err_t mb_log_subscribe_rtt(mb_log_level_t threshold)
{
	(void)threshold;
	return LOG_ERR_NOT_SUBSCRIBED;
}
#endif

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_MB_LOG_H */
/* ===== End modbus/include/modbus/mb_log.h ===== */

/* ===== Begin modbus/include/modbus/pdu.h ===== */
/**
 * @file pdu.h
 * @brief Helpers to encode and decode Modbus Protocol Data Units.
 */

#ifndef MODBUS_PDU_H
#define MODBUS_PDU_H

#include <stdbool.h>
#include <stddef.h>

// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/mb_types.h> (amalgamated)

#ifdef __cplusplus
extern "C" {
#endif

#define MB_PDU_MAX 253U

#define MB_PDU_FC_READ_COILS                    0x01U
#define MB_PDU_FC_READ_DISCRETE_INPUTS          0x02U
#define MB_PDU_FC_READ_HOLDING_REGISTERS        0x03U
#define MB_PDU_FC_READ_INPUT_REGISTERS          0x04U
#define MB_PDU_FC_WRITE_SINGLE_COIL             0x05U
#define MB_PDU_FC_WRITE_SINGLE_REGISTER         0x06U
#define MB_PDU_FC_READ_EXCEPTION_STATUS         0x07U
#define MB_PDU_FC_WRITE_MULTIPLE_COILS          0x0FU
#define MB_PDU_FC_WRITE_MULTIPLE_REGISTERS      0x10U
#define MB_PDU_FC_REPORT_SERVER_ID              0x11U
#define MB_PDU_FC_MASK_WRITE_REGISTER           0x16U
#define MB_PDU_FC_READ_WRITE_MULTIPLE_REGISTERS 0x17U

#define MB_PDU_EXCEPTION_BIT 0x80U

#define MB_PDU_COIL_OFF_VALUE 0x0000U
#define MB_PDU_COIL_ON_VALUE  0xFF00U

#define MB_PDU_FC01_MIN_COILS   1U
#define MB_PDU_FC01_MAX_COILS   2000U
#define MB_PDU_FC02_MIN_INPUTS  1U
#define MB_PDU_FC02_MAX_INPUTS  2000U
#define MB_PDU_FC03_MIN_REGISTERS 1U
#define MB_PDU_FC03_MAX_REGISTERS 125U
#define MB_PDU_FC04_MIN_REGISTERS 1U
#define MB_PDU_FC04_MAX_REGISTERS 125U

#define MB_PDU_FC16_MIN_REGISTERS 1U
#define MB_PDU_FC16_MAX_REGISTERS 123U

#define MB_PDU_FC0F_MIN_COILS  1U
#define MB_PDU_FC0F_MAX_COILS  1968U

#define MB_PDU_FC17_MIN_READ_REGISTERS   1U
#define MB_PDU_FC17_MAX_READ_REGISTERS   125U
#define MB_PDU_FC17_MIN_WRITE_REGISTERS  1U
#define MB_PDU_FC17_MAX_WRITE_REGISTERS  121U

#define MB_PDU_FC11_MAX_PAYLOAD 251U

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
mb_err_t mb_pdu_build_read_coils_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 quantity);
mb_err_t mb_pdu_parse_read_coils_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_quantity);

mb_err_t mb_pdu_build_read_coils_response(mb_u8 *out, mb_size_t out_cap, const bool *coils, mb_u16 count);
mb_err_t mb_pdu_parse_read_coils_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u8 *out_byte_count);

mb_err_t mb_pdu_build_read_discrete_inputs_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 quantity);
mb_err_t mb_pdu_parse_read_discrete_inputs_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_quantity);

mb_err_t mb_pdu_build_read_discrete_inputs_response(mb_u8 *out, mb_size_t out_cap, const bool *inputs, mb_u16 count);
mb_err_t mb_pdu_parse_read_discrete_inputs_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u8 *out_byte_count);

mb_err_t mb_pdu_build_read_holding_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 quantity);
mb_err_t mb_pdu_parse_read_holding_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_quantity);

mb_err_t mb_pdu_build_read_holding_response(mb_u8 *out, mb_size_t out_cap, const mb_u16 *registers, mb_u16 count);
mb_err_t mb_pdu_parse_read_holding_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u16 *out_register_count);

mb_err_t mb_pdu_build_read_input_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 quantity);
mb_err_t mb_pdu_parse_read_input_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_quantity);

mb_err_t mb_pdu_build_read_input_response(mb_u8 *out, mb_size_t out_cap, const mb_u16 *registers, mb_u16 count);
mb_err_t mb_pdu_parse_read_input_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u16 *out_register_count);

mb_err_t mb_pdu_build_write_single_request(mb_u8 *out, mb_size_t out_cap, mb_u16 address, mb_u16 value);
mb_err_t mb_pdu_parse_write_single_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, mb_u16 *out_value);
mb_err_t mb_pdu_build_write_single_response(mb_u8 *out, mb_size_t out_cap, mb_u16 address, mb_u16 value);
mb_err_t mb_pdu_parse_write_single_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, mb_u16 *out_value);

mb_err_t mb_pdu_build_write_single_coil_request(mb_u8 *out, mb_size_t out_cap, mb_u16 address, bool coil_on);
mb_err_t mb_pdu_parse_write_single_coil_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, bool *out_coil_on);
mb_err_t mb_pdu_build_write_single_coil_response(mb_u8 *out, mb_size_t out_cap, mb_u16 address, bool coil_on);
mb_err_t mb_pdu_parse_write_single_coil_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, bool *out_coil_on);

mb_err_t mb_pdu_build_read_exception_status_request(mb_u8 *out, mb_size_t out_cap);
mb_err_t mb_pdu_parse_read_exception_status_request(const mb_u8 *pdu, mb_size_t len);
mb_err_t mb_pdu_build_read_exception_status_response(mb_u8 *out, mb_size_t out_cap, mb_u8 status);
mb_err_t mb_pdu_parse_read_exception_status_response(const mb_u8 *pdu, mb_size_t len, mb_u8 *out_status);

mb_err_t mb_pdu_build_report_server_id_request(mb_u8 *out, mb_size_t out_cap);
mb_err_t mb_pdu_parse_report_server_id_request(const mb_u8 *pdu, mb_size_t len);
mb_err_t mb_pdu_build_report_server_id_response(mb_u8 *out, mb_size_t out_cap, const mb_u8 *payload, mb_size_t payload_len);
mb_err_t mb_pdu_parse_report_server_id_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u8 *out_byte_count);

mb_err_t mb_pdu_build_write_multiple_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, const mb_u16 *values, mb_u16 count);
mb_err_t mb_pdu_parse_write_multiple_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_count, const mb_u8 **out_payload);
mb_err_t mb_pdu_build_exception(mb_u8 *out, mb_size_t out_cap, mb_u8 function, mb_u8 exception_code);
mb_err_t mb_pdu_parse_exception(const mb_u8 *pdu, mb_size_t len, mb_u8 *out_function, mb_u8 *out_exception);


mb_err_t mb_pdu_build_write_multiple_response(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 count);
mb_err_t mb_pdu_parse_write_multiple_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_count);

mb_err_t mb_pdu_build_write_multiple_coils_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, const bool *coils, mb_u16 count);
mb_err_t mb_pdu_parse_write_multiple_coils_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_count, mb_u8 *out_byte_count, const mb_u8 **out_payload);
mb_err_t mb_pdu_build_write_multiple_coils_response(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 count);
mb_err_t mb_pdu_parse_write_multiple_coils_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_count);

mb_err_t mb_pdu_build_mask_write_register_request(mb_u8 *out, mb_size_t out_cap, mb_u16 address, mb_u16 and_mask, mb_u16 or_mask);
mb_err_t mb_pdu_parse_mask_write_register_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, mb_u16 *out_and_mask, mb_u16 *out_or_mask);
mb_err_t mb_pdu_build_mask_write_register_response(mb_u8 *out, mb_size_t out_cap, mb_u16 address, mb_u16 and_mask, mb_u16 or_mask);
mb_err_t mb_pdu_parse_mask_write_register_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, mb_u16 *out_and_mask, mb_u16 *out_or_mask);

mb_err_t mb_pdu_build_read_write_multiple_request(mb_u8 *out, mb_size_t out_cap, mb_u16 read_start_addr, mb_u16 read_quantity, mb_u16 write_start_addr, const mb_u16 *write_values, mb_u16 write_quantity);
mb_err_t mb_pdu_parse_read_write_multiple_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_read_addr, mb_u16 *out_read_quantity, mb_u16 *out_write_addr, mb_u16 *out_write_quantity, const mb_u8 **out_write_payload);

mb_err_t mb_pdu_build_read_write_multiple_response(mb_u8 *out, mb_size_t out_cap, const mb_u16 *read_registers, mb_u16 read_quantity);
mb_err_t mb_pdu_parse_read_write_multiple_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u16 *out_register_count);
// NOLINTEND(bugprone-easily-swappable-parameters)

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_PDU_H */
/* ===== End modbus/include/modbus/pdu.h ===== */

/* ===== Begin modbus/include/modbus/frame.h ===== */
/**
 * @file frame.h
 * @brief Helpers to assemble and dissect Modbus Application Data Units.
 */

#ifndef MODBUS_FRAME_H
#define MODBUS_FRAME_H

// #include <modbus/conf.h> (amalgamated)
// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/mb_types.h> (amalgamated)

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Lightweight view over a Modbus ADU payload.
 */
typedef struct {
    mb_u8 unit_id;           /**< Slave / server address (a.k.a. unit identifier). */
    mb_u8 function;          /**< Function code. */
    const mb_u8 *payload;    /**< Pointer to bytes immediately after the function code. */
    mb_size_t payload_len;   /**< Number of payload bytes (may be zero). */
} mb_adu_view_t;

/**
 * @brief Builds an RTU frame from the supplied ADU view.
 */
mb_err_t mb_frame_rtu_encode(const mb_adu_view_t *adu,
                             mb_u8 *out_adu,
                             mb_size_t out_cap,
                             mb_size_t *out_len);

/**
 * @brief Parses an RTU frame, validating CRC and extracting the ADU view.
 */
mb_err_t mb_frame_rtu_decode(const mb_u8 *adu,
                             mb_size_t adu_len,
                             mb_adu_view_t *out);

#if MB_CONF_TRANSPORT_ASCII
mb_err_t mb_frame_ascii_encode(const mb_adu_view_t *adu,
                               mb_u8 *out_ascii,
                               mb_size_t out_cap,
                               mb_size_t *out_len);

mb_err_t mb_frame_ascii_decode(const mb_u8 *ascii,
                               mb_size_t ascii_len,
                               mb_adu_view_t *out,
                               mb_u8 *payload_buf,
                               mb_size_t payload_cap);
#endif

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_FRAME_H */
/* ===== End modbus/include/modbus/frame.h ===== */

/* ===== Begin modbus/include/modbus/transport/rtu.h ===== */
/**
 * @file transport/rtu.h
 * @brief Minimal RTU transport built on top of the non-blocking transport interface.
 */

#ifndef MODBUS_TRANSPORT_RTU_H
#define MODBUS_TRANSPORT_RTU_H

#include <stdbool.h>

// #include <modbus/conf.h> (amalgamated)

#if MB_CONF_TRANSPORT_RTU
// #include <modbus/frame.h> (amalgamated)
// #include <modbus/pdu.h> (amalgamated)
// #include <modbus/transport_if.h> (amalgamated)

#ifdef __cplusplus
extern "C" {
#endif

#define MB_RTU_DEFAULT_SILENCE_TIMEOUT_MS 5U
#define MB_RTU_BUFFER_SIZE (MB_PDU_MAX + 4U)

typedef struct mb_rtu_transport mb_rtu_transport_t;

typedef void (*mb_rtu_frame_callback_t)(mb_rtu_transport_t *rtu,
                                        const mb_adu_view_t *adu,
                                        mb_err_t status,
                                        void *user);

struct mb_rtu_transport {
    const mb_transport_if_t *iface;
    mb_time_ms_t silence_timeout_ms;
    mb_time_ms_t last_activity;
    mb_u8 buffer[MB_RTU_BUFFER_SIZE];
    mb_size_t index;
    bool receiving;
    mb_rtu_frame_callback_t callback;
    void *user_ctx;
};

mb_err_t mb_rtu_init(mb_rtu_transport_t *rtu,
                     const mb_transport_if_t *iface,
                     mb_rtu_frame_callback_t callback,
                     void *user_ctx);

void mb_rtu_reset(mb_rtu_transport_t *rtu);

void mb_rtu_set_silence_timeout(mb_rtu_transport_t *rtu, mb_time_ms_t timeout_ms);

mb_err_t mb_rtu_poll(mb_rtu_transport_t *rtu);

mb_err_t mb_rtu_submit(mb_rtu_transport_t *rtu, const mb_adu_view_t *adu);

#ifdef __cplusplus
}
#endif

#endif /* MB_CONF_TRANSPORT_RTU */

#endif /* MODBUS_TRANSPORT_RTU_H */
/* ===== End modbus/include/modbus/transport/rtu.h ===== */

/* ===== Begin modbus/include/modbus/core.h ===== */
/**
 * @file modbus_core.h
 * @brief Core Modbus protocol functions for both Client and Server.
 *
 * This header defines core functions and data structures used by both Modbus Client
 * and Server implementations. It focuses on:
 * - Building and parsing Modbus RTU frames.
 * - Performing CRC checks.
 * - Handling timeouts and inter-frame delays.
 * - Providing a generic interface for sending and receiving frames, leaving the
 *   specifics (which registers to read/write) to Client or Server logic.
 *
 * The idea is that Modbus Client or Server code calls these functions to handle the low-level
 * details of frame management, while the higher-level logic (e.g., deciding which registers
 * to read, handling device info requests) is implemented elsewhere.
 *
 * **Key Features:**
 * - Construction of Modbus RTU frames with CRC.
 * - Parsing and validation of received Modbus RTU frames.
 * - Sending and receiving frames through the configured transport layer.
 * - Utility functions to map Modbus exception codes to error types.
 * - Buffer management for Modbus transactions.
 *
 * **Usage Example:**
 * @code
 * // Building a Modbus RTU frame for reading holding registers
 * uint8_t request_data[] = {0x00, 0x01, 0x00, 0x02}; // Starting address and quantity
 * uint8_t frame[256];
 * uint16_t frame_length = modbus_build_rtu_frame(0x01, MODBUS_FUNC_READ_HOLDING_REGISTERS,
 *                                               request_data, sizeof(request_data),
 *                                               frame, sizeof(frame));
 *
 * // Sending the frame
 * modbus_send_frame(&ctx, frame, frame_length);
 *
 * // Receiving a response frame
 * uint8_t response_frame[256];
 * uint16_t response_length;
 * modbus_error_t error = modbus_receive_frame(&ctx, response_frame, sizeof(response_frame), &response_length);
 *
 * if (error == MODBUS_ERROR_NONE) {
 *     uint8_t address, function;
 *     const uint8_t *payload;
 *     uint16_t payload_len;
 *     error = modbus_parse_rtu_frame(response_frame, response_length, &address, &function, &payload, &payload_len);
 *     if (error == MODBUS_ERROR_NONE) {
 *         // Process payload
 *     }
 * }
 * @endcode
 *
 * **Notes:**
 * - Ensure that the transport layer is correctly initialized before using send and receive functions.
 * - Handle exceptions and error codes appropriately to maintain robust communication.
 * - The buffer sizes should be adequately defined based on the expected frame sizes.
 *
 * @see modbus_transport.h, modbus_utils.h, modbus_fsm.h
 *
 * @ingroup ModbusCore
 * @{
 */

#ifndef MODBUS_CORE_H
#define MODBUS_CORE_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C"{
#endif

// #include <modbus/conf.h> (amalgamated)
// #include <modbus/base.h> (amalgamated)
// #include <modbus/utils.h> (amalgamated)

/** 
 * @brief Common Modbus function codes (subset).
 *
 * More can be added as needed. Both Client and Server might reference these.
 */
typedef enum {
    MODBUS_FUNC_READ_COILS                    = 0x01U, /**< Read Coils */
    MODBUS_FUNC_READ_DISCRETE_INPUTS          = 0x02U, /**< Read Discrete Inputs */
    MODBUS_FUNC_READ_HOLDING_REGISTERS        = 0x03U, /**< Read Holding Registers */
    MODBUS_FUNC_READ_INPUT_REGISTERS          = 0x04U, /**< Read Input Registers */
    MODBUS_FUNC_WRITE_SINGLE_COIL             = 0x05U, /**< Write Single Coil */
    MODBUS_FUNC_WRITE_SINGLE_REGISTER         = 0x06U, /**< Write Single Register */
    MODBUS_FUNC_WRITE_MULTIPLE_COILS          = 0x0FU, /**< Write Multiple Coils */
    MODBUS_FUNC_WRITE_MULTIPLE_REGISTERS      = 0x10U, /**< Write Multiple Registers */
    MODBUS_FUNC_READ_WRITE_MULTIPLE_REGISTERS = 0x17U, /**< Read/Write Multiple Registers */
    MODBUS_FUNC_READ_DEVICE_INFORMATION       = 0x2BU, /**< Read Device Information */
    
    MODBUS_FUNC_ERROR_FRAME_HEADER            = 0x80U /**< Used to indicate an error response. */
} modbus_function_code_t;

/**
 * @brief Builds a Modbus RTU frame by adding CRC.
 *
 * This function takes the given address, function code, and data payload, and
 * appends the CRC to form a complete Modbus RTU frame in the provided buffer.
 *
 * @param[in]  address         Modbus server/client address (or target device address).
 * @param[in]  function_code   Modbus function code.
 * @param[in]  data            Pointer to the data payload (without CRC).
 * @param[in]  data_length     Length of the data payload.
 * @param[out] out_buffer      Buffer to store the complete frame (including CRC).
 * @param[in]  out_buffer_size Size of the out_buffer.
 * 
 * @return Number of bytes written to out_buffer, or 0 if there is not enough space.
 *
 * @retval >0  Number of bytes written to out_buffer.
 * @retval 0   Insufficient buffer size to store the complete frame.
 *
 * @example
 * ```c
 * uint8_t payload[] = {0x00, 0x01, 0x00, 0x02};
 * uint8_t frame[256];
 * uint16_t frame_len = modbus_build_rtu_frame(0x01, MODBUS_FUNC_READ_HOLDING_REGISTERS,
 *                                           payload, sizeof(payload),
 *                                           frame, sizeof(frame));
 * if (frame_len > 0) {
 *     // Frame successfully built, proceed to send
 * }
 * ```
 */
#if MB_CONF_TRANSPORT_RTU
uint16_t modbus_build_rtu_frame(uint8_t address, uint8_t function_code,
                                const uint8_t *data, uint16_t data_length,
                                uint8_t *out_buffer, uint16_t out_buffer_size);

/**
 * @brief Parses a Modbus RTU frame, verifying CRC.
 *
 * This function checks the CRC of the given frame. If valid, it extracts the address,
 * function code, and payload. The caller can then interpret the payload according to
 * the function code.  
 *
 * @param[in]  frame        Pointer to the frame buffer (address + function + data + CRC).
 * @param[in]  frame_length Length of the frame in bytes.
 * @param[out] address      Pointer to store the parsed address.
 * @param[out] function     Pointer to store the parsed function code.
 * @param[out] payload      Pointer to store the start of the payload (inside frame).
 * @param[out] payload_len  Pointer to store the length of the payload (excluding CRC).
 *
 * @return modbus_error_t `MODBUS_ERROR_NONE` if successful, or an error/exception code.
 *
 * @retval MODBUS_ERROR_NONE                  Frame parsed successfully.
 * @retval MODBUS_ERROR_INVALID_REQUEST        Frame length is too short or CRC is invalid.
 * @retval MODBUS_EXCEPTION_ILLEGAL_FUNCTION   The function code indicates an error response.
 * @retval Others                              Various error codes as defined in `modbus_error_t`.
 *
 * @example
 * ```c
 * uint8_t response_frame[] = {0x01, 0x03, 0x02, 0x00, 0x0A, 0xC4, 0x0B};
 * uint16_t response_length = sizeof(response_frame);
 * uint8_t address, function;
 * const uint8_t *payload;
 * uint16_t payload_len;
 *
 * modbus_error_t error = modbus_parse_rtu_frame(response_frame, response_length,
 *                                               &address, &function,
 *                                               &payload, &payload_len);
 * if (error == MODBUS_ERROR_NONE) {
 *     // Process payload
 * }
 * ```
 */
modbus_error_t modbus_parse_rtu_frame(const uint8_t *frame, uint16_t frame_length,
                                      uint8_t *address, uint8_t *function,
                                      const uint8_t **payload, uint16_t *payload_len);

/**
 * @brief Sends a Modbus frame using the configured transport.
 *
 * This function attempts to write the given frame to the transport. It returns
 * an error if it fails. It does not block indefinitely; the behavior depends
 * on the transport implementation.
 *
 * @param[in]  ctx         Pointer to the Modbus context.
 * @param[in]  frame       Pointer to the complete frame (including CRC).
 * @param[in]  frame_len   Length of the frame.
 *
 * @return modbus_error_t `MODBUS_ERROR_NONE` on success, or error code.
 *
 * @retval MODBUS_ERROR_NONE          Frame sent successfully.
 * @retval MODBUS_ERROR_TRANSPORT      Transport layer error occurred.
 * @retval Others                      Various error codes as defined in `modbus_error_t`.
 *
 * @example
 * ```c
 * uint8_t frame[] = {0x01, 0x03, 0x00, 0x01, 0x00, 0x02, 0xC4, 0x0B};
 * modbus_error_t error = modbus_send_frame(&ctx, frame, sizeof(frame));
 * if (error == MODBUS_ERROR_NONE) {
 *     // Frame sent successfully
 * }
 * ```
 */
modbus_error_t modbus_send_frame(modbus_context_t *ctx, const uint8_t *frame, uint16_t frame_len);

/**
 * @brief Receives a Modbus frame using the configured transport.
 *
 * This function tries to read a Modbus RTU frame from the transport. It may implement
 * timing logic (checking inter-character timeouts, frame timeouts).
 *
 * If a complete frame is successfully received and validated, it returns `MODBUS_ERROR_NONE`.
 * Otherwise, it returns an error code (e.g., `MODBUS_ERROR_TIMEOUT`, `MODBUS_ERROR_CRC`).
 *
 * @param[in]  ctx         Pointer to the Modbus context.
 * @param[out] out_buffer  Buffer to store the received frame.
 * @param[in]  out_size    Size of `out_buffer`.
 * @param[out] out_length  Pointer to store the received frame length.
 *
 * @return modbus_error_t `MODBUS_ERROR_NONE` on success, or error code.
 *
 * @retval MODBUS_ERROR_NONE          Frame received and validated successfully.
 * @retval MODBUS_ERROR_TIMEOUT        Timeout occurred while waiting for frame.
 * @retval MODBUS_ERROR_CRC            CRC check failed.
 * @retval Others                      Various error codes as defined in `modbus_error_t`.
 *
 * @example
 * ```c
 * uint8_t response_frame[256];
 * uint16_t response_length;
 * modbus_error_t error = modbus_receive_frame(&ctx, response_frame, sizeof(response_frame), &response_length);
 * if (error == MODBUS_ERROR_NONE) {
 *     // Process received frame
 * }
 * ```
 */
modbus_error_t modbus_receive_frame(modbus_context_t *ctx, uint8_t *out_buffer, uint16_t out_size, uint16_t *out_length);
#endif /* MB_CONF_TRANSPORT_RTU */

/**
 * @brief Helper function to check if a given function code indicates an error response.
 *
 * If the function code >= 0x80, it's typically an exception response from the server.
 *
 * @param[in]  function_code The function code from a received frame.
 * @return `true` if it is an error response, `false` otherwise.
 *
 * @example
 * ```c
 * uint8_t function = received_frame[1];
 * if (modbus_is_error_response(function)) {
 *     // Handle error response
 * }
 * ```
 */
static inline bool modbus_is_error_response(uint8_t function_code) {
    return (function_code & MODBUS_FUNC_ERROR_FRAME_HEADER) != 0;
}

/**
 * @brief Converts a Modbus exception code to a `modbus_error_t`.
 *
 * For example, if the payload indicates exception code 2 (Illegal Data Address),
 * this function returns `MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS`.
 *
 * @param[in]  exception_code The exception code from the Modbus frame.
 * @return A corresponding `modbus_error_t`.
 *
 * @retval MODBUS_EXCEPTION_ILLEGAL_FUNCTION           Exception code 1: Illegal Function
 * @retval MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS       Exception code 2: Illegal Data Address
 * @retval MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE         Exception code 3: Illegal Data Value
 * @retval MODBUS_EXCEPTION_SERVER_DEVICE_FAILURE      Exception code 4: Server Device Failure
 * @retval MODBUS_ERROR_OTHER_REQUESTS                 Other exception codes mapped to `modbus_error_t`
 *
 * @example
 * ```c
 * uint8_t exception_code = received_payload[0];
 * modbus_error_t error = modbus_exception_to_error(exception_code);
 * if (modbus_error_is_exception(error)) {
 *     // Handle the specific exception
 * }
 * ```
 */
modbus_error_t modbus_exception_to_error(uint8_t exception_code);

/**
 * @brief Convenience function to reset internal RX/TX counters in the context.
 *
 * This might be used when starting a new transaction or after an error.
 *
 * @param[in,out] ctx Pointer to the Modbus context.
 *
 * @example
 * ```c
 * modbus_reset_buffers(&ctx);
 * ```
 */
void modbus_reset_buffers(modbus_context_t *ctx);

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_CORE_H */

/** @} */
/* ===== End modbus/include/modbus/core.h ===== */

/* ===== Begin modbus/include/modbus/fsm.h ===== */
/**
 * @file fsm.h
 * @brief Finite State Machine (FSM) framework for event-driven execution.
 *
 * This header defines a generic Finite State Machine (FSM) framework, allowing
 * the creation of states, events, transitions, and actions. It is completely
 * independent of any hardware or protocol, making it suitable for use in a wide
 * range of embedded applications, including Modbus Client and Server implementations.
 *
 * **Features:**
 * - Each state can have multiple transitions triggered by specific events.
 * - Transitions can have optional guard functions (conditions) to determine if
 *   the transition is allowed.
 * - Actions can be associated with transitions to perform operations during
 *   state changes.
 * - Provides an event queue to safely handle events from both ISR and main loop.
 * - Non-blocking state handling: `fsm_run()` processes events incrementally.
 *
 * **Example Usage:**
 * @code
 * // Define action and guard callbacks
 * void on_enter_state(fsm_t *fsm) { 
 *     // Action to perform upon entering the state
 * }
 * 
 * bool guard_condition(fsm_t *fsm) { 
 *     // Condition to allow transition
 *     return true; 
 * }
 *
 * // Define transitions for the IDLE state
 * static const fsm_transition_t state_idle_transitions[] = {
 *     FSM_TRANSITION(EVENT_START, state_running, on_enter_state, guard_condition)
 * };
 *
 * // Define the IDLE state
 * const fsm_state_t state_idle = FSM_STATE("IDLE", 0, state_idle_transitions, NULL);
 *
 * // Define transitions for the RUNNING state
 * static const fsm_transition_t state_running_transitions[] = {
 *     FSM_TRANSITION(EVENT_STOP, state_idle, on_exit_state, NULL)
 * };
 *
 * // Define the RUNNING state
 * const fsm_state_t state_running = FSM_STATE("RUNNING", 1, state_running_transitions, on_run_action);
 *
 * // Initialize and use the FSM
 * fsm_t my_fsm;
 * fsm_init(&my_fsm, &state_idle, NULL);
 * fsm_handle_event(&my_fsm, EVENT_START);
 * fsm_run(&my_fsm);  // Processes EVENT_START and transitions to RUNNING state.
 * @endcode
 *
 * **Notes:**
 * - Ensure that states are defined before they are referenced in transitions.
 * - The FSM framework is designed to be thread-safe; however, ensure that
 *   event handling and state transitions are managed appropriately in concurrent environments.
 * 
 * @note
 * - Adjust `FSM_EVENT_QUEUE_SIZE` as necessary based on the expected event load.
 * - For larger applications, consider implementing more efficient event queue mechanisms.
 *
 * @author
 * Luiz Carlos Gili
 * 
 * @date
 * 2024-12-20
 *
 * @addtogroup FSM
 * @{
 */

#ifndef FSM_H
#define FSM_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef FSM_EVENT_STATE_TIMEOUT
#define FSM_EVENT_STATE_TIMEOUT  0xFF
#endif



/**
 * @brief Opaque structure representing the FSM.
 *
 * The FSM structure encapsulates the current state, user-defined data, and the event queue.
 */
typedef struct fsm fsm_t;

/**
 * @brief Opaque structure representing a state in the FSM.
 *
 * Each state is uniquely identified and contains transitions that define possible state changes.
 */
typedef struct fsm_state fsm_state_t;

/**
 * @brief Action function pointer type.
 *
 * Actions are functions executed when a transition occurs.
 *
 * @param fsm Pointer to the FSM instance.
 *
 * @example
 * ```c
 * void on_enter_state(fsm_t *fsm) {
 *     // Perform actions upon entering a new state
 * }
 * ```
 */
typedef void (*fsm_action_t)(fsm_t *fsm);

/**
 * @brief Guard function pointer type.
 *
 * Guards are boolean conditions that determine whether a transition can occur.
 *
 * @param fsm Pointer to the FSM instance.
 * @return `true` if the transition is allowed, `false` otherwise.
 *
 * @example
 * ```c
 * bool guard_condition(fsm_t *fsm) {
 *     // Check if a certain condition is met
 *     return (some_condition);
 * }
 * ```
 */
typedef bool (*fsm_guard_t)(fsm_t *fsm);

/**
 * @brief Structure representing a single transition in the FSM.
 *
 * Each transition is triggered by a specific event and can optionally have a guard
 * and an action. If the guard evaluates to true, the FSM transitions to the next
 * state and executes the action (if not NULL).
 */
typedef struct {
    uint8_t event;                  /**< Event that triggers the transition. */
    const fsm_state_t *next_state;  /**< Pointer to the next state after transition. */
    fsm_action_t action;            /**< Action executed during the transition (optional). */
    fsm_guard_t guard;              /**< Guard condition for the transition (optional). */
} fsm_transition_t;

/**
 * @brief Structure representing a state in the FSM.
 *
 * Each state has:
 * - An optional name (for debugging)
 * - A numeric ID
 * - A set of transitions triggered by events
 * - A default action executed if no events are pending (optional)
 */
struct fsm_state {
    const char *name;                       /**< Human-readable name of the state (optional). */
    uint8_t id;                             /**< Numeric ID of the state. */
    const fsm_transition_t *transitions;    /**< Array of transitions for this state. */
    uint8_t num_transitions;                /**< Number of transitions in the array. */
    fsm_action_t default_action;            /**< Default action executed when no events are pending (optional). */
    uint16_t timeout_ms; 	                /**< Timeout *deste* estado (0=desabilitado) */

};

/**
 * @brief Defines the size of the event queue.
 *
 * Adjust this as necessary. If the queue is full and a new event is handled,
 * the new event is discarded.
 */
#ifndef FSM_EVENT_QUEUE_SIZE
#define FSM_EVENT_QUEUE_SIZE 20
#endif

/**
 * @brief Structure for the FSM's event queue.
 *
 * Implements a circular buffer storing events until processed by `fsm_run()`.
 */
typedef struct {
    volatile uint8_t events[FSM_EVENT_QUEUE_SIZE];  /**< Circular buffer of events. */
    volatile uint8_t head;                          /**< Index of the next event to process. */
    volatile uint8_t tail;                          /**< Index where the next event will be added. */
} fsm_event_queue_t;

/**
 * @brief Structure representing the finite state machine.
 *
 * The FSM holds:
 * - The current state
 * - User-defined data pointer for application-specific context
 * - An event queue for storing incoming events
 */
struct fsm {
    const fsm_state_t *current_state;   /**< Pointer to the current state. */
    void *user_data;                    /**< User data associated with the FSM instance. */
    fsm_event_queue_t event_queue;      /**< Event queue for handling asynchronous events. */
    uint16_t state_entry_time;
    bool has_timeout;
};

/**
 * @brief Initializes the FSM.
 *
 * Sets the initial state and associates optional user data. Resets the event queue.
 *
 * @param fsm            Pointer to the FSM instance.
 * @param initial_state  Pointer to the initial state.
 * @param user_data      Pointer to user-defined data (can be `NULL`).
 *
 * @example
 * ```c
 * fsm_t my_fsm;
 * fsm_init(&my_fsm, &state_idle, &app_context);
 * ```
 */
void fsm_init(fsm_t *fsm, const fsm_state_t *initial_state, void *user_data);

/**
 * @brief Queues an event for the FSM.
 *
 * This function adds an event to the FSM's event queue. If the queue is full, the event is discarded.
 *
 * @param fsm   Pointer to the FSM instance.
 * @param event Event to handle.
 *
 * @example
 * ```c
 * fsm_handle_event(&my_fsm, EVENT_START);
 * ```
 */
void fsm_handle_event(fsm_t *fsm, uint8_t event);

/**
 * @brief Runs the FSM to process pending events.
 *
 * This function should be called regularly (e.g., in the main loop). It retrieves events
 * from the queue and checks transitions in the current state. If a matching transition
 * is found and its guard returns `true`, it executes the action and changes state.
 * If no event matches or no event is pending, it executes the state's default action (if any).
 *
 * @param fsm Pointer to the FSM instance.
 *
 * @example
 * ```c
 * while (1) {
 *     fsm_run(&my_fsm);
 *     // Other application code
 * }
 * ```
 */
void fsm_run(fsm_t *fsm);

/**
 * @brief Helper macro to define a transition.
 *
 * **Example:**
 * @code
 * FSM_TRANSITION(EVENT_X, next_state, my_action, my_guard);
 * @endcode
 *
 * @param _event      Triggering event.
 * @param _next_state Next state to transition to if guard is `true`.
 * @param _action     Action to execute during the transition (or `NULL`).
 * @param _guard      Guard function to evaluate (or `NULL`).
 *
 * @return Initialized `fsm_transition_t` structure.
 */
#define FSM_TRANSITION(_event, _next_state, _action, _guard) \
    { _event, &_next_state, _action, _guard }

/**
 * @brief Helper macro to define a state.
 *
 * **Example:**
 * @code
 * static const fsm_transition_t idle_transitions[] = {
 *     FSM_TRANSITION(EVENT_START, state_running, start_action, NULL)
 * };
 * const fsm_state_t state_idle = FSM_STATE("IDLE", 0, idle_transitions, NULL);
 * @endcode
 *
 * @param _name            Name of the state (string).
 * @param _state_id        Numeric ID of the state.
 * @param _transitions     Array of transitions.
 * @param _default_action  Default action function to execute when no events are pending (or `NULL`).
 *
 * @return Initialized `fsm_state_t` structure.
 */
#define FSM_STATE(_name, _state_id, _transitions, _default_action, _timeout) \
	{ #_name, _state_id, _transitions, sizeof(_transitions)/sizeof(fsm_transition_t), _default_action, _timeout }

#ifdef __cplusplus
}
#endif

#endif /* FSM_H */

/** @} */
/* ===== End modbus/include/modbus/fsm.h ===== */

/* ===== Begin modbus/include/modbus/observe.h ===== */
/**
 * @file observe.h
 * @brief Observability primitives (events, diagnostics and tracing controls).
 */

#ifndef MODBUS_OBSERVE_H
#define MODBUS_OBSERVE_H

#include <stdbool.h>
#include <stddef.h>

// #include <modbus/conf.h> (amalgamated)
// #include <modbus/frame.h> (amalgamated)
// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/mb_types.h> (amalgamated)

#ifdef __cplusplus
extern "C" {
#endif

/** @brief Identifies the component emitting an observability event. */
typedef enum {
    MB_EVENT_SOURCE_CLIENT = 0,
    MB_EVENT_SOURCE_SERVER = 1
} mb_event_source_t;

/** @brief Event categories surfaced through the observability callback. */
typedef enum {
    MB_EVENT_CLIENT_STATE_ENTER = 0,
    MB_EVENT_CLIENT_STATE_EXIT,
    MB_EVENT_CLIENT_TX_SUBMIT,
    MB_EVENT_CLIENT_TX_COMPLETE,
    MB_EVENT_SERVER_STATE_ENTER,
    MB_EVENT_SERVER_STATE_EXIT,
    MB_EVENT_SERVER_REQUEST_ACCEPT,
    MB_EVENT_SERVER_REQUEST_COMPLETE
} mb_event_type_t;

/** @brief Payload carried by an observability event. */
typedef struct mb_event {
    mb_event_source_t source;
    mb_event_type_t type;
    mb_time_ms_t timestamp;
    union {
        struct {
            mb_u8 state; /**< Client state identifier (see @ref mb_client_state_t). */
        } client_state;
        struct {
            mb_u8 state; /**< Server state identifier. */
        } server_state;
        struct {
            mb_u8 function;      /**< Function code associated with the transaction. */
            mb_err_t status;     /**< Completion status (MB_OK on success). */
            bool expect_response;/**< Whether the transaction expects a response. */
        } client_txn;
        struct {
            mb_u8 function;  /**< Function code of the request. */
            bool broadcast;  /**< True when the request was a broadcast (unit id == 0). */
            mb_err_t status; /**< Resulting status (exception or transport error). */
        } server_req;
    } data;
} mb_event_t;

/** @brief Callback signature used to surface observability events. */
typedef void (*mb_event_callback_t)(const mb_event_t *event, void *user_ctx);

/** @brief Canonical buckets used for error diagnostics counters. */
typedef enum {
    MB_DIAG_ERR_SLOT_OK = 0,
    MB_DIAG_ERR_SLOT_INVALID_ARGUMENT,
    MB_DIAG_ERR_SLOT_TIMEOUT,
    MB_DIAG_ERR_SLOT_TRANSPORT,
    MB_DIAG_ERR_SLOT_CRC,
    MB_DIAG_ERR_SLOT_INVALID_REQUEST,
    MB_DIAG_ERR_SLOT_OTHER_REQUESTS,
    MB_DIAG_ERR_SLOT_OTHER,
    MB_DIAG_ERR_SLOT_CANCELLED,
    MB_DIAG_ERR_SLOT_NO_RESOURCES,
    MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_FUNCTION,
    MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_DATA_ADDRESS,
    MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_DATA_VALUE,
    MB_DIAG_ERR_SLOT_EXCEPTION_SERVER_DEVICE_FAILURE,
    MB_DIAG_ERR_SLOT_EXCEPTION_ACKNOWLEDGE,
    MB_DIAG_ERR_SLOT_EXCEPTION_SERVER_DEVICE_BUSY,
    MB_DIAG_ERR_SLOT_EXCEPTION_NEGATIVE_ACKNOWLEDGE,
    MB_DIAG_ERR_SLOT_EXCEPTION_MEMORY_PARITY_ERROR,
    MB_DIAG_ERR_SLOT_EXCEPTION_GATEWAY_PATH_UNAVAILABLE,
    MB_DIAG_ERR_SLOT_EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED,
    MB_DIAG_ERR_SLOT_MAX
} mb_diag_err_slot_t;

/** @brief Aggregated counters grouped by function code and error bucket. */
typedef struct {
    mb_u64 function[256];
    mb_u64 error[MB_DIAG_ERR_SLOT_MAX];
} mb_diag_counters_t;

#if MB_CONF_DIAG_ENABLE_TRACE && (MB_CONF_DIAG_TRACE_DEPTH <= 0)
#error "MB_CONF_DIAG_TRACE_DEPTH must be greater than zero when trace diagnostics are enabled"
#endif

#if MB_CONF_DIAG_ENABLE_TRACE
typedef struct {
    mb_time_ms_t timestamp;
    mb_event_source_t source;
    mb_event_type_t type;
    mb_u8 function;
    mb_err_t status;
} mb_diag_trace_entry_t;

typedef struct {
    mb_diag_trace_entry_t entries[MB_CONF_DIAG_TRACE_DEPTH];
    mb_u16 head;
    mb_u16 count;
} mb_diag_trace_buffer_t;
#endif

typedef struct {
#if MB_CONF_DIAG_ENABLE_COUNTERS
    mb_diag_counters_t counters;
#endif
#if MB_CONF_DIAG_ENABLE_TRACE
    mb_diag_trace_buffer_t trace;
#endif
#if !MB_CONF_DIAG_ENABLE_COUNTERS && !MB_CONF_DIAG_ENABLE_TRACE
    mb_u8 reserved;
#endif
} mb_diag_state_t;

typedef struct {
#if MB_CONF_DIAG_ENABLE_COUNTERS
    mb_diag_counters_t counters;
#endif
#if MB_CONF_DIAG_ENABLE_TRACE
    mb_diag_trace_entry_t trace[MB_CONF_DIAG_TRACE_DEPTH];
    mb_u16 trace_len;
#endif
#if !MB_CONF_DIAG_ENABLE_COUNTERS && !MB_CONF_DIAG_ENABLE_TRACE
    mb_u8 reserved;
#endif
} mb_diag_snapshot_t;

void mb_diag_reset(mb_diag_counters_t *diag);
void mb_diag_record_fc(mb_diag_counters_t *diag, mb_u8 function);
void mb_diag_record_error(mb_diag_counters_t *diag, mb_err_t err);
mb_diag_err_slot_t mb_diag_slot_from_error(mb_err_t err);
const char *mb_diag_err_slot_str(mb_diag_err_slot_t slot);

void mb_diag_state_init(mb_diag_state_t *state);
void mb_diag_state_reset(mb_diag_state_t *state);
void mb_diag_state_record_fc(mb_diag_state_t *state, mb_u8 function);
void mb_diag_state_record_error(mb_diag_state_t *state, mb_err_t err);
void mb_diag_state_capture_event(mb_diag_state_t *state, const mb_event_t *event);
void mb_diag_snapshot(const mb_diag_state_t *state, mb_diag_snapshot_t *out_snapshot);

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_OBSERVE_H */
/* ===== End modbus/include/modbus/observe.h ===== */

/* ===== Begin modbus/include/modbus/client.h ===== */
/**
 * @file client.h
 * @brief Public API for the asynchronous Modbus client state machine.
 *
 * The client manages a queue of protocol transactions, applies retry and
 * watchdog policies, and bridges the higher layers to RTU or TCP transports
 * without blocking the caller.
 */

#ifndef MODBUS_CLIENT_H
#define MODBUS_CLIENT_H

// #include <modbus/conf.h> (amalgamated)

#if !MB_CONF_BUILD_CLIENT
#error "Modbus client support is disabled (enable MODBUS_ENABLE_CLIENT to use this header)."
#endif

#include <stdbool.h>
#include <stddef.h>

// #include <modbus/frame.h> (amalgamated)
// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/mb_types.h> (amalgamated)
// #include <modbus/observe.h> (amalgamated)
#if MB_CONF_TRANSPORT_RTU
// #include <modbus/transport/rtu.h> (amalgamated)
#endif
#if MB_CONF_TRANSPORT_TCP
// #include <modbus/transport/tcp.h> (amalgamated)
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define MB_CLIENT_DEFAULT_TIMEOUT_MS 1000U
#define MB_CLIENT_DEFAULT_RETRY_BACKOFF_MS 500U
#define MB_CLIENT_DEFAULT_WATCHDOG_MS 5000U
#define MB_CLIENT_MAX_TIMEOUT_MS 60000U

struct mb_client;
struct mb_client_txn;

#define MB_CLIENT_REQUEST_NO_RESPONSE   (1u << 0)
#define MB_CLIENT_REQUEST_HIGH_PRIORITY (1u << 1)
#define MB_CLIENT_REQUEST_POISON        (1u << 2)

typedef void (*mb_client_callback_t)(struct mb_client *client,
                                     const struct mb_client_txn *txn,
                                     mb_err_t status,
                                     const mb_adu_view_t *response,
                                     void *user_ctx);

typedef struct mb_client_request {
    uint32_t flags;
    mb_adu_view_t request;
    mb_time_ms_t timeout_ms;
    mb_u8 max_retries;
    mb_time_ms_t retry_backoff_ms;
    mb_client_callback_t callback;
    void *user_ctx;
} mb_client_request_t;

typedef struct mb_client_txn {
    bool in_use;
    bool queued;
    bool completed;
    bool cancelled;
    bool callback_pending;
    bool expect_response;
    bool high_priority;
    bool poison;
    mb_client_request_t cfg;
    mb_err_t status;
    mb_u8 retry_count;
    mb_u8 max_retries;
    mb_time_ms_t timeout_ms;
    mb_time_ms_t base_timeout_ms;
    mb_time_ms_t retry_backoff_ms;
    mb_time_ms_t deadline;
    mb_time_ms_t watchdog_deadline;
    mb_time_ms_t next_attempt_ms;
    mb_time_ms_t start_time;
    mb_adu_view_t request_view;
    mb_adu_view_t response_view;
    mb_u8 request_storage[MB_PDU_MAX];
    mb_u8 response_storage[MB_PDU_MAX];
    mb_u16 tid;
    struct mb_client_txn *next;
} mb_client_txn_t;

typedef enum {
    MB_CLIENT_STATE_IDLE = 0,
    MB_CLIENT_STATE_WAITING,
    MB_CLIENT_STATE_BACKOFF
} mb_client_state_t;

typedef enum {
    MB_CLIENT_TRANSPORT_RTU = 0,
    MB_CLIENT_TRANSPORT_TCP
} mb_client_transport_t;

typedef struct {
    mb_u64 submitted;
    mb_u64 completed;
    mb_u64 retries;
    mb_u64 timeouts;
    mb_u64 errors;
    mb_u64 cancelled;
    mb_u64 poison_triggers;
    mb_u64 bytes_tx;
    mb_u64 bytes_rx;
    mb_u64 response_count;
    mb_u64 response_latency_total_ms;
} mb_client_metrics_t;

typedef struct mb_client {
    const mb_transport_if_t *iface;
#if MB_CONF_TRANSPORT_RTU
    mb_rtu_transport_t rtu;
#endif
#if MB_CONF_TRANSPORT_TCP
    mb_tcp_transport_t tcp;
#endif
    mb_client_transport_t transport;
    mb_client_txn_t *pool;
    mb_size_t pool_size;
    mb_client_txn_t *pending_head;
    mb_client_txn_t *pending_tail;
    mb_client_txn_t *current;
    mb_client_state_t state;
    mb_time_ms_t watchdog_ms;
    mb_u16 next_tid;
    mb_size_t queue_capacity;
    mb_size_t pending_count;
    mb_time_ms_t fc_timeouts[256];
    mb_client_metrics_t metrics;
    mb_diag_state_t diag;
    mb_event_callback_t observer_cb;
    void *observer_user;
    bool trace_hex;
} mb_client_t;

/**
 * @brief Initialises a Modbus client instance bound to a transport.
 *
 * The client adopts @p iface as its non-blocking transport, clears the
 * transaction pool and applies default timeout/backoff configuration. Callers
 * must provide storage for the transaction descriptors in @p txn_pool.
 *
 * @param client        Client object to initialise.
 * @param iface         Transport interface implementing @ref mb_transport_if_t.
 * @param txn_pool      Array of transaction slots managed by the client.
 * @param txn_pool_len  Number of elements in @p txn_pool.
 *
 * @retval MB_OK                 Initialisation succeeded.
 * @retval MB_ERR_INVALID_ARGUMENT  One of the arguments was NULL or invalid.
 */
#if MB_CONF_TRANSPORT_RTU
mb_err_t mb_client_init(mb_client_t *client,
                        const mb_transport_if_t *iface,
                        mb_client_txn_t *txn_pool,
                        mb_size_t txn_pool_len);
#endif

/**
 * @brief Initialises a client instance targeting Modbus TCP transports.
 *
 * This variant wires the TCP transport helper, enabling transaction ID routing
 * and multi-socket aware callbacks. Parameters mirror @ref mb_client_init.
 *
 * @see mb_client_init
 *
 * @retval MB_OK                 Initialisation succeeded.
 * @retval MB_ERR_INVALID_ARGUMENT  One of the arguments was NULL or invalid.
 */
#if MB_CONF_TRANSPORT_TCP
mb_err_t mb_client_init_tcp(mb_client_t *client,
                            const mb_transport_if_t *iface,
                            mb_client_txn_t *txn_pool,
                            mb_size_t txn_pool_len);
#endif

/**
 * @brief Queues a Modbus request for transmission.
 *
 * The request is copied into an available transaction slot. When @p out_txn is
 * not NULL it receives the descriptor so callers can later inspect state or
 * cancel the operation. Requests flagged with
 * ::MB_CLIENT_REQUEST_HIGH_PRIORITY bypass the FIFO order while
 * ::MB_CLIENT_REQUEST_POISON flushes the queue.
 *
 * @param client   Client instance obtained from @ref mb_client_init.
 * @param request  Immutable request description; payload is copied internally.
 * @param out_txn  Optional pointer that receives the allocated transaction.
 *
 * @retval MB_OK              The request was queued successfully.
 * @retval MB_ERR_INVALID_ARGUMENT  Arguments were NULL or payload exceeded ::MB_PDU_MAX.
 * @retval MB_ERR_NO_RESOURCES No transaction slots or queue capacity available.
 */
mb_err_t mb_client_submit(mb_client_t *client,
                          const mb_client_request_t *request,
                          mb_client_txn_t **out_txn);

/**
 * @brief Injects a high-priority poison pill that drains the queue.
 *
 * The client stops after current work completes, leaving the FSM idle. Useful
 * when shutting down or when transports need to be reconfigured.
 *
 * @param client Client instance.
 *
 * @retval MB_OK                 Poison request queued successfully.
 * @retval MB_ERR_INVALID_ARGUMENT @p client was NULL.
 * @retval MB_ERR_NO_RESOURCES   No transaction slot available for the poison pill.
 */
mb_err_t mb_client_submit_poison(mb_client_t *client);

/**
 * @brief Cancels a previously submitted transaction.
 *
 * If the transaction is in-flight it is finalised with ::MB_ERR_CANCELLED. If
 * it was queued, it is removed from the pending list.
 *
 * @param client Client instance.
 * @param txn    Transaction descriptor obtained from @ref mb_client_submit.
 *
 * @retval MB_OK                  The transaction was cancelled successfully.
 * @retval MB_ERR_INVALID_ARGUMENT The transaction pointer was NULL or not in use.
 */
mb_err_t mb_client_cancel(mb_client_t *client, mb_client_txn_t *txn);

/**
 * @brief Advances the client finite-state machine.
 *
 * Poll this function from your event loop to progress retries, timeouts and
 * transport I/O.
 *
 * @param client Client instance.
 * @retval MB_OK             Operation succeeded or no work was required.
 * @retval MB_ERR_INVALID_ARGUMENT  @p client was NULL.
 * @retval other             Error codes bubbled up from the active transport.
 */
mb_err_t mb_client_poll(mb_client_t *client);

/**
 * @brief Configures the watchdog window for in-flight transactions.
 *
 * When non-zero, transactions exceeding @p watchdog_ms without progress are
 * aborted with ::MB_ERR_TRANSPORT.
 *
 * @param client      Client instance.
 * @param watchdog_ms Maximum inactivity window in milliseconds (0 disables).
 */
void mb_client_set_watchdog(mb_client_t *client, mb_time_ms_t watchdog_ms);

/**
 * @brief Reports whether the client has no active or queued transactions.
 *
 * @param client Client instance.
 *
 * @retval true  No transactions active or queued.
 * @retval false At least one transaction is pending.
 */
bool mb_client_is_idle(const mb_client_t *client);

/**
 * @brief Returns the number of transactions currently active or queued.
 *
 * @param client Client instance.
 * @return Number of transactions in-flight or awaiting dispatch.
 */
mb_size_t mb_client_pending(const mb_client_t *client);

/**
 * @brief Limits the amount of concurrent work accepted by the client.
 *
 * Set @p capacity to zero to fall back to the pool size (default behaviour).
 *
 * @param client   Client instance.
 * @param capacity Maximum number of transactions allowed simultaneously.
 */
void mb_client_set_queue_capacity(mb_client_t *client, mb_size_t capacity);

/**
 * @brief Retrieves the current queue capacity limit.
 *
 * @param client Client instance.
 * @return Configured queue capacity (0 when @p client is NULL).
 */
mb_size_t mb_client_queue_capacity(const mb_client_t *client);

/**
 * @brief Overrides the timeout for a specific function code.
 *
 * Passing a zero timeout clears the override and reverts to the default
 * exponential strategy.
 *
 * @param client   Client instance.
 * @param function Function code to override.
 * @param timeout_ms New timeout in milliseconds (0 clears override).
 */
void mb_client_set_fc_timeout(mb_client_t *client, mb_u8 function, mb_time_ms_t timeout_ms);

/**
 * @brief Copies the current client metrics into @p out_metrics.
 *
 * @param client      Client instance.
 * @param out_metrics Destination structure; left untouched when NULL.
 */
void mb_client_get_metrics(const mb_client_t *client, mb_client_metrics_t *out_metrics);

/**
 * @brief Resets all accumulated client metrics back to zero.
 *
 * @param client Client instance.
 */
void mb_client_reset_metrics(mb_client_t *client);

/**
 * @brief Copies diagnostic counters into @p out_diag.
 *
 * @param client   Client instance.
 * @param out_diag Destination structure; left untouched when NULL.
 */
void mb_client_get_diag(const mb_client_t *client, mb_diag_counters_t *out_diag);

/**
 * @brief Captures a snapshot of diagnostic counters and trace entries.
 *
 * Trace data is only populated when ::MB_CONF_DIAG_ENABLE_TRACE is enabled at
 * build time. The snapshot is safe to inspect outside of the polling context.
 *
 * @param client        Client instance.
 * @param out_snapshot  Destination snapshot; left untouched when NULL.
 */
void mb_client_get_diag_snapshot(const mb_client_t *client, mb_diag_snapshot_t *out_snapshot);

/**
 * @brief Clears the diagnostic counters collected for this client.
 *
 * @param client Client instance.
 */
void mb_client_reset_diag(mb_client_t *client);

/**
 * @brief Registers an event callback to observe client activity.
 *
 * When @p callback is non-NULL the current state is emitted immediately.
 *
 * @param client    Client instance.
 * @param callback  Event sink invoked on state and transaction updates.
 * @param user_ctx  Opaque pointer forwarded to @p callback.
 */
void mb_client_set_event_callback(mb_client_t *client, mb_event_callback_t callback, void *user_ctx);

/**
 * @brief Toggles hexadecimal tracing of TX/RX PDUs to the logging sink.
 *
 * @param client Client instance.
 * @param enable ``true`` to enable tracing, ``false`` to disable.
 */
void mb_client_set_trace_hex(mb_client_t *client, bool enable);

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_CLIENT_H */
/* ===== End modbus/include/modbus/client.h ===== */

/* ===== Begin modbus/include/modbus/modbus.h ===== */
/**
 * @file modbus.h
 * @brief Single public header for the Modbus library.
 *
 * This header consolidates all the necessary includes for using the Modbus library.
 * Users only need to include this file in their application.
 *
 * Internally, it includes:
 * - modbus_conf.h: configuration and macros
 * - fsm.h: finite state machine framework
 * - modbus_crc.h: CRC calculation
 * - modbus_utils.h: utility functions (sorting, safe reads, etc.)
 * - modbus_transport.h: transport abstraction interface
 * - modbus_core.h: core functions for Modbus RTU frames and parsing
 * - modbus_master.h: Master (Client) API
 * - modbus_server.h: Server (Slave) API
 *
 * Author:
 * Date: 2024-12-20
 */

#ifndef MODBUS_H
#define MODBUS_H

/* Include configuration first */
// #include <modbus/conf.h> (amalgamated)

/* Include the rest of the library headers */
// #include <modbus/mb_err.h> (amalgamated)
// #include <modbus/mb_log.h> (amalgamated)
// #include <modbus/observe.h> (amalgamated)
// #include <modbus/base.h> (amalgamated)
// #include <modbus/transport.h> (amalgamated)
// #include <modbus/transport_if.h> (amalgamated)
#if MB_CONF_TRANSPORT_RTU
// #include <modbus/transport/rtu.h> (amalgamated)
#endif
#if MB_CONF_TRANSPORT_ASCII
// #include <modbus/transport/ascii.h> (amalgamated)
#endif
#if MB_CONF_TRANSPORT_TCP
// #include <modbus/transport/tcp.h> (amalgamated)
// #include <modbus/transport/tcp_multi.h> (amalgamated)
#endif
// #include <modbus/frame.h> (amalgamated)
// #include <modbus/utils.h> (amalgamated)
// #include <modbus/fsm.h> (amalgamated)
// #include <modbus/core.h> (amalgamated)
#if MB_CONF_BUILD_SERVER
// #include <modbus/server.h> (amalgamated)
// #include <modbus/mapping.h> (amalgamated)
#endif

#if MB_CONF_BUILD_CLIENT
// #include <modbus/client.h> (amalgamated)
#endif

#if defined(_WIN32)
// #include <modbus/port/win.h> (amalgamated)
#endif


#endif /* MODBUS_H */
/* ===== End modbus/include/modbus/modbus.h ===== */

#endif /* MODBUS_AMALGAMATED_H */
