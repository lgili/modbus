#!/usr/bin/env python3
"""Generate drop-in amalgamated sources for baseline Modbus client + RTU."""
from __future__ import annotations

import argparse
import datetime as _dt
import textwrap
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]
EMBEDDED_ROOT = REPO_ROOT / "embedded" / "quickstarts" / "drop_in"

HEADER_ORDER = [
    "modbus/include/modbus/mb_types.h",
    "modbus/include/modbus/conf.h",
    "modbus/include/modbus/mb_err.h",
    "modbus/include/modbus/transport_if.h",
    "modbus/include/modbus/transport.h",
    "modbus/include/modbus/base.h",
    "modbus/include/modbus/utils.h",
    "modbus/include/modbus/ringbuf.h",
    "modbus/include/modbus/mempool.h",
    "modbus/include/modbus/log.h",
    "modbus/include/modbus/mb_log.h",
    "modbus/include/modbus/pdu.h",
    "modbus/include/modbus/frame.h",
    "modbus/include/modbus/transport/rtu.h",
    "modbus/include/modbus/core.h",
    "modbus/include/modbus/fsm.h",
    "modbus/include/modbus/observe.h",
    "modbus/include/modbus/client.h",
    "modbus/include/modbus/modbus.h",
]

SOURCE_ORDER = [
    "modbus/src/mb_err.c",
    "modbus/src/mb_log.c",
    "modbus/src/log.c",
    "modbus/src/utils.c",
    "modbus/src/ringbuf.c",
    "modbus/src/mempool.c",
    "modbus/src/pdu.c",
    "modbus/src/frame.c",
    "modbus/src/transport.c",
    "modbus/src/transport/rtu/rtu.c",
    "modbus/src/fsm.c",
    "modbus/src/core.c",
    "modbus/src/observe.c",
    "modbus/src/client.c",
]

# Append any additional sources referenced above if they are missing.
_SOURCE_BASE = REPO_ROOT / "modbus" / "src"
for source in sorted(_SOURCE_BASE.rglob("*.c")):
    rel = source.relative_to(REPO_ROOT).as_posix()
    if rel not in SOURCE_ORDER and "transport/rtu" in rel:
        SOURCE_ORDER.append(rel)

HEADER_BANNER = textwrap.dedent(
    """
    /*
     * modbus_amalgamated.h - generated drop-in header
     *
     * This file is generated by scripts/amalgamate.py.
     * It contains the public Modbus API required for the baseline RTU client
     * configuration so that embedded projects can integrate without the full
     * repository layout.
     *
     * Generation timestamp: {timestamp}
     */
    """
)

SOURCE_BANNER = textwrap.dedent(
    """
    /*
     * modbus_amalgamated.c - generated drop-in translation unit
     *
     * This file is generated by scripts/amalgamate.py.
     * It bundles the Modbus core, baseline client implementation and RTU
     * transport into a single compilation unit suitable for embedded builds.
     *
     * Generation timestamp: {timestamp}
     */
    """
)

DROP_IN_DEFAULTS = {
    "MB_CONF_BUILD_CLIENT": "1",
    "MB_CONF_BUILD_SERVER": "0",
    "MB_CONF_TRANSPORT_RTU": "1",
    "MB_CONF_TRANSPORT_ASCII": "0",
    "MB_CONF_TRANSPORT_TCP": "0",
}


def _scrub_modbus_includes(text: str, comment: bool = False) -> str:
    result: list[str] = []
    for line in text.splitlines():
        stripped = line.strip()
        if stripped.startswith("#include") and ("\"modbus/" in stripped or "<modbus/" in stripped):
            if comment:
                # Use // to avoid nested comment issues when the original line contains
                # Doxygen-style annotations such as /**< ... */.
                cleaned = line.strip()
                if "/*" in cleaned:
                    cleaned = cleaned.split("/*", 1)[0].strip()
                result.append(f"// {cleaned} (amalgamated)")
            continue
        result.append(line)
    return "\n".join(result) + "\n"


def _scrub_conf_defaults(text: str) -> str:
    for macro, value in DROP_IN_DEFAULTS.items():
        text = text.replace(f"#define {macro} 1", f"#define {macro} {value}")
        text = text.replace(f"#define {macro} 0", f"#define {macro} {value}")
    return text


def generate_header() -> None:
    EMBEDDED_ROOT.mkdir(parents=True, exist_ok=True)
    header_path = EMBEDDED_ROOT / "modbus_amalgamated.h"
    timestamp = _dt.datetime.now(_dt.timezone.utc).isoformat(timespec="seconds")
    pieces: list[str] = [HEADER_BANNER.format(timestamp=timestamp)]
    pieces.append("#ifndef MODBUS_AMALGAMATED_H\n#define MODBUS_AMALGAMATED_H\n\n")
    pieces.append("#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n")

    seen = set()
    for rel_path in HEADER_ORDER:
        if rel_path in seen:
            continue
        seen.add(rel_path)
        path = REPO_ROOT / rel_path
        content = path.read_text()
        content = _scrub_modbus_includes(content, comment=True)
        if path.name == "conf.h":
            content = _scrub_conf_defaults(content)
        pieces.append(f"/* ===== Begin {rel_path} ===== */\n")
        pieces.append(content)
        pieces.append(f"/* ===== End {rel_path} ===== */\n\n")

    pieces.append("#endif /* MODBUS_AMALGAMATED_H */\n")
    header_path.write_text("".join(pieces))


def generate_source() -> None:
    source_path = EMBEDDED_ROOT / "modbus_amalgamated.c"
    timestamp = _dt.datetime.now(_dt.timezone.utc).isoformat(timespec="seconds")
    pieces: list[str] = [SOURCE_BANNER.format(timestamp=timestamp)]
    pieces.append("#define MB_LOG_ENABLED 1\n")
    for macro, value in DROP_IN_DEFAULTS.items():
        pieces.append(f"#ifndef {macro}\n#define {macro} {value}\n#endif\n")
    pieces.append("\n#include \"modbus_amalgamated.h\"\n\n")

    seen = set()
    for rel_path in SOURCE_ORDER:
        if rel_path in seen:
            continue
        seen.add(rel_path)
        path = REPO_ROOT / rel_path
        content = path.read_text()
        content = _scrub_modbus_includes(content)
        pieces.append(f"/* ===== Begin {rel_path} ===== */\n")
        pieces.append(content)
        if not content.endswith("\n"):
            pieces.append("\n")
        pieces.append(f"/* ===== End {rel_path} ===== */\n\n")

    source_path.write_text("".join(pieces))


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate amalgamated Modbus sources")
    parser.add_argument("--check", action="store_true", help="Fail if generated files are out of date")
    args = parser.parse_args()

    previous_header = (EMBEDDED_ROOT / "modbus_amalgamated.h").read_text() if (EMBEDDED_ROOT / "modbus_amalgamated.h").exists() else None
    previous_source = (EMBEDDED_ROOT / "modbus_amalgamated.c").read_text() if (EMBEDDED_ROOT / "modbus_amalgamated.c").exists() else None

    generate_header()
    generate_source()

    if args.check:
        if previous_header is not None and previous_header != (EMBEDDED_ROOT / "modbus_amalgamated.h").read_text():
            raise SystemExit("modbus_amalgamated.h is out of date; run scripts/amalgamate.py")
        if previous_source is not None and previous_source != (EMBEDDED_ROOT / "modbus_amalgamated.c").read_text():
            raise SystemExit("modbus_amalgamated.c is out of date; run scripts/amalgamate.py")


if __name__ == "__main__":
    main()
