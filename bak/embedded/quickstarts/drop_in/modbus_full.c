
/*
 * modbus_full.c - generated drop-in translation unit
 *
 * This file is generated by scripts/amalgamate.py.
 * It bundles the Modbus core into a single compilation unit suitable
 * for embedded builds.
 *
 * Generation timestamp: 2025-10-09T03:07:52+00:00
 */
#define MB_LOG_ENABLED 1
#ifndef MB_CONF_PROFILE
#define MB_CONF_PROFILE 2
#endif
#ifndef MB_CONF_BUILD_CLIENT
#define MB_CONF_BUILD_CLIENT 1
#endif
#ifndef MB_CONF_BUILD_SERVER
#define MB_CONF_BUILD_SERVER 1
#endif
#ifndef MB_CONF_TRANSPORT_RTU
#define MB_CONF_TRANSPORT_RTU 1
#endif
#ifndef MB_CONF_TRANSPORT_ASCII
#define MB_CONF_TRANSPORT_ASCII 1
#endif
#ifndef MB_CONF_TRANSPORT_TCP
#define MB_CONF_TRANSPORT_TCP 1
#endif
#ifndef MB_CONF_ENABLE_FC01
#define MB_CONF_ENABLE_FC01 1
#endif
#ifndef MB_CONF_ENABLE_FC02
#define MB_CONF_ENABLE_FC02 1
#endif
#ifndef MB_CONF_ENABLE_FC03
#define MB_CONF_ENABLE_FC03 1
#endif
#ifndef MB_CONF_ENABLE_FC04
#define MB_CONF_ENABLE_FC04 1
#endif
#ifndef MB_CONF_ENABLE_FC05
#define MB_CONF_ENABLE_FC05 1
#endif
#ifndef MB_CONF_ENABLE_FC06
#define MB_CONF_ENABLE_FC06 1
#endif
#ifndef MB_CONF_ENABLE_FC07
#define MB_CONF_ENABLE_FC07 1
#endif
#ifndef MB_CONF_ENABLE_FC0F
#define MB_CONF_ENABLE_FC0F 1
#endif
#ifndef MB_CONF_ENABLE_FC10
#define MB_CONF_ENABLE_FC10 1
#endif
#ifndef MB_CONF_ENABLE_FC11
#define MB_CONF_ENABLE_FC11 1
#endif
#ifndef MB_CONF_ENABLE_FC16
#define MB_CONF_ENABLE_FC16 1
#endif
#ifndef MB_CONF_ENABLE_FC17
#define MB_CONF_ENABLE_FC17 1
#endif
#ifndef MB_CONF_DIAG_ENABLE_COUNTERS
#define MB_CONF_DIAG_ENABLE_COUNTERS 1
#endif
#ifndef MB_CONF_DIAG_ENABLE_TRACE
#define MB_CONF_DIAG_ENABLE_TRACE 1
#endif

#include "modbus_full.h"

/* ===== Begin modbus/src/mb_err.c ===== */

const char *mb_err_str(mb_err_t err)
{
    switch (err) {
    case MB_OK:
        return "OK";
    case MB_ERR_INVALID_ARGUMENT:
        return "Invalid argument";
    case MB_ERR_TIMEOUT:
        return "Timeout";
    case MB_ERR_TRANSPORT:
        return "Transport error";
    case MB_ERR_CRC:
        return "CRC error";
    case MB_ERR_INVALID_REQUEST:
        return "Invalid request";
    case MB_ERR_OTHER_REQUESTS:
    case MODBUS_OTHERS_REQUESTS:
        return "Other request";
    case MB_ERR_OTHER:
        return "Unspecified error";
    case MB_ERR_CANCELLED:
        return "Cancelled";
    case MB_ERR_NO_RESOURCES:
        return "No resources";
    case MB_ERR_BUSY:
        return "Busy";
    case MB_EX_ILLEGAL_FUNCTION:
        return "Illegal function";
    case MB_EX_ILLEGAL_DATA_ADDRESS:
        return "Illegal data address";
    case MB_EX_ILLEGAL_DATA_VALUE:
        return "Illegal data value";
    case MB_EX_SERVER_DEVICE_FAILURE:
        return "Server device failure";
    case MB_EX_ACKNOWLEDGE:
        return "Acknowledge";
    case MB_EX_SERVER_DEVICE_BUSY:
        return "Server device busy";
    case MB_EX_NEGATIVE_ACKNOWLEDGE:
        return "Negative acknowledge";
    case MB_EX_MEMORY_PARITY_ERROR:
        return "Memory parity error";
    case MB_EX_GATEWAY_PATH_UNAVAILABLE:
        return "Gateway path unavailable";
    case MB_EX_GATEWAY_TARGET_FAILED:
        return "Gateway target device failed";
    default:
        return "Unknown error";
    }
}
/* ===== End modbus/src/mb_err.c ===== */

/* ===== Begin modbus/src/mb_log.c ===== */

#include <stdbool.h>

#if MB_LOG_ENABLE_STDIO
#include <stdio.h>
#ifndef MB_LOG_STDIO_STREAM
#define MB_LOG_STDIO_STREAM stdout
#endif
#endif

#if MB_LOG_ENABLE_SEGGER_RTT
#include "SEGGER_RTT.h"
#ifndef MB_LOG_RTT_PRINTF
#define MB_LOG_RTT_PRINTF SEGGER_RTT_printf
#endif
#endif

#if MB_LOG_ENABLE_STDIO

#ifndef MB_LOG_STDIO_BUFFER_CAP
#define MB_LOG_STDIO_BUFFER_CAP 256U
#endif

static void mb_log_stdio_sink(mb_log_level_t level, char *msg)
{
    char line[MB_LOG_STDIO_BUFFER_CAP];
    const int written = snprintf(line, sizeof(line), "[%s] %s\n", MB_LOG_LEVEL_NAME(level), msg);
    if (written < 0) {
        return;
    }

    size_t to_write = (size_t)written;
    if (to_write >= sizeof(line)) {
        to_write = sizeof(line) - 1U;
        line[to_write] = '\0';
    }

    const size_t written_bytes = fwrite(line, 1U, to_write, MB_LOG_STDIO_STREAM);
    if (written_bytes != to_write) {
        return;
    }

#if MB_LOG_STDOUT_SYNC_FLUSH
    const int flush_result = fflush(MB_LOG_STDIO_STREAM);
    if (flush_result != 0) {
        return;
    }
#endif
}

mb_log_err_t mb_log_subscribe_stdio(mb_log_level_t threshold)
{
    return MB_LOG_SUBSCRIBE(mb_log_stdio_sink, threshold);
}
#endif

#if MB_LOG_ENABLE_SEGGER_RTT
static void mb_log_rtt_sink(mb_log_level_t level, char *msg)
{
    MB_LOG_RTT_PRINTF(MB_LOG_RTT_CHANNEL, "[%s] %s\n", MB_LOG_LEVEL_NAME(level), msg);
}

mb_log_err_t mb_log_subscribe_rtt(mb_log_level_t threshold)
{
    return MB_LOG_SUBSCRIBE(mb_log_rtt_sink, threshold);
}
#endif

void mb_log_bootstrap_defaults(void)
{
    static bool bootstrapped = false;

    if (!bootstrapped) {
        MB_LOG_INIT();
        bootstrapped = true;
    }

#if MB_LOG_ENABLE_STDIO
    static bool stdio_registered = false;
    if (!stdio_registered) {
        (void)mb_log_subscribe_stdio(MB_LOG_DEFAULT_THRESHOLD);
        stdio_registered = true;
    }
#endif

#if MB_LOG_ENABLE_SEGGER_RTT
    static bool rtt_registered = false;
    if (!rtt_registered) {
        (void)mb_log_subscribe_rtt(MB_LOG_DEFAULT_THRESHOLD);
        rtt_registered = true;
    }
#endif
}
/* ===== End modbus/src/mb_log.c ===== */

/* ===== Begin modbus/src/log.c ===== */
/**
MIT License

Copyright (c) 2019 R. Dunbar Poor <rdpoor@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * \file ulog.c
 *
 * \brief uLog: lightweight logging for embedded systems
 *
 * See ulog.h for sparse documentation.
 */


#ifdef LOG_ENABLED  // whole file...

#include <stdio.h>
#include <string.h>
#include <stdarg.h>


// =============================================================================
// types and definitions

typedef struct {
  log_function_t fn;
  log_level_t threshold;
} subscriber_t;

// =============================================================================
// local storage

static subscriber_t s_subscribers[LOG_MAX_SUBSCRIBERS];
static char s_message[LOG_MAX_MESSAGE_LENGTH];

// =============================================================================
// user-visible code

void log_init(void) {
  memset(s_subscribers, 0, sizeof(s_subscribers));
}

// search the s_subscribers table to install or update fn
log_err_t log_subscribe(log_function_t fn, log_level_t threshold) {
  int available_slot = -1;
  int i;
  for (i=0; i<LOG_MAX_SUBSCRIBERS; i++) {
    if (s_subscribers[i].fn == fn) {
      // already subscribed: update threshold and return immediately.
      s_subscribers[i].threshold = threshold;
      return LOG_ERR_NONE;

    } else if (s_subscribers[i].fn == NULL) {
      // found a free slot
      available_slot = i;
    }
  }
  // fn is not yet a subscriber.  assign if possible.
  if (available_slot == -1) {
    return LOG_ERR_SUBSCRIBERS_EXCEEDED;
  }
  s_subscribers[available_slot].fn = fn;
  s_subscribers[available_slot].threshold = threshold;
  return LOG_ERR_NONE;
}

// search the s_subscribers table to remove
log_err_t log_unsubscribe(log_function_t fn) {
  int i;
  for (i=0; i<LOG_MAX_SUBSCRIBERS; i++) {
    if (s_subscribers[i].fn == fn) {
      s_subscribers[i].fn = NULL;    // mark as empty
      return LOG_ERR_NONE;
    }
  }
  return LOG_ERR_NOT_SUBSCRIBED;
}

const char *log_level_name(log_level_t severity) {
  switch(severity) {
   case LOG_TRACE_LEVEL: return "\x1b[94mTRACE\x1b[0m";
   case LOG_DEBUG_LEVEL: return "\x1b[36mDEBUG\x1b[0m";
   case LOG_INFO_LEVEL: return "\x1b[32mINFO\x1b[0m";
   case LOG_WARNING_LEVEL: return "\x1b[33mWARNING\x1b[0m";
   case LOG_ERROR_LEVEL: return "\x1b[31mERROR\x1b[0m";
   case LOG_CRITICAL_LEVEL: return "\x1b[35mCRITICAL\x1b[0m";
   case LOG_ALWAYS_LEVEL: return "ALWAYS";
   default: return "UNKNOWN";
  }
}

void log_message(log_level_t severity, const char *fmt, ...) {
  va_list ap;
  int i;
  va_start(ap, fmt);
  vsnprintf(s_message, LOG_MAX_MESSAGE_LENGTH, fmt, ap);
  va_end(ap);

  for (i=0; i<LOG_MAX_SUBSCRIBERS; i++) {
    if (s_subscribers[i].fn != NULL) {
      if (severity >= s_subscribers[i].threshold) {
        s_subscribers[i].fn(severity, s_message);
      }
    }
  }
}

// =============================================================================
// private code

#endif  // #ifdef LOG_ENABLED
/* ===== End modbus/src/log.c ===== */

/* ===== Begin modbus/src/utils.c ===== */
/**
 * @file modbus_utils.c
 * @brief Implementation of utility functions for Modbus protocol operations.
 *
 * This source file implements the helper functions declared in `modbus_utils.h`.
 * It provides safe reading from buffers, as well as sorting and searching
 * functionalities for arrays of Modbus variables. Additionally, it includes
 * functions to calculate CRC-16 checksums, essential for ensuring data integrity
 * in Modbus communications.
 *
 * **Key Features:**
 * - Safe reading of 8-bit and 16-bit unsigned integers from buffers.
 * - Sorting and searching utilities for arrays of `variable_modbus_t`.
 * - CRC-16 calculation using both bit-by-bit and table-driven approaches.
 *
 * **Notes:**
 * - Ensure that the CRC lookup table is correctly initialized before using `modbus_crc_with_table()`.
 * - The selection sort algorithm used in `modbus_selection_sort()` has a time complexity of O(n²).
 *   For larger datasets, consider implementing a more efficient sorting algorithm.
 *
 * @author
 * Luiz Carlos Gili
 * 
 * @date
 * 2024-12-20
 *
 * @ingroup ModbusUtils
 * @{
 */

#include <stddef.h>
#include <string.h>

#ifndef CRC_POLYNOMIAL
#define CRC_POLYNOMIAL 0xA001U /**< CRC polynomial used for Modbus CRC-16 calculation */
#endif

/**
 * @brief Precomputed CRC lookup table for Modbus.
 *
 * This table is used by the `modbus_crc_with_table()` function to quickly compute
 * the CRC for each byte of data. It enhances the efficiency of CRC calculations
 * compared to bit-by-bit methods.
 *
 * @note
 * - Ensure that the table remains unchanged to maintain CRC calculation accuracy.
 */
static const uint16_t crc_table[256] = {
    0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
    0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
    0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
    0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
    0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
    0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
    0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
    0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
    0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
    0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
    0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
    0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
    0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
    0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
    0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
    0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
    0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
    0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
    0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
    0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
    0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
    0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
    0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
    0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
    0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
    0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
    0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

static void modbus_regs_to_bytes_abcd(const uint16_t *registers, uint8_t out[4])
{
    if (out == NULL) {
        return;
    }

    if (registers == NULL) {
        out[0] = 0U;
        out[1] = 0U;
        out[2] = 0U;
        out[3] = 0U;
        return;
    }

    out[0] = (uint8_t)((registers[0] >> 8) & 0xFFU);
    out[1] = (uint8_t)(registers[0] & 0xFFU);
    out[2] = (uint8_t)((registers[1] >> 8) & 0xFFU);
    out[3] = (uint8_t)(registers[1] & 0xFFU);
}

static void modbus_bytes_to_regs_abcd(const uint8_t bytes[4], uint16_t *dest)
{
    if (dest == NULL || bytes == NULL) {
        return;
    }

    dest[0] = (uint16_t)(((uint16_t)bytes[0] << 8) | (uint16_t)bytes[1]);
    dest[1] = (uint16_t)(((uint16_t)bytes[2] << 8) | (uint16_t)bytes[3]);
}

static uint32_t modbus_bytes_to_u32(const uint8_t bytes[4])
{
    return ((uint32_t)bytes[0] << 24) |
           ((uint32_t)bytes[1] << 16) |
           ((uint32_t)bytes[2] << 8)  |
           (uint32_t)bytes[3];
}

static void modbus_u32_to_bytes(uint32_t value, uint8_t out[4])
{
    out[0] = (uint8_t)((value >> 24) & 0xFFU);
    out[1] = (uint8_t)((value >> 16) & 0xFFU);
    out[2] = (uint8_t)((value >> 8) & 0xFFU);
    out[3] = (uint8_t)(value & 0xFFU);
}

static void modbus_reorder_bytes(const uint8_t in[4], uint8_t out[4], uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
    out[0] = in[b0];
    out[1] = in[b1];
    out[2] = in[b2];
    out[3] = in[b3];
}

static uint32_t modbus_get_u32_ordered(const uint16_t *registers, uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
    uint8_t abcd[4];
    uint8_t ordered[4];
    modbus_regs_to_bytes_abcd(registers, abcd);
    modbus_reorder_bytes(abcd, ordered, b0, b1, b2, b3);
    return modbus_bytes_to_u32(ordered);
}

static void modbus_set_u32_ordered(uint32_t value, uint16_t *dest, uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
    if (dest == NULL) {
        return;
    }

    uint8_t abcd[4];
    uint8_t ordered[4];
    modbus_u32_to_bytes(value, abcd);
    modbus_reorder_bytes(abcd, ordered, b0, b1, b2, b3);
    modbus_bytes_to_regs_abcd(ordered, dest);
}

static float modbus_float_from_u32(uint32_t raw)
{
    float value = 0.0f;
    memcpy(&value, &raw, sizeof(value));
    return value;
}

static uint32_t modbus_u32_from_float(float value)
{
    uint32_t raw = 0U;
    memcpy(&raw, &value, sizeof(raw));
    return raw;
}

/**
 * @brief Safely reads an 8-bit unsigned integer from a buffer.
 *
 * This function checks if there is enough space in the buffer before reading
 * an 8-bit value. If reading would exceed the buffer size, it returns `false`.
 *
 * @param[in]  buffer       Pointer to the data buffer.
 * @param[in,out] index     Pointer to the current read index in the buffer. It is incremented by one on success.
 * @param[in]  buffer_size  Size of the buffer in bytes.
 * @param[out] value        Pointer to the variable where the read value will be stored.
 *
 * @return `true` if the value was successfully read, `false` if not enough data.
 *
 * @example
 * ```c
 * uint8_t data[] = {0x12, 0x34};
 * uint16_t idx = 0;
 * uint8_t val;
 * if (modbus_read_uint8(data, &idx, 2, &val)) {
 *     // val = 0x12
 * }
 * ```
 */
bool modbus_read_uint8(const uint8_t *buffer, uint16_t *index, uint16_t buffer_size, uint8_t *value)
{
    if (!buffer || !index || !value) {
        return false; // Invalid arguments
    }

    if (*index >= buffer_size) {
        return false; // Not enough data to read
    }
    *value = buffer[(*index)++];
    return true;
}

/**
 * @brief Safely reads a 16-bit unsigned integer from a buffer (big-endian).
 *
 * This function checks if there is enough space in the buffer before reading
 * a 16-bit value. It reads two bytes from the buffer and combines them into
 * a 16-bit value, interpreting the first read byte as the high-order byte.
 *
 * @param[in]  buffer       Pointer to the data buffer.
 * @param[in,out] index     Pointer to the current read index in the buffer. It is incremented by two on success.
 * @param[in]  buffer_size  Size of the buffer in bytes.
 * @param[out] value        Pointer to the variable where the read 16-bit value will be stored.
 *
 * @return `true` if the value was successfully read, `false` if not enough data.
 *
 * @example
 * ```c
 * uint8_t data[] = {0x12, 0x34};
 * uint16_t idx = 0;
 * uint16_t val;
 * if (modbus_read_uint16(data, &idx, 2, &val)) {
 *     // val = 0x1234
 * }
 * ```
 */
bool modbus_read_uint16(const uint8_t *buffer, uint16_t *index, uint16_t buffer_size, uint16_t *value)
{
    if (!buffer || !index || !value) {
        return false; // Invalid arguments
    }

    if ((*index + 1U) >= buffer_size) {
        return false; // Not enough data to read
    }
    const uint8_t data_high = buffer[(*index)++];
    const uint8_t data_low  = buffer[(*index)++];
    const uint16_t high_word = (uint16_t)((uint16_t)data_high << 8U);
    const uint16_t low_word = (uint16_t)data_low;
    *value = (uint16_t)(high_word | low_word);
    return true;
}

/**
 * @brief Sorts an array of Modbus variables by their address using selection sort.
 *
 * This function organizes the array of `variable_modbus_t` in ascending order
 * based on the `address` field. Selection sort is used due to its simplicity.
 *
 * @param[in,out] modbus_variables Array of Modbus variables to sort.
 * @param[in] length               Number of elements in the array.
 *
 * @note
 * - Selection sort has a time complexity of O(n²). For larger datasets, consider implementing a more efficient sorting algorithm like quicksort or mergesort.
 *
 * @example
 * ```c
 * variable_modbus_t vars[3] = {
 *     {.address = 3},
 *     {.address = 1},
 *     {.address = 2}
 * };
 * modbus_selection_sort(vars, 3);
 * // vars now sorted by address: 1, 2, 3
 * ```
 */
void modbus_selection_sort(variable_modbus_t modbus_variables[], int length)
{
    if (!modbus_variables || length <= 1) {
        return; // No need to sort
    }

    for (int i = 0; i < (length - 1); i++) {
        int min_idx = i;
        // Find the minimum element in the unsorted part of the array
        for (int j = i + 1; j < length; j++) {
            if (modbus_variables[j].address < modbus_variables[min_idx].address) {
                min_idx = j;
            }
        }
        // Swap the found minimum element with the first element of the unsorted part
        if (min_idx != i) {
            variable_modbus_t temp = modbus_variables[min_idx];
            modbus_variables[min_idx] = modbus_variables[i];
            modbus_variables[i] = temp;
        }
    }
}

/**
 * @brief Performs a binary search on an array of Modbus variables sorted by address.
 *
 * Given a sorted array of `variable_modbus_t` (sorted by `address`), this function
 * searches for a given address using binary search. It returns the index of the matching
 * variable or -1 if the address is not found.
 *
 * @param[in] modbus_variables Sorted array of Modbus variables.
 * @param[in] low              Lowest index of the search range.
 * @param[in] high             Highest index of the search range.
 * @param[in] value            Address value to search for.
 *
 * @return The index of the variable with the matching address, or -1 if not found.
 *
 * @example
 * ```c
 * variable_modbus_t vars[3] = {
 *     {.address = 1},
 *     {.address = 2},
 *     {.address = 3}
 * };
 * int index = modbus_binary_search(vars, 0, 2, 2);
 * // index = 1
 * ```
 */
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
int modbus_binary_search(variable_modbus_t modbus_variables[], uint16_t low, uint16_t high, uint16_t value)
{
    if (!modbus_variables || low > high) {
        return -1; // Invalid parameters
    }

    while (low <= high) {
        uint16_t mid = low + (high - low) / 2U;

        if (modbus_variables[mid].address == value) {
            return (int)mid;
        }
        else if (modbus_variables[mid].address < value) {
            low = mid + 1U;
        }
        else {
            if (mid == 0) { // Prevent underflow
                break;
            }
            high = mid - 1U;
        }
    }
    return -1; // Not found
}
// NOLINTEND(bugprone-easily-swappable-parameters)

uint32_t modbus_get_uint32_abcd(const uint16_t *registers)
{
    return modbus_get_u32_ordered(registers, 0U, 1U, 2U, 3U);
}

uint32_t modbus_get_uint32_dcba(const uint16_t *registers)
{
    return modbus_get_u32_ordered(registers, 3U, 2U, 1U, 0U);
}

uint32_t modbus_get_uint32_badc(const uint16_t *registers)
{
    return modbus_get_u32_ordered(registers, 1U, 0U, 3U, 2U);
}

uint32_t modbus_get_uint32_cdab(const uint16_t *registers)
{
    return modbus_get_u32_ordered(registers, 2U, 3U, 0U, 1U);
}

void modbus_set_uint32_abcd(uint32_t value, uint16_t *dest)
{
    modbus_set_u32_ordered(value, dest, 0U, 1U, 2U, 3U);
}

void modbus_set_uint32_dcba(uint32_t value, uint16_t *dest)
{
    modbus_set_u32_ordered(value, dest, 3U, 2U, 1U, 0U);
}

void modbus_set_uint32_badc(uint32_t value, uint16_t *dest)
{
    modbus_set_u32_ordered(value, dest, 1U, 0U, 3U, 2U);
}

void modbus_set_uint32_cdab(uint32_t value, uint16_t *dest)
{
    modbus_set_u32_ordered(value, dest, 2U, 3U, 0U, 1U);
}

int32_t modbus_get_int32_abcd(const uint16_t *registers)
{
    return (int32_t)modbus_get_uint32_abcd(registers);
}

int32_t modbus_get_int32_dcba(const uint16_t *registers)
{
    return (int32_t)modbus_get_uint32_dcba(registers);
}

int32_t modbus_get_int32_badc(const uint16_t *registers)
{
    return (int32_t)modbus_get_uint32_badc(registers);
}

int32_t modbus_get_int32_cdab(const uint16_t *registers)
{
    return (int32_t)modbus_get_uint32_cdab(registers);
}

void modbus_set_int32_abcd(int32_t value, uint16_t *dest)
{
    modbus_set_uint32_abcd((uint32_t)value, dest);
}

void modbus_set_int32_dcba(int32_t value, uint16_t *dest)
{
    modbus_set_uint32_dcba((uint32_t)value, dest);
}

void modbus_set_int32_badc(int32_t value, uint16_t *dest)
{
    modbus_set_uint32_badc((uint32_t)value, dest);
}

void modbus_set_int32_cdab(int32_t value, uint16_t *dest)
{
    modbus_set_uint32_cdab((uint32_t)value, dest);
}

float modbus_get_float_abcd(const uint16_t *registers)
{
    return modbus_float_from_u32(modbus_get_uint32_abcd(registers));
}

float modbus_get_float_dcba(const uint16_t *registers)
{
    return modbus_float_from_u32(modbus_get_uint32_dcba(registers));
}

float modbus_get_float_badc(const uint16_t *registers)
{
    return modbus_float_from_u32(modbus_get_uint32_badc(registers));
}

float modbus_get_float_cdab(const uint16_t *registers)
{
    return modbus_float_from_u32(modbus_get_uint32_cdab(registers));
}

void modbus_set_float_abcd(float value, uint16_t *dest)
{
    modbus_set_uint32_abcd(modbus_u32_from_float(value), dest);
}

void modbus_set_float_dcba(float value, uint16_t *dest)
{
    modbus_set_uint32_dcba(modbus_u32_from_float(value), dest);
}

void modbus_set_float_badc(float value, uint16_t *dest)
{
    modbus_set_uint32_badc(modbus_u32_from_float(value), dest);
}

void modbus_set_float_cdab(float value, uint16_t *dest)
{
    modbus_set_uint32_cdab(modbus_u32_from_float(value), dest);
}

/**
 * @brief Calculates the Modbus CRC-16 using a bit-by-bit algorithm.
 *
 * This function iterates over each byte in the given data buffer and updates the
 * CRC value accordingly. While less efficient than a table-driven approach, it
 * is straightforward and does not require a precomputed table.
 *
 * @param[in] data   Pointer to the data buffer for which to calculate CRC.
 * @param[in] length Number of bytes in the data buffer.
 *
 * @return The calculated CRC-16 value.
 *
 * @note
 * - Bit-by-bit CRC calculation is simple but may be slower for large data buffers.
 *
 * @example
 * ```c
 * uint8_t frame[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02};
 * uint16_t crc = modbus_calculate_crc(frame, 6);
 * // crc = 0xC5C9 (example value)
 * ```
 */
uint16_t modbus_calculate_crc(const uint8_t *data, uint16_t length)
{
    if (!data) {
        return 0xFFFFU; // Default CRC for invalid data
    }

    uint16_t crc = 0xFFFFU;
    for (uint16_t i = 0; i < length; i++) {
        crc ^= (uint16_t)data[i];
        for (uint8_t j = 0; j < 8U; j++) {
            if ((crc & 0x0001U) != 0U) {
                crc >>= 1U;
                crc ^= CRC_POLYNOMIAL;
            } else {
                crc >>= 1U;
            }
        }
    }
    return crc;
}

/**
 * @brief Calculates the Modbus CRC-16 using a lookup table.
 *
 * This function uses a precomputed lookup table to calculate the Modbus CRC-16
 * more efficiently. It is generally faster than the bit-by-bit approach.
 *
 * @param[in] data   Pointer to the data buffer for which to calculate CRC.
 * @param[in] length Number of bytes in the data buffer.
 *
 * @return The calculated CRC-16 value.
 *
 * @note
 * - Lookup table CRC calculation is faster but requires additional memory for the table.
 * - Ensure that the CRC table is correctly initialized before using this function.
 *
 * @example
 * ```c
 * uint8_t frame[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02};
 * uint16_t crc = modbus_crc_with_table(frame, 6);
 * // crc = 0xC5C9 (example value)
 * ```
 */
uint16_t modbus_crc_with_table(const uint8_t *data, uint16_t length)
{
    if (!data) {
        return 0xFFFFU; // Default CRC for invalid data
    }

    uint16_t crc = 0xFFFFU;
    for (uint16_t i = 0; i < length; i++) {
        uint8_t index = (uint8_t)(crc ^ data[i]);
        crc = (uint16_t)((crc >> 8U) ^ crc_table[index]);
    }
    return crc;
}

/**
 * @brief Validates the trailing CRC of the provided frame.
 */
bool modbus_crc_validate(const uint8_t *frame, uint16_t length)
{
    if (!frame || length < 2U) {
        return false;
    }

    const uint16_t payload_len = (uint16_t)(length - 2U);
    const uint16_t expected_crc = (uint16_t)((uint16_t)frame[payload_len] | ((uint16_t)frame[payload_len + 1U] << 8U));
    const uint16_t computed_crc = modbus_crc_with_table(frame, payload_len);

    return (computed_crc == expected_crc);
}

/** @} */
/* ===== End modbus/src/utils.c ===== */

/* ===== Begin modbus/src/ringbuf.c ===== */
/**
 * @file ringbuf.c
 */


#include <stddef.h>

static bool is_power_of_two(size_t value)
{
    return value != 0U && (value & (value - 1U)) == 0U;
}

mb_err_t mb_ringbuf_init(mb_ringbuf_t *rb, uint8_t *storage, size_t capacity)
{
    if (rb == NULL || storage == NULL || capacity == 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!is_power_of_two(capacity)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    rb->buffer = storage;
    rb->capacity = capacity;
    rb->mask = capacity - 1U;
    rb->head = 0U;
    rb->tail = 0U;
    rb->count = 0U;

    return MODBUS_ERROR_NONE;
}

void mb_ringbuf_reset(mb_ringbuf_t *rb)
{
    if (rb == NULL) {
        return;
    }

    rb->head = 0U;
    rb->tail = 0U;
    rb->count = 0U;
}

size_t mb_ringbuf_capacity(const mb_ringbuf_t *rb)
{
    return (rb == NULL) ? 0U : rb->capacity;
}

size_t mb_ringbuf_size(const mb_ringbuf_t *rb)
{
    return (rb == NULL) ? 0U : rb->count;
}

size_t mb_ringbuf_free(const mb_ringbuf_t *rb)
{
    return (rb == NULL) ? 0U : (rb->capacity - rb->count);
}

bool mb_ringbuf_is_empty(const mb_ringbuf_t *rb)
{
    return mb_ringbuf_size(rb) == 0U;
}

bool mb_ringbuf_is_full(const mb_ringbuf_t *rb)
{
    if (rb == NULL) {
        return false;
    }

    return rb->count == rb->capacity;
}

size_t mb_ringbuf_write(mb_ringbuf_t *rb, const uint8_t *data, size_t len)
{
    if (rb == NULL || data == NULL || len == 0U) {
        return 0U;
    }

    const size_t available = rb->capacity - rb->count;
    const size_t to_write = (len < available) ? len : available;

    for (size_t i = 0U; i < to_write; ++i) {
        rb->buffer[rb->tail] = data[i];
        rb->tail = (rb->tail + 1U) & rb->mask;
    }

    rb->count += to_write;
    return to_write;
}

size_t mb_ringbuf_read(mb_ringbuf_t *rb, uint8_t *out, size_t len)
{
    if (rb == NULL || out == NULL || len == 0U) {
        return 0U;
    }

    const size_t to_read = (len < rb->count) ? len : rb->count;

    for (size_t i = 0U; i < to_read; ++i) {
        out[i] = rb->buffer[rb->head];
        rb->head = (rb->head + 1U) & rb->mask;
    }

    rb->count -= to_read;
    return to_read;
}

bool mb_ringbuf_push(mb_ringbuf_t *rb, uint8_t byte)
{
    if (rb == NULL || rb->count == rb->capacity) {
        return false;
    }

    rb->buffer[rb->tail] = byte;
    rb->tail = (rb->tail + 1U) & rb->mask;
    rb->count += 1U;
    return true;
}

bool mb_ringbuf_pop(mb_ringbuf_t *rb, uint8_t *out_byte)
{
    if (rb == NULL || out_byte == NULL || rb->count == 0U) {
        return false;
    }

    *out_byte = rb->buffer[rb->head];
    rb->head = (rb->head + 1U) & rb->mask;
    rb->count -= 1U;
    return true;
}
/* ===== End modbus/src/ringbuf.c ===== */

/* ===== Begin modbus/src/mempool.c ===== */
/**
 * @file mempool.c
 */



static void mempool_build_free_list(mb_mempool_t *pool)
{
    pool->free_list = NULL;
    pool->free_count = 0U;

    for (mb_size_t i = 0U; i < pool->block_count; ++i) {
        mb_u8 *block = pool->storage + (i * pool->block_size);
        *(void **)block = pool->free_list;
        pool->free_list = block;
        pool->free_count += 1U;
    }
}

static bool mempool_pointer_belongs(const mb_mempool_t *pool, const void *block)
{
    if (pool == NULL || block == NULL) {
        return false;
    }

    const mb_u8 *byte_ptr = (const mb_u8 *)block;
    const mb_u8 *begin = pool->storage;
    const mb_u8 *end = begin + (pool->block_count * pool->block_size);

    if (byte_ptr < begin || byte_ptr >= end) {
        return false;
    }

    mb_size_t offset = (mb_size_t)(byte_ptr - begin);
    return (offset % pool->block_size) == 0U;
}

mb_err_t mb_mempool_init(mb_mempool_t *pool,
                         void *buffer,
                         mb_size_t block_size,
                         mb_size_t block_count)
{
    if (pool == NULL || buffer == NULL || block_size == 0U || block_count == 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (block_size < sizeof(void *)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    pool->storage = (mb_u8 *)buffer;
    pool->block_size = block_size;
    pool->block_count = block_count;

    mempool_build_free_list(pool);
    return MODBUS_ERROR_NONE;
}

void mb_mempool_reset(mb_mempool_t *pool)
{
    if (pool == NULL || pool->storage == NULL) {
        return;
    }

    mempool_build_free_list(pool);
}

void *mb_mempool_acquire(mb_mempool_t *pool)
{
    if (pool == NULL || pool->free_list == NULL) {
        return NULL;
    }

    void *block = pool->free_list;
    pool->free_list = *(void **)pool->free_list;
    pool->free_count -= 1U;
    return block;
}

mb_err_t mb_mempool_release(mb_mempool_t *pool, void *block)
{
    if (pool == NULL || block == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mempool_pointer_belongs(pool, block)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pool->free_count >= pool->block_count) {
        return MODBUS_ERROR_OTHER;
    }

    *(void **)block = pool->free_list;
    pool->free_list = block;
    pool->free_count += 1U;
    return MODBUS_ERROR_NONE;
}

mb_size_t mb_mempool_capacity(const mb_mempool_t *pool)
{
    if (pool == NULL) {
        return 0U;
    }
    return pool->block_count;
}

mb_size_t mb_mempool_free_count(const mb_mempool_t *pool)
{
    if (pool == NULL) {
        return 0U;
    }
    return pool->free_count;
}

bool mb_mempool_contains(const mb_mempool_t *pool, const void *block)
{
    return mempool_pointer_belongs(pool, block);
}
/* ===== End modbus/src/mempool.c ===== */

/* ===== Begin modbus/src/pdu.c ===== */
/**
 * @file pdu.c
 */


#include <string.h>

// NOLINTBEGIN(bugprone-easily-swappable-parameters)

static void mb_pdu_write_u16(mb_u8 *out, mb_u16 value)
{
    out[0] = (mb_u8)((value >> 8) & 0xFFU);
    out[1] = (mb_u8)(value & 0xFFU);
}

static mb_u16 mb_pdu_read_u16(const mb_u8 *in)
{
    return (mb_u16)(((mb_u16)in[0] << 8) | (mb_u16)in[1]);
}

static bool mb_pdu_validate_capacity(mb_size_t required, mb_size_t out_cap)
{
    if (required > MB_PDU_MAX) {
        return false;
    }
    return required <= out_cap;
}

#if MB_CONF_ENABLE_FC01 || MB_CONF_ENABLE_FC02 || MB_CONF_ENABLE_FC05 || MB_CONF_ENABLE_FC0F
static mb_size_t mb_pdu_bits_to_bytes(mb_u16 bit_count)
{
    return (mb_size_t)((bit_count + 7U) / 8U);
}

static void mb_pdu_pack_bits_payload(mb_u8 *dest, const bool *bits, mb_u16 count)
{
    for (mb_u16 i = 0U; i < count; ++i) {
        if (bits[i]) {
            const mb_u16 byte_index = (mb_u16)(i / 8U);
            const mb_u8 bit_index = (mb_u8)(i % 8U);
            dest[byte_index] = (mb_u8)(dest[byte_index] | (mb_u8)(1U << bit_index));
        }
    }
}

static bool mb_pdu_is_valid_coil_encoding(mb_u16 value)
{
    return (value == MB_PDU_COIL_OFF_VALUE) || (value == MB_PDU_COIL_ON_VALUE);
}
#endif

#if MB_CONF_ENABLE_FC01
mb_err_t mb_pdu_build_read_coils_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 quantity)
{
    const mb_size_t required = 5U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((quantity < MB_PDU_FC01_MIN_COILS) || (quantity > MB_PDU_FC01_MAX_COILS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_COILS;
    mb_pdu_write_u16(&out[1], start_addr);
    mb_pdu_write_u16(&out[3], quantity);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_coils_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_quantity)
{
    if (pdu == NULL || len != 5U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_COILS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 quantity = mb_pdu_read_u16(&pdu[3]);
    if ((quantity < MB_PDU_FC01_MIN_COILS) || (quantity > MB_PDU_FC01_MAX_COILS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_addr != NULL) {
        *out_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_quantity != NULL) {
        *out_quantity = quantity;
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_read_coils_response(mb_u8 *out, mb_size_t out_cap, const bool *coils, mb_u16 count)
{
    if (out == NULL || coils == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((count < MB_PDU_FC01_MIN_COILS) || (count > MB_PDU_FC01_MAX_COILS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t byte_count = mb_pdu_bits_to_bytes(count);
    const mb_size_t required = 2U + byte_count;

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_COILS;
    out[1] = (mb_u8)byte_count;
    memset(&out[2], 0, byte_count);
    mb_pdu_pack_bits_payload(&out[2], coils, count);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_coils_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u8 *out_byte_count)
{
    if (pdu == NULL || len < 3U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_COILS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 byte_count = pdu[1];
    const mb_u8 min_bytes = (mb_u8)mb_pdu_bits_to_bytes(MB_PDU_FC01_MIN_COILS);
    const mb_u8 max_bytes = (mb_u8)mb_pdu_bits_to_bytes(MB_PDU_FC01_MAX_COILS);

    if ((byte_count < min_bytes) || (byte_count > max_bytes)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(2U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_payload != NULL) {
        *out_payload = &pdu[2];
    }

    if (out_byte_count != NULL) {
        *out_byte_count = byte_count;
    }

    return MODBUS_ERROR_NONE;
}

#endif

#if MB_CONF_ENABLE_FC02
mb_err_t mb_pdu_build_read_discrete_inputs_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 quantity)
{
    const mb_size_t required = 5U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((quantity < MB_PDU_FC02_MIN_INPUTS) || (quantity > MB_PDU_FC02_MAX_INPUTS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_DISCRETE_INPUTS;
    mb_pdu_write_u16(&out[1], start_addr);
    mb_pdu_write_u16(&out[3], quantity);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_discrete_inputs_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_quantity)
{
    if (pdu == NULL || len != 5U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_DISCRETE_INPUTS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 quantity = mb_pdu_read_u16(&pdu[3]);
    if ((quantity < MB_PDU_FC02_MIN_INPUTS) || (quantity > MB_PDU_FC02_MAX_INPUTS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_addr != NULL) {
        *out_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_quantity != NULL) {
        *out_quantity = quantity;
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_read_discrete_inputs_response(mb_u8 *out, mb_size_t out_cap, const bool *inputs, mb_u16 count)
{
    if (out == NULL || inputs == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((count < MB_PDU_FC02_MIN_INPUTS) || (count > MB_PDU_FC02_MAX_INPUTS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t byte_count = mb_pdu_bits_to_bytes(count);
    const mb_size_t required = 2U + byte_count;

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_DISCRETE_INPUTS;
    out[1] = (mb_u8)byte_count;
    memset(&out[2], 0, byte_count);
    mb_pdu_pack_bits_payload(&out[2], inputs, count);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_discrete_inputs_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u8 *out_byte_count)
{
    if (pdu == NULL || len < 3U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_DISCRETE_INPUTS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 byte_count = pdu[1];
    const mb_u8 min_bytes = (mb_u8)mb_pdu_bits_to_bytes(MB_PDU_FC02_MIN_INPUTS);
    const mb_u8 max_bytes = (mb_u8)mb_pdu_bits_to_bytes(MB_PDU_FC02_MAX_INPUTS);

    if ((byte_count < min_bytes) || (byte_count > max_bytes)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(2U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_payload != NULL) {
        *out_payload = &pdu[2];
    }

    if (out_byte_count != NULL) {
        *out_byte_count = byte_count;
    }

    return MODBUS_ERROR_NONE;
}

#endif

#if MB_CONF_ENABLE_FC03
mb_err_t mb_pdu_build_read_holding_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 quantity)
{
    const mb_size_t required = 5U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((quantity < MB_PDU_FC03_MIN_REGISTERS) || (quantity > MB_PDU_FC03_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_HOLDING_REGISTERS;
    mb_pdu_write_u16(&out[1], start_addr);
    mb_pdu_write_u16(&out[3], quantity);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_holding_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_quantity)
{
    if (pdu == NULL || len != 5U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_HOLDING_REGISTERS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 quantity = mb_pdu_read_u16(&pdu[3]);
    if ((quantity < MB_PDU_FC03_MIN_REGISTERS) || (quantity > MB_PDU_FC03_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_addr != NULL) {
        *out_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_quantity != NULL) {
        *out_quantity = quantity;
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_read_holding_response(mb_u8 *out, mb_size_t out_cap, const mb_u16 *registers, mb_u16 count)
{
    if (out == NULL || registers == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((count < MB_PDU_FC03_MIN_REGISTERS) || (count > MB_PDU_FC03_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t byte_count = (mb_size_t)count * 2U;
    const mb_size_t required = 2U + byte_count;

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_HOLDING_REGISTERS;
    out[1] = (mb_u8)byte_count;

    for (mb_u16 i = 0U; i < count; ++i) {
        mb_pdu_write_u16(&out[2U + (i * 2U)], registers[i]);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_holding_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u16 *out_register_count)
{
    if (pdu == NULL || len < 2U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_HOLDING_REGISTERS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 byte_count = pdu[1];
    if ((byte_count & 0x01U) != 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(2U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 reg_count = (mb_u16)(byte_count / 2U);
    if ((reg_count < MB_PDU_FC03_MIN_REGISTERS) || (reg_count > MB_PDU_FC03_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_payload != NULL) {
        *out_payload = &pdu[2];
    }

    if (out_register_count != NULL) {
        *out_register_count = reg_count;
    }

    return MODBUS_ERROR_NONE;
}

#endif

#if MB_CONF_ENABLE_FC04
mb_err_t mb_pdu_build_read_input_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 quantity)
{
    const mb_size_t required = 5U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((quantity < MB_PDU_FC04_MIN_REGISTERS) || (quantity > MB_PDU_FC04_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_INPUT_REGISTERS;
    mb_pdu_write_u16(&out[1], start_addr);
    mb_pdu_write_u16(&out[3], quantity);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_input_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_quantity)
{
    if (pdu == NULL || len != 5U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_INPUT_REGISTERS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 quantity = mb_pdu_read_u16(&pdu[3]);
    if ((quantity < MB_PDU_FC04_MIN_REGISTERS) || (quantity > MB_PDU_FC04_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_addr != NULL) {
        *out_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_quantity != NULL) {
        *out_quantity = quantity;
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_read_input_response(mb_u8 *out, mb_size_t out_cap, const mb_u16 *registers, mb_u16 count)
{
    if (out == NULL || registers == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((count < MB_PDU_FC04_MIN_REGISTERS) || (count > MB_PDU_FC04_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t byte_count = (mb_size_t)count * 2U;
    const mb_size_t required = 2U + byte_count;

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_INPUT_REGISTERS;
    out[1] = (mb_u8)byte_count;

    for (mb_u16 i = 0U; i < count; ++i) {
        mb_pdu_write_u16(&out[2U + (i * 2U)], registers[i]);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_input_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u16 *out_register_count)
{
    if (pdu == NULL || len < 2U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_INPUT_REGISTERS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 byte_count = pdu[1];
    if ((byte_count & 0x01U) != 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(2U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 reg_count = (mb_u16)(byte_count / 2U);
    if ((reg_count < MB_PDU_FC04_MIN_REGISTERS) || (reg_count > MB_PDU_FC04_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_payload != NULL) {
        *out_payload = &pdu[2];
    }

    if (out_register_count != NULL) {
        *out_register_count = reg_count;
    }

    return MODBUS_ERROR_NONE;
}

#endif

// --------------------------------------------------------------------------

#if MB_CONF_ENABLE_FC06
mb_err_t mb_pdu_build_write_single_request(mb_u8 *out, mb_size_t out_cap, mb_u16 address, mb_u16 value)
{
    const mb_size_t required = 5U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_WRITE_SINGLE_REGISTER;
    mb_pdu_write_u16(&out[1], address);
    mb_pdu_write_u16(&out[3], value);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_write_single_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, mb_u16 *out_value)
{
    if (pdu == NULL || len != 5U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_WRITE_SINGLE_REGISTER) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_address != NULL) {
        *out_address = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_value != NULL) {
        *out_value = mb_pdu_read_u16(&pdu[3]);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_write_single_response(mb_u8 *out, mb_size_t out_cap, mb_u16 address, mb_u16 value)
{
    return mb_pdu_build_write_single_request(out, out_cap, address, value);
}

mb_err_t mb_pdu_parse_write_single_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, mb_u16 *out_value)
{
    return mb_pdu_parse_write_single_request(pdu, len, out_address, out_value);
}

#endif

#if MB_CONF_ENABLE_FC05
mb_err_t mb_pdu_build_write_single_coil_request(mb_u8 *out, mb_size_t out_cap, mb_u16 address, bool coil_on)
{
    const mb_size_t required = 5U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_WRITE_SINGLE_COIL;
    mb_pdu_write_u16(&out[1], address);
    mb_pdu_write_u16(&out[3], coil_on ? MB_PDU_COIL_ON_VALUE : MB_PDU_COIL_OFF_VALUE);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_write_single_coil_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, bool *out_coil_on)
{
    if (pdu == NULL || len != 5U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_WRITE_SINGLE_COIL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 raw_value = mb_pdu_read_u16(&pdu[3]);
    if (!mb_pdu_is_valid_coil_encoding(raw_value)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_address != NULL) {
        *out_address = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_coil_on != NULL) {
        *out_coil_on = (raw_value == MB_PDU_COIL_ON_VALUE);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_write_single_coil_response(mb_u8 *out, mb_size_t out_cap, mb_u16 address, bool coil_on)
{
    return mb_pdu_build_write_single_coil_request(out, out_cap, address, coil_on);
}

mb_err_t mb_pdu_parse_write_single_coil_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, bool *out_coil_on)
{
    return mb_pdu_parse_write_single_coil_request(pdu, len, out_address, out_coil_on);
}

#endif

#if MB_CONF_ENABLE_FC07
mb_err_t mb_pdu_build_read_exception_status_request(mb_u8 *out, mb_size_t out_cap)
{
    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(1U, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_EXCEPTION_STATUS;
    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_exception_status_request(const mb_u8 *pdu, mb_size_t len)
{
    if (pdu == NULL || len != 1U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_EXCEPTION_STATUS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_read_exception_status_response(mb_u8 *out, mb_size_t out_cap, mb_u8 status)
{
    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(2U, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_EXCEPTION_STATUS;
    out[1] = status;
    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_exception_status_response(const mb_u8 *pdu, mb_size_t len, mb_u8 *out_status)
{
    if (pdu == NULL || len != 2U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_EXCEPTION_STATUS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_status != NULL) {
        *out_status = pdu[1];
    }

    return MODBUS_ERROR_NONE;
}

#endif

#if MB_CONF_ENABLE_FC11
mb_err_t mb_pdu_build_report_server_id_request(mb_u8 *out, mb_size_t out_cap)
{
    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(1U, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_REPORT_SERVER_ID;
    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_report_server_id_request(const mb_u8 *pdu, mb_size_t len)
{
    if (pdu == NULL || len != 1U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_REPORT_SERVER_ID) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_report_server_id_response(mb_u8 *out, mb_size_t out_cap, const mb_u8 *payload, mb_size_t payload_len)
{
    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (payload_len > MB_PDU_FC11_MAX_PAYLOAD) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((payload_len > 0U) && (payload == NULL)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t required = 2U + payload_len;
    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_REPORT_SERVER_ID;
    out[1] = (mb_u8)payload_len;
    if (payload_len > 0U) {
        memcpy(&out[2], payload, payload_len);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_report_server_id_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u8 *out_byte_count)
{
    if (pdu == NULL || len < 2U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_REPORT_SERVER_ID) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_u8 byte_count = pdu[1];
    if (byte_count > MB_PDU_FC11_MAX_PAYLOAD) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(2U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_payload != NULL) {
        *out_payload = (byte_count > 0U) ? &pdu[2] : NULL;
    }

    if (out_byte_count != NULL) {
        *out_byte_count = byte_count;
    }

    return MODBUS_ERROR_NONE;
}

#endif

#if MB_CONF_ENABLE_FC10
mb_err_t mb_pdu_build_write_multiple_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, const mb_u16 *values, mb_u16 count)
{
    if (out == NULL || values == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((count < MB_PDU_FC16_MIN_REGISTERS) || (count > MB_PDU_FC16_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t byte_count = (mb_size_t)count * 2U;
    const mb_size_t required = 6U + byte_count;

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_WRITE_MULTIPLE_REGISTERS;
    mb_pdu_write_u16(&out[1], start_addr);
    mb_pdu_write_u16(&out[3], count);
    out[5] = (mb_u8)byte_count;

    for (mb_u16 i = 0U; i < count; ++i) {
        mb_pdu_write_u16(&out[6U + (i * 2U)], values[i]);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_write_multiple_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_count, const mb_u8 **out_payload)
{
    if (pdu == NULL || len < 8U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_WRITE_MULTIPLE_REGISTERS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 quantity = mb_pdu_read_u16(&pdu[3]);
    if ((quantity < MB_PDU_FC16_MIN_REGISTERS) || (quantity > MB_PDU_FC16_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 byte_count = pdu[5];
    if ((byte_count & 0x01U) != 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(6U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (byte_count != (mb_u8)(quantity * 2U)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_addr != NULL) {
        *out_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_count != NULL) {
        *out_count = quantity;
    }

    if (out_payload != NULL) {
        *out_payload = &pdu[6];
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_write_multiple_response(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 count)
{
    const mb_size_t required = 5U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((count < MB_PDU_FC16_MIN_REGISTERS) || (count > MB_PDU_FC16_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_WRITE_MULTIPLE_REGISTERS;
    mb_pdu_write_u16(&out[1], start_addr);
    mb_pdu_write_u16(&out[3], count);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_write_multiple_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_count)
{
    if (pdu == NULL || len != 5U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_WRITE_MULTIPLE_REGISTERS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 count = mb_pdu_read_u16(&pdu[3]);
    if ((count < MB_PDU_FC16_MIN_REGISTERS) || (count > MB_PDU_FC16_MAX_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_addr != NULL) {
        *out_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_count != NULL) {
        *out_count = count;
    }

    return MODBUS_ERROR_NONE;
}

#endif

#if MB_CONF_ENABLE_FC0F
mb_err_t mb_pdu_build_write_multiple_coils_request(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, const bool *coils, mb_u16 count)
{
    if (out == NULL || coils == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((count < MB_PDU_FC0F_MIN_COILS) || (count > MB_PDU_FC0F_MAX_COILS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t byte_count = mb_pdu_bits_to_bytes(count);
    const mb_size_t required = 6U + byte_count;

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_WRITE_MULTIPLE_COILS;
    mb_pdu_write_u16(&out[1], start_addr);
    mb_pdu_write_u16(&out[3], count);
    out[5] = (mb_u8)byte_count;
    memset(&out[6], 0, byte_count);
    mb_pdu_pack_bits_payload(&out[6], coils, count);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_write_multiple_coils_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_count, mb_u8 *out_byte_count, const mb_u8 **out_payload)
{
    if (pdu == NULL || len < 7U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_WRITE_MULTIPLE_COILS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 quantity = mb_pdu_read_u16(&pdu[3]);
    if ((quantity < MB_PDU_FC0F_MIN_COILS) || (quantity > MB_PDU_FC0F_MAX_COILS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 byte_count = pdu[5];
    mb_u8 expected = (mb_u8)mb_pdu_bits_to_bytes(quantity);
    if ((byte_count == 0U) || (byte_count != expected)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(6U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_addr != NULL) {
        *out_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_count != NULL) {
        *out_count = quantity;
    }

    if (out_byte_count != NULL) {
        *out_byte_count = byte_count;
    }

    if (out_payload != NULL) {
        *out_payload = &pdu[6];
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_write_multiple_coils_response(mb_u8 *out, mb_size_t out_cap, mb_u16 start_addr, mb_u16 count)
{
    const mb_size_t required = 5U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((count < MB_PDU_FC0F_MIN_COILS) || (count > MB_PDU_FC0F_MAX_COILS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_WRITE_MULTIPLE_COILS;
    mb_pdu_write_u16(&out[1], start_addr);
    mb_pdu_write_u16(&out[3], count);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_write_multiple_coils_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_addr, mb_u16 *out_count)
{
    if (pdu == NULL || len != 5U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_WRITE_MULTIPLE_COILS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 count = mb_pdu_read_u16(&pdu[3]);
    if ((count < MB_PDU_FC0F_MIN_COILS) || (count > MB_PDU_FC0F_MAX_COILS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_addr != NULL) {
        *out_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_count != NULL) {
        *out_count = count;
    }

    return MODBUS_ERROR_NONE;
}

#endif

#if MB_CONF_ENABLE_FC16
mb_err_t mb_pdu_build_mask_write_register_request(mb_u8 *out, mb_size_t out_cap, mb_u16 address, mb_u16 and_mask, mb_u16 or_mask)
{
    const mb_size_t required = 7U;

    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_MASK_WRITE_REGISTER;
    mb_pdu_write_u16(&out[1], address);
    mb_pdu_write_u16(&out[3], and_mask);
    mb_pdu_write_u16(&out[5], or_mask);

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_mask_write_register_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, mb_u16 *out_and_mask, mb_u16 *out_or_mask)
{
    if (pdu == NULL || len != 7U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_MASK_WRITE_REGISTER) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_address != NULL) {
        *out_address = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_and_mask != NULL) {
        *out_and_mask = mb_pdu_read_u16(&pdu[3]);
    }

    if (out_or_mask != NULL) {
        *out_or_mask = mb_pdu_read_u16(&pdu[5]);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_mask_write_register_response(mb_u8 *out, mb_size_t out_cap, mb_u16 address, mb_u16 and_mask, mb_u16 or_mask)
{
    return mb_pdu_build_mask_write_register_request(out, out_cap, address, and_mask, or_mask);
}

mb_err_t mb_pdu_parse_mask_write_register_response(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_address, mb_u16 *out_and_mask, mb_u16 *out_or_mask)
{
    return mb_pdu_parse_mask_write_register_request(pdu, len, out_address, out_and_mask, out_or_mask);
}

#endif

#if MB_CONF_ENABLE_FC17
mb_err_t mb_pdu_build_read_write_multiple_request(mb_u8 *out, mb_size_t out_cap, mb_u16 read_start_addr, mb_u16 read_quantity, mb_u16 write_start_addr, const mb_u16 *write_values, mb_u16 write_quantity)
{
    if (out == NULL || write_values == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((read_quantity < MB_PDU_FC17_MIN_READ_REGISTERS) || (read_quantity > MB_PDU_FC17_MAX_READ_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((write_quantity < MB_PDU_FC17_MIN_WRITE_REGISTERS) || (write_quantity > MB_PDU_FC17_MAX_WRITE_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t write_byte_count = (mb_size_t)write_quantity * 2U;
    const mb_size_t required = 10U + write_byte_count;

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_WRITE_MULTIPLE_REGISTERS;
    mb_pdu_write_u16(&out[1], read_start_addr);
    mb_pdu_write_u16(&out[3], read_quantity);
    mb_pdu_write_u16(&out[5], write_start_addr);
    mb_pdu_write_u16(&out[7], write_quantity);
    out[9] = (mb_u8)write_byte_count;

    for (mb_u16 i = 0U; i < write_quantity; ++i) {
        mb_pdu_write_u16(&out[10U + (i * 2U)], write_values[i]);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_write_multiple_request(const mb_u8 *pdu, mb_size_t len, mb_u16 *out_read_addr, mb_u16 *out_read_quantity, mb_u16 *out_write_addr, mb_u16 *out_write_quantity, const mb_u8 **out_write_payload)
{
    if (pdu == NULL || len < 12U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_WRITE_MULTIPLE_REGISTERS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 read_quantity = mb_pdu_read_u16(&pdu[3]);
    if ((read_quantity < MB_PDU_FC17_MIN_READ_REGISTERS) || (read_quantity > MB_PDU_FC17_MAX_READ_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 write_quantity = mb_pdu_read_u16(&pdu[7]);
    if ((write_quantity < MB_PDU_FC17_MIN_WRITE_REGISTERS) || (write_quantity > MB_PDU_FC17_MAX_WRITE_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 byte_count = pdu[9];
    if ((byte_count & 0x01U) != 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (byte_count != (mb_u8)(write_quantity * 2U)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(10U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_read_addr != NULL) {
        *out_read_addr = mb_pdu_read_u16(&pdu[1]);
    }

    if (out_read_quantity != NULL) {
        *out_read_quantity = read_quantity;
    }

    if (out_write_addr != NULL) {
        *out_write_addr = mb_pdu_read_u16(&pdu[5]);
    }

    if (out_write_quantity != NULL) {
        *out_write_quantity = write_quantity;
    }

    if (out_write_payload != NULL) {
        *out_write_payload = &pdu[10];
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_build_read_write_multiple_response(mb_u8 *out, mb_size_t out_cap, const mb_u16 *read_registers, mb_u16 read_quantity)
{
    if (out == NULL || read_registers == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((read_quantity < MB_PDU_FC17_MIN_READ_REGISTERS) || (read_quantity > MB_PDU_FC17_MAX_READ_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t byte_count = (mb_size_t)read_quantity * 2U;
    const mb_size_t required = 2U + byte_count;

    if (!mb_pdu_validate_capacity(required, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = MB_PDU_FC_READ_WRITE_MULTIPLE_REGISTERS;
    out[1] = (mb_u8)byte_count;

    for (mb_u16 i = 0U; i < read_quantity; ++i) {
        mb_pdu_write_u16(&out[2U + (i * 2U)], read_registers[i]);
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_read_write_multiple_response(const mb_u8 *pdu, mb_size_t len, const mb_u8 **out_payload, mb_u16 *out_register_count)
{
    if (pdu == NULL || len < 2U || len > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (pdu[0] != MB_PDU_FC_READ_WRITE_MULTIPLE_REGISTERS) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 byte_count = pdu[1];
    if ((byte_count & 0x01U) != 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len != (mb_size_t)(2U + byte_count)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u16 reg_count = (mb_u16)(byte_count / 2U);
    if ((reg_count < MB_PDU_FC17_MIN_READ_REGISTERS) || (reg_count > MB_PDU_FC17_MAX_READ_REGISTERS)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_payload != NULL) {
        *out_payload = &pdu[2];
    }

    if (out_register_count != NULL) {
        *out_register_count = reg_count;
    }

    return MODBUS_ERROR_NONE;
}
#endif

mb_err_t mb_pdu_build_exception(mb_u8 *out, mb_size_t out_cap, mb_u8 function, mb_u8 exception_code)
{
    if (out == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((function & MB_PDU_EXCEPTION_BIT) != 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (exception_code < MB_EX_ILLEGAL_FUNCTION || exception_code > MB_EX_SERVER_DEVICE_FAILURE) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!mb_pdu_validate_capacity(2U, out_cap)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out[0] = (mb_u8)(function | MB_PDU_EXCEPTION_BIT);
    out[1] = exception_code;
    return MODBUS_ERROR_NONE;
}

mb_err_t mb_pdu_parse_exception(const mb_u8 *pdu, mb_size_t len, mb_u8 *out_function, mb_u8 *out_exception)
{
    if (pdu == NULL || len != 2U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((pdu[0] & MB_PDU_EXCEPTION_BIT) == 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 function = (mb_u8)(pdu[0] & 0x7FU);
    mb_u8 code = pdu[1];

    if (code < MB_EX_ILLEGAL_FUNCTION || code > MB_EX_SERVER_DEVICE_FAILURE) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (out_function != NULL) {
        *out_function = function;
    }

    if (out_exception != NULL) {
        *out_exception = code;
    }

    return MODBUS_ERROR_NONE;
}

// NOLINTEND(bugprone-easily-swappable-parameters)
/* ===== End modbus/src/pdu.c ===== */

/* ===== Begin modbus/src/frame.c ===== */
/**
 * @file frame.c
 * @brief Implementation of Modbus ADU framing helpers.
 */

#include <stdbool.h>
#include <string.h>


mb_err_t mb_frame_rtu_encode(const mb_adu_view_t *adu,
                             mb_u8 *out_adu,
                             mb_size_t out_cap,
                             mb_size_t *out_len)
{
    if (out_len) {
        *out_len = 0U;
    }

    if (!adu || !out_adu) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((adu->payload_len + 1U) > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t required = 1U + 1U + adu->payload_len + 2U;
    if (out_cap < required) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_size_t index = 0U;
    out_adu[index++] = adu->unit_id;
    out_adu[index++] = adu->function;

    if (adu->payload && adu->payload_len > 0U) {
        memcpy(&out_adu[index], adu->payload, adu->payload_len);
        index += adu->payload_len;
    }

    const mb_u16 crc = modbus_crc_with_table(out_adu, (mb_u16)index);
    out_adu[index++] = (mb_u8)(crc & 0xFFU);
    out_adu[index++] = (mb_u8)((crc >> 8) & 0xFFU);

    if (out_len) {
        *out_len = index;
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_frame_rtu_decode(const mb_u8 *adu,
                             mb_size_t adu_len,
                             mb_adu_view_t *out)
{
    if (!adu || !out) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (adu_len < 4U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_u16 computed_crc = modbus_crc_with_table(adu, (mb_u16)(adu_len - 2U));
    const mb_u16 frame_crc = (mb_u16)((mb_u16)adu[adu_len - 1U] << 8U) | adu[adu_len - 2U];
    if (computed_crc != frame_crc) {
        return MODBUS_ERROR_CRC;
    }

    const mb_size_t payload_len = adu_len - 4U; /* address + function + crc(2) */
    if ((payload_len + 1U) > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    out->unit_id = adu[0];
    out->function = adu[1];
    out->payload = (payload_len > 0U) ? &adu[2] : NULL;
    out->payload_len = payload_len;

    return MODBUS_ERROR_NONE;
}

#if MB_CONF_TRANSPORT_ASCII
static mb_u8 mb_frame_ascii_lrc(const mb_u8 *data, mb_size_t len)
{
    mb_u32 sum = 0U;
    for (mb_size_t i = 0U; i < len; ++i) {
        sum += data[i];
    }

    sum &= 0xFFU;
    return (mb_u8)(((~sum) + 1U) & 0xFFU);
}

static bool mb_frame_ascii_nibble(mb_u8 ch, mb_u8 *out)
{
    if (out == NULL) {
        return false;
    }

    if (ch >= '0' && ch <= '9') {
        *out = (mb_u8)(ch - '0');
        return true;
    }

    if (ch >= 'A' && ch <= 'F') {
        *out = (mb_u8)(10U + (ch - 'A'));
        return true;
    }

    if (ch >= 'a' && ch <= 'f') {
        *out = (mb_u8)(10U + (ch - 'a'));
        return true;
    }

    return false;
}

static bool mb_frame_ascii_hex_pair_to_byte(mb_u8 hi, mb_u8 lo, mb_u8 *out)
{
    mb_u8 high = 0U;
    mb_u8 low = 0U;

    if (!mb_frame_ascii_nibble(hi, &high) || !mb_frame_ascii_nibble(lo, &low)) {
        return false;
    }

    *out = (mb_u8)((high << 4U) | low);
    return true;
}

mb_err_t mb_frame_ascii_encode(const mb_adu_view_t *adu,
                               mb_u8 *out_ascii,
                               mb_size_t out_cap,
                               mb_size_t *out_len)
{
    if (out_len) {
        *out_len = 0U;
    }

    if (!adu || !out_ascii) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if ((adu->payload_len + 1U) > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (adu->payload_len > 0U && adu->payload == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const mb_size_t bytes_len = 2U + adu->payload_len;
    mb_u8 bytes[MB_PDU_MAX + 3U];

    bytes[0] = adu->unit_id;
    bytes[1] = adu->function;

    if (adu->payload_len > 0U) {
        memcpy(&bytes[2], adu->payload, adu->payload_len);
    }

    const mb_u8 lrc = mb_frame_ascii_lrc(bytes, bytes_len);
    bytes[bytes_len] = lrc;

    const mb_size_t data_len = bytes_len + 1U;
    const mb_size_t required = 1U + (data_len * 2U) + 2U;
    if (out_cap < required) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    static const char hex_digits[] = "0123456789ABCDEF";

    mb_size_t index = 0U;
    out_ascii[index++] = ':';

    for (mb_size_t i = 0U; i < data_len; ++i) {
        const mb_u8 value = bytes[i];
        out_ascii[index++] = (mb_u8)hex_digits[(value >> 4U) & 0x0FU];
        out_ascii[index++] = (mb_u8)hex_digits[value & 0x0FU];
    }

    out_ascii[index++] = '\r';
    out_ascii[index++] = '\n';

    if (out_len) {
        *out_len = index;
    }

    return MODBUS_ERROR_NONE;
}

mb_err_t mb_frame_ascii_decode(const mb_u8 *ascii,
                               mb_size_t ascii_len,
                               mb_adu_view_t *out,
                               mb_u8 *payload_buf,
                               mb_size_t payload_cap)
{
    if (!ascii || !out) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (ascii_len < 9U) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (ascii[0] != ':') {
        return MODBUS_ERROR_INVALID_REQUEST;
    }

    if (ascii[ascii_len - 2U] != '\r' || ascii[ascii_len - 1U] != '\n') {
        return MODBUS_ERROR_INVALID_REQUEST;
    }

    const mb_size_t hex_digits = ascii_len - 3U; /* strip ':' and CRLF */
    if ((hex_digits % 2U) != 0U) {
        return MODBUS_ERROR_INVALID_REQUEST;
    }

    const mb_size_t byte_count = hex_digits / 2U;
    if (byte_count < 3U) {
        return MODBUS_ERROR_INVALID_REQUEST;
    }

    if (byte_count > (MB_PDU_MAX + 3U)) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 bytes[MB_PDU_MAX + 3U];
    const mb_u8 *cursor = &ascii[1];

    for (mb_size_t i = 0U; i < byte_count; ++i) {
        mb_u8 value = 0U;
        if (!mb_frame_ascii_hex_pair_to_byte(cursor[0], cursor[1], &value)) {
            return MODBUS_ERROR_INVALID_REQUEST;
        }
        bytes[i] = value;
        cursor += 2;
    }

    const mb_u8 expected_lrc = bytes[byte_count - 1U];
    const mb_u8 computed_lrc = mb_frame_ascii_lrc(bytes, byte_count - 1U);
    if (expected_lrc != computed_lrc) {
        return MODBUS_ERROR_CRC;
    }

    const mb_size_t payload_len = byte_count - 3U;
    if ((payload_len + 1U) > MB_PDU_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    memset(out, 0, sizeof *out);
    out->unit_id = bytes[0];
    out->function = bytes[1];
    out->payload_len = payload_len;

    if (payload_len > 0U) {
        if (!payload_buf || payload_cap < payload_len) {
            return MODBUS_ERROR_INVALID_ARGUMENT;
        }
        memcpy(payload_buf, &bytes[2], payload_len);
        out->payload = payload_buf;
    } else {
        out->payload = NULL;
    }

    return MODBUS_ERROR_NONE;
}
#endif /* MB_CONF_TRANSPORT_ASCII */
/* ===== End modbus/src/frame.c ===== */

/* ===== Begin modbus/src/transport.c ===== */
#include <limits.h>


static mb_err_t modbus_transport_legacy_send(void *ctx,
                                             const mb_u8 *buf,
                                             mb_size_t len,
                                             mb_transport_io_result_t *out)
{
    modbus_transport_t *legacy = (modbus_transport_t *)ctx;
    if (!legacy || !buf || !legacy->write) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (len > (mb_size_t)UINT16_MAX) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    const int32_t written = legacy->write(buf, (uint16_t)len);
    if (written < 0) {
        return MODBUS_ERROR_TRANSPORT;
    }

    if (out) {
        out->processed = (mb_size_t)written;
    }

    return (written == (int32_t)len) ? MODBUS_ERROR_NONE : MODBUS_ERROR_TRANSPORT;
}

static mb_err_t modbus_transport_legacy_recv(void *ctx,
                                             mb_u8 *buf,
                                             mb_size_t cap,
                                             mb_transport_io_result_t *out)
{
    modbus_transport_t *legacy = (modbus_transport_t *)ctx;
    if (!legacy || !buf || cap == 0U || !legacy->read) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (cap > (mb_size_t)UINT16_MAX) {
        cap = UINT16_MAX;
    }

    const int32_t bytes = legacy->read(buf, (uint16_t)cap);
    if (bytes < 0) {
        return MODBUS_ERROR_TRANSPORT;
    }

    if (out) {
        out->processed = (mb_size_t)bytes;
    }

    return (bytes > 0) ? MODBUS_ERROR_NONE : MODBUS_ERROR_TIMEOUT;
}

static mb_time_ms_t modbus_transport_legacy_now(void *ctx)
{
    modbus_transport_t *legacy = (modbus_transport_t *)ctx;
    if (!legacy || !legacy->get_reference_msec) {
        return 0U;
    }

    return (mb_time_ms_t)legacy->get_reference_msec();
}

mb_err_t modbus_transport_bind_legacy(mb_transport_if_t *iface, modbus_transport_t *legacy)
{
    if (!iface || !legacy) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    if (!legacy->write || !legacy->read || !legacy->get_reference_msec) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    iface->ctx = legacy;
    iface->send = modbus_transport_legacy_send;
    iface->recv = modbus_transport_legacy_recv;
    iface->now = modbus_transport_legacy_now;
    iface->yield = NULL;

    return MODBUS_ERROR_NONE;
}
/* ===== End modbus/src/transport.c ===== */

/* ===== Begin modbus/src/transport/rtu/rtu.c ===== */

#if MB_CONF_TRANSPORT_RTU


#include <string.h>

static void mb_rtu_invoke_callback(mb_rtu_transport_t *rtu,
                                   const mb_adu_view_t *adu,
                                   mb_err_t status)
{
    if (rtu->callback) {
        rtu->callback(rtu, adu, status, rtu->user_ctx);
    }
}

mb_err_t mb_rtu_init(mb_rtu_transport_t *rtu,
                     const mb_transport_if_t *iface,
                     mb_rtu_frame_callback_t callback,
                     void *user_ctx)
{
    if (rtu == NULL || iface == NULL || iface->recv == NULL || iface->send == NULL || iface->now == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    memset(rtu, 0, sizeof(*rtu));
    rtu->iface = iface;
    rtu->silence_timeout_ms = MB_RTU_DEFAULT_SILENCE_TIMEOUT_MS;
    rtu->callback = callback;
    rtu->user_ctx = user_ctx;

    return MODBUS_ERROR_NONE;
}

void mb_rtu_reset(mb_rtu_transport_t *rtu)
{
    if (rtu == NULL) {
        return;
    }

    rtu->index = 0U;
    rtu->receiving = false;
}

void mb_rtu_set_silence_timeout(mb_rtu_transport_t *rtu, mb_time_ms_t timeout_ms)
{
    if (rtu == NULL) {
        return;
    }

    rtu->silence_timeout_ms = (timeout_ms == 0U) ? MB_RTU_DEFAULT_SILENCE_TIMEOUT_MS : timeout_ms;
}

static void mb_rtu_finalize_frame(mb_rtu_transport_t *rtu, mb_err_t status)
{
    if (rtu->index >= 4U && status == MODBUS_ERROR_NONE) {
        mb_adu_view_t view = {0};
        status = mb_frame_rtu_decode(rtu->buffer, rtu->index, &view);
        if (status == MODBUS_ERROR_NONE) {
            mb_rtu_invoke_callback(rtu, &view, status);
        } else {
            mb_rtu_invoke_callback(rtu, NULL, status);
        }
    } else {
        if (status == MODBUS_ERROR_NONE) {
            status = MODBUS_ERROR_INVALID_REQUEST;
        }
        mb_rtu_invoke_callback(rtu, NULL, status);
    }

    mb_rtu_reset(rtu);
}

static void mb_rtu_process_byte(mb_rtu_transport_t *rtu, mb_u8 byte)
{
    if (rtu->index >= MB_RTU_BUFFER_SIZE) {
        mb_rtu_finalize_frame(rtu, MODBUS_ERROR_INVALID_REQUEST);
        return;
    }

    rtu->buffer[rtu->index++] = byte;
    rtu->last_activity = mb_transport_now(rtu->iface);
    rtu->receiving = true;
    if (rtu->index >= MB_RTU_BUFFER_SIZE) {
        mb_rtu_finalize_frame(rtu, MODBUS_ERROR_INVALID_REQUEST);
    }
}

mb_err_t mb_rtu_poll(mb_rtu_transport_t *rtu)
{
    if (rtu == NULL || rtu->iface == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_err_t last_status = MODBUS_ERROR_NONE;

    while (true) {
        mb_transport_io_result_t io = {0};
        mb_u8 byte = 0U;
        mb_err_t status = mb_transport_recv(rtu->iface, &byte, 1U, &io);

        if (status == MODBUS_ERROR_NONE && io.processed > 0U) {
            mb_rtu_process_byte(rtu, byte);
            last_status = MODBUS_ERROR_NONE;
            continue;
        }

        if (status == MODBUS_ERROR_TIMEOUT || (status == MODBUS_ERROR_NONE && io.processed == 0U)) {
            last_status = MODBUS_ERROR_NONE;
        } else if (status != MODBUS_ERROR_NONE) {
            mb_rtu_invoke_callback(rtu, NULL, status);
            last_status = status;
        }
        break;
    }

    if (rtu->receiving) {
        const mb_time_ms_t elapsed = mb_transport_elapsed_since(rtu->iface, rtu->last_activity);
        if (elapsed >= rtu->silence_timeout_ms) {
            mb_rtu_finalize_frame(rtu, MODBUS_ERROR_NONE);
        }
    }

    return last_status;
}

mb_err_t mb_rtu_submit(mb_rtu_transport_t *rtu, const mb_adu_view_t *adu)
{
    if (rtu == NULL || adu == NULL) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_u8 frame[MB_RTU_BUFFER_SIZE];
    mb_size_t frame_len = 0U;
    mb_err_t status = mb_frame_rtu_encode(adu, frame, sizeof frame, &frame_len);
    if (status != MODBUS_ERROR_NONE) {
        return status;
    }

    mb_transport_io_result_t io = {0};
    status = mb_transport_send(rtu->iface, frame, frame_len, &io);
    if (status != MODBUS_ERROR_NONE) {
        return status;
    }

    if (io.processed != frame_len) {
        return MODBUS_ERROR_TRANSPORT;
    }

    return MODBUS_ERROR_NONE;
}
#endif /* MB_CONF_TRANSPORT_RTU */
/* ===== End modbus/src/transport/rtu/rtu.c ===== */

/* ===== Begin modbus/src/fsm.c ===== */
/**
 * @file fsm.c
 * @brief Finite State Machine (FSM) framework implementation.
 *
 * This file implements the functions declared in `fsm.h`. It provides a simple
 * event-driven finite state machine framework where events are queued, and the
 * state machine processes these events to potentially trigger state transitions.
 * Actions and guard conditions can be defined for each transition.
 *
 * The FSM is designed to be non-blocking and can be integrated into a main loop
 * or a cooperative multitasking environment. This makes it suitable for use
 * in embedded systems, including those implementing communication protocols
 * such as Modbus Client and Server.
 *
 * **Key Features:**
 * - Initialization of the FSM with an initial state and optional user data.
 * - Handling and queuing of events in a thread-safe manner.
 * - Processing of events to execute state transitions based on defined transitions.
 * - Execution of actions associated with transitions.
 * - Support for guard conditions to control transition eligibility.
 *
 * **Usage Example:**
 * @code
 * // Define action and guard callbacks
 * void on_enter_state(fsm_t *fsm) { 
 *     // Action to perform upon entering a new state
 * }
 * 
 * bool guard_condition(fsm_t *fsm) { 
 *     // Condition to allow transition
 *     return true; 
 * }
 *
 * // Define transitions for the IDLE state
 * static const fsm_transition_t state_idle_transitions[] = {
 *     FSM_TRANSITION(EVENT_START, state_running, on_enter_state, guard_condition)
 * };
 *
 * // Define the IDLE state
 * static const fsm_state_t state_idle = FSM_STATE("IDLE", 0, state_idle_transitions, NULL);
 *
 * // Define transitions for the RUNNING state
 * static const fsm_transition_t state_running_transitions[] = {
 *     FSM_TRANSITION(EVENT_STOP, state_idle, on_exit_state, NULL)
 * };
 *
 * // Define the RUNNING state
 * static const fsm_state_t state_running = FSM_STATE("RUNNING", 1, state_running_transitions, on_run_action);
 *
 * // Initialize and use the FSM
 * fsm_t my_fsm;
 * fsm_init(&my_fsm, &state_idle, NULL);
 * fsm_handle_event(&my_fsm, EVENT_START);
 * fsm_run(&my_fsm);  // Processes EVENT_START and transitions to RUNNING state.
 * @endcode
 *
 * @note
 * - Ensure that states are defined before they are referenced in transitions.
 * - The FSM framework is designed to be thread-safe; however, ensure that
 *   event handling and state transitions are managed appropriately in concurrent environments.
 * 
 * @see fsm.h
 *
 * @ingroup FSM
 * @{
 */

#include <stddef.h>

extern uint16_t get_current_time_ms(void);

/**
 * @brief Initializes the finite state machine (FSM).
 *
 * Sets the initial state, associates optional user data, and clears the event queue.
 * This function must be called before using the FSM to ensure it starts in a known state.
 *
 * @param[in,out] fsm           Pointer to the FSM instance to initialize.
 * @param[in]     initial_state Pointer to the initial state of the FSM.
 * @param[in]     user_data     Pointer to user-defined data (can be `NULL`).
 *
 * @warning
 * - Both `fsm` and `initial_state` must not be `NULL`. If either is `NULL`, the function returns immediately without initializing.
 *
 * @example
 * ```c
 * fsm_t my_fsm;
 * fsm_init(&my_fsm, &state_idle, &app_context);
 * ```
 */
static inline uint16_t fsm_now(const fsm_t *fsm)
{
    if (fsm == NULL) {
        return 0U;
    }

    if (fsm->time_fn != NULL) {
        return fsm->time_fn();
    }

    return get_current_time_ms();
}

static void fsm_queue_reset(fsm_t *fsm)
{
    if (fsm == NULL) {
        return;
    }

    fsm->event_queue.head = 0U;
    fsm->event_queue.tail = 0U;
}

static void fsm_bind_queue(fsm_t *fsm, const fsm_config_t *config)
{
    if (fsm == NULL) {
        return;
    }

    if (config != NULL && config->queue_storage != NULL && config->queue_capacity > 0U) {
        fsm->event_queue.events = config->queue_storage;
        fsm->event_queue.capacity = config->queue_capacity;
    }
#if FSM_CONF_INLINE_QUEUE
    else {
        fsm->event_queue.events = fsm->inline_queue;
        fsm->event_queue.capacity = FSM_EVENT_QUEUE_SIZE;
    }
#else
    else {
        fsm->event_queue.events = NULL;
        fsm->event_queue.capacity = 0U;
    }
#endif

    if (fsm->event_queue.capacity < 2U) {
        fsm->event_queue.events = NULL;
        fsm->event_queue.capacity = 0U;
    }

    fsm_queue_reset(fsm);
}

void fsm_init_with_config(fsm_t *fsm,
                          const fsm_state_t *initial_state,
                          void *user_data,
                          const fsm_config_t *config)
{
    if (fsm == NULL || initial_state == NULL) {
        return;
    }

    fsm->current_state = initial_state;
    fsm->user_data = user_data;
    fsm->time_fn = (config != NULL && config->time_fn != NULL) ? config->time_fn : get_current_time_ms;
    fsm->event_drop_cb = (config != NULL) ? config->on_event_drop : NULL;

    fsm_bind_queue(fsm, config);

    fsm->state_entry_time = fsm_now(fsm);
    fsm->has_timeout = false;
}

void fsm_init(fsm_t *fsm, const fsm_state_t *initial_state, void *user_data)
{
    fsm_init_with_config(fsm, initial_state, user_data, NULL);
}

/**
 * @brief Adds an event to the FSM's event queue.
 *
 * This function queues an event to be processed by the FSM. If the event queue is full,
 * the new event is discarded to prevent overflow. It is safe to call this function
 * from both interrupt service routines (ISRs) and the main loop.
 *
 * @param[in,out] fsm   Pointer to the FSM instance.
 * @param[in]     event Event to handle.
 *
 * @warning
 * - If the event queue is full, the new event will be discarded. Consider increasing
 *   `FSM_EVENT_QUEUE_SIZE` if event loss is unacceptable.
 *
 * @example
 * ```c
 * fsm_handle_event(&my_fsm, EVENT_START);
 * ```
 */
void fsm_handle_event(fsm_t *fsm, uint8_t event) {
    if (!fsm) {
        // Optionally, log an error or handle the invalid FSM pointer
        return;
    }
    if (fsm->event_queue.events == NULL || fsm->event_queue.capacity == 0U) {
        return;
    }

    fsm_queue_index_t next_tail = fsm->event_queue.tail + 1U;
    if (next_tail >= fsm->event_queue.capacity) {
        next_tail = 0U;
    }

    if (next_tail != fsm->event_queue.head) {
        fsm->event_queue.events[fsm->event_queue.tail] = event;
        fsm->event_queue.tail = next_tail;
    } else if (fsm->event_drop_cb != NULL) {
        fsm->event_drop_cb(fsm, event);
    }
}

/**
 * @brief Processes any pending events from the queue and executes state transitions if needed.
 *
 * This function should be called regularly (e.g., in the main loop). It retrieves events
 * from the queue and checks transitions in the current state. If a matching transition
 * is found and its guard returns `true`, it executes the action and changes state.
 * If no event matches or no event is pending, it executes the state's default action (if any).
 *
 * @param[in,out] fsm Pointer to the FSM instance.
 *
 * @warning
 * - Ensure that `fsm_init` has been called before using `fsm_run`.
 * - This function is non-blocking and should be integrated into an iterative loop.
 *
 * @example
 * ```c
 * while (1) {
 *     fsm_run(&my_fsm);
 *     // Other application code
 * }
 * ```
 */
void fsm_run(fsm_t *fsm) {
    if (!fsm || !fsm->current_state) {
        // Optionally, log an error or handle the invalid FSM state
        return;
    }

    const fsm_state_t *s = fsm->current_state;
    fsm->has_timeout = false;

    // 1) se este estado tem timeout configurado, verifica se excedeu
    if (s->timeout_ms > 0U) {
        const uint16_t now = fsm_now(fsm);
        const uint16_t elapsed = now - fsm->state_entry_time;
        if (elapsed >= s->timeout_ms) {
            // limpa fila e dispara evento de timeout
            fsm_queue_reset(fsm);
            fsm->has_timeout = true;
            fsm_handle_event(fsm, FSM_EVENT_STATE_TIMEOUT);
            // atualiza timestamp (para não disparar repetidamente)
            fsm->state_entry_time = now;
        }
    }

    if (fsm->event_queue.events == NULL || fsm->event_queue.capacity == 0U) {
        if (fsm->current_state->default_action) {
            fsm->current_state->default_action(fsm);
        }
        return;
    }

    // Check if we have an event to process
    if (fsm->event_queue.head == fsm->event_queue.tail) {
        // No events pending, execute default action if available
        if (fsm->current_state->default_action) {
            fsm->current_state->default_action(fsm);
        }
        return;
    }

    // Get next event from the queue
    uint8_t event = fsm->event_queue.events[fsm->event_queue.head];
    fsm->event_queue.head = (fsm->event_queue.head + 1U);
    if (fsm->event_queue.head >= fsm->event_queue.capacity) {
        fsm->event_queue.head = 0U;
    }

    // Try to find a matching transition for this event
    const fsm_state_t *state = fsm->current_state;
    const fsm_transition_t *transitions = state->transitions;
    uint8_t num_transitions = state->num_transitions;
    bool event_processed = false;

    for (uint8_t i = 0; i < num_transitions; i++) {
        const fsm_transition_t *transition = &transitions[i];
        if (transition->event == event) {
            bool guard_passed = (transition->guard == NULL) || transition->guard(fsm);
            if (guard_passed) {
                if (transition->action) {
                    transition->action(fsm);
                }
                fsm->current_state = transition->next_state;
                fsm->state_entry_time = fsm_now(fsm);
                event_processed = true;
            } else {
                /* Guard rejected transition, requeue event for future evaluation */
                fsm_handle_event(fsm, event);
            }
            break;
        }
    }

    // If the event was not processed (no matching transition), it is ignored.
    // Optionally, handle unprocessed events here (e.g., logging or error handling).

    // After handling this event, if no transitions occurred and no more events are queued,
    // execute the default action if defined.
    if (!event_processed && fsm->event_queue.head == fsm->event_queue.tail && fsm->current_state->default_action) {
        fsm->current_state->default_action(fsm);
    }
}

/* ===== End modbus/src/fsm.c ===== */

/* ===== Begin modbus/src/core.c ===== */
/**
 * @file modbus_core.c
 * @brief Implementation of core Modbus protocol functions for both Client and Server.
 *
 * This source file implements the functions declared in `modbus_core.h`.
 * It provides core functionality for constructing, parsing, sending,
 * and receiving Modbus RTU frames.
 *
 * **Key Functionalities:**
 * - **Building Frames:** Constructs Modbus RTU frames by appending CRC.
 * - **Parsing Frames:** Parses and validates received Modbus RTU frames.
 * - **Sending Frames:** Abstracted send functions using the transport interface.
 * - **Receiving Frames:** Abstracted receive functions with basic timeout handling.
 * - **Exception Handling:** Maps Modbus exception codes to `modbus_error_t`.
 * - **Buffer Management:** Resets RX/TX buffers for new transactions or after errors.
 *
 * **Notes:**
 * - Ensure that the transport layer is correctly initialized before using send and receive functions.
 * - Handle exceptions and error codes appropriately to maintain robust communication.
 * - The buffer sizes should be adequately defined based on the expected frame sizes.
 * - Consider enhancing `modbus_receive_frame()` to include comprehensive timeout and inter-frame delay handling.
 *
 * **Usage Example:**
 * @code
 * // Building a Modbus RTU frame for reading holding registers
 * uint8_t request_data[] = {0x00, 0x01, 0x00, 0x02}; // Starting address and quantity
 * uint8_t frame[256];
 * uint16_t frame_length = modbus_build_rtu_frame(0x01, MODBUS_FUNC_READ_HOLDING_REGISTERS,
 *                                               request_data, sizeof(request_data),
 *                                               frame, sizeof(frame));
 *
 * // Sending the frame
 * modbus_error_t send_error = modbus_send_frame(&ctx, frame, frame_length);
 * if (send_error != MODBUS_ERROR_NONE) {
 *     // Handle send error
 * }
 *
 * // Receiving a response frame
 * uint8_t response_frame[256];
 * uint16_t response_length;
 * modbus_error_t recv_error = modbus_receive_frame(&ctx, response_frame, sizeof(response_frame), &response_length);
 *
 * if (recv_error == MODBUS_ERROR_NONE) {
 *     uint8_t address, function;
 *     const uint8_t *payload;
 *     uint16_t payload_len;
 *     modbus_error_t parse_error = modbus_parse_rtu_frame(response_frame, response_length, &address, &function, &payload, &payload_len);
 *     if (parse_error == MODBUS_ERROR_NONE) {
 *         // Process payload
 *     } else {
 *         // Handle parse error
 *     }
 * } else {
 *     // Handle receive error
 * }
 * @endcode
 *
 * @see modbus_core.h, modbus_transport.h, modbus_utils.h
 *
 * @ingroup ModbusCore
 * @{
 */

#include <string.h>


/* Internal defines for timeouts, if needed */
#ifndef MODBUS_INTERFRAME_TIMEOUT_MS
#define MODBUS_INTERFRAME_TIMEOUT_MS 100 /**< Time in milliseconds to wait between frames */
#endif

#ifndef MODBUS_BYTE_TIMEOUT_MS
#define MODBUS_BYTE_TIMEOUT_MS 50 /**< Time in milliseconds to wait between bytes */
#endif

/**
 * @brief Builds a Modbus RTU frame by adding CRC.
 *
 * This function constructs a complete Modbus RTU frame by appending the CRC
 * to the provided address, function code, and data payload. It ensures that
 * the output buffer has sufficient space to hold the entire frame, including
 * the CRC.
 *
 * @param[in]  address         Modbus server/client address (or target device address).
 * @param[in]  function_code   Modbus function code.
 * @param[in]  data            Pointer to the data payload (excluding CRC).
 * @param[in]  data_length     Length of the data payload in bytes.
 * @param[out] out_buffer      Buffer to store the complete frame (including CRC).
 * @param[in]  out_buffer_size Size of the `out_buffer` in bytes.
 * 
 * @return Number of bytes written to `out_buffer`, or 0 if there is not enough space.
 *
 * @retval >0  Number of bytes written to `out_buffer`.
 * @retval 0   Insufficient buffer size to store the complete frame.
 *
 * @warning
 * - Ensure that `out_buffer` has enough space to accommodate `address` (1 byte),
 *   `function_code` (1 byte), `data` (`data_length` bytes), and CRC (2 bytes).
 * 
 * @example
 * ```c
 * uint8_t payload[] = {0x00, 0x01, 0x00, 0x02};
 * uint8_t frame[256];
 * uint16_t frame_len = modbus_build_rtu_frame(0x01, MODBUS_FUNC_READ_HOLDING_REGISTERS,
 *                                           payload, sizeof(payload),
 *                                           frame, sizeof(frame));
 * if (frame_len > 0) {
 *     // Frame successfully built, proceed to send
 * }
 * ```
 */
#if MB_CONF_TRANSPORT_RTU
uint16_t modbus_build_rtu_frame(uint8_t address, uint8_t function_code,
                                const uint8_t *data, uint16_t data_length,
                                uint8_t *out_buffer, uint16_t out_buffer_size) {
    const mb_adu_view_t adu = {
        .unit_id = address,
        .function = function_code,
        .payload = data,
        .payload_len = data_length
    };

    mb_size_t produced = 0U;
    if (mb_frame_rtu_encode(&adu, out_buffer, out_buffer_size, &produced) != MODBUS_ERROR_NONE) {
        return 0U;
    }

    return (uint16_t)produced;
}

/**
 * @brief Parses a Modbus RTU frame, verifying CRC.
 *
 * This function validates the CRC of the provided Modbus RTU frame. If the CRC is
 * correct, it extracts the address, function code, and payload from the frame.
 * The payload can then be interpreted based on the function code.
 *
 * @param[in]  frame        Pointer to the frame buffer (address + function + data + CRC).
 * @param[in]  frame_length Length of the frame in bytes.
 * @param[out] address      Pointer to store the parsed address.
 * @param[out] function     Pointer to store the parsed function code.
 * @param[out] payload      Pointer to store the start of the payload within the frame.
 * @param[out] payload_len  Pointer to store the length of the payload (excluding CRC).
 *
 * @return modbus_error_t `MODBUS_ERROR_NONE` if successful, or an error/exception code.
 *
 * @retval MODBUS_ERROR_NONE                  Frame parsed and CRC validated successfully.
 * @retval MODBUS_ERROR_INVALID_ARGUMENT       Frame length is too short or pointers are `NULL`.
 * @retval MODBUS_ERROR_CRC                    CRC check failed.
 * @retval MODBUS_EXCEPTION_ILLEGAL_FUNCTION   The function code indicates an error response.
 * @retval MODBUS_ERROR_OTHER                  Other error codes as defined in `modbus_error_t`.
 *
 * @warning
 * - The frame must contain at least 4 bytes: address (1 byte) + function code (1 byte) + CRC (2 bytes).
 * - Ensure that `payload` and `payload_len` are valid pointers before calling this function.
 * 
 * @example
 * ```c
 * uint8_t response_frame[] = {0x01, 0x03, 0x02, 0x00, 0x0A, 0xC4, 0x0B};
 * uint16_t response_length = sizeof(response_frame);
 * uint8_t address, function;
 * const uint8_t *payload;
 * uint16_t payload_len;
 *
 * modbus_error_t error = modbus_parse_rtu_frame(response_frame, response_length, &address, &function, &payload, &payload_len);
 * if (error == MODBUS_ERROR_NONE) {
 *     // Process payload
 * }
 * ```
 */
modbus_error_t modbus_parse_rtu_frame(const uint8_t *frame, uint16_t frame_length,
                                      uint8_t *address, uint8_t *function,
                                      const uint8_t **payload, uint16_t *payload_len) {
    if (!frame || !address || !function || !payload || !payload_len) {
        return MODBUS_ERROR_INVALID_ARGUMENT;
    }

    mb_adu_view_t adu = {0};
    modbus_error_t status = mb_frame_rtu_decode(frame, frame_length, &adu);
    if (status != MODBUS_ERROR_NONE) {
        return status;
    }

    *address = adu.unit_id;
    *function = adu.function;

    /* Check if the function code indicates an error response */
    if (modbus_is_error_response(*function)) {
        if (adu.payload_len == 0U || !adu.payload) {
            return MODBUS_ERROR_INVALID_ARGUMENT;
        }
        uint8_t exception_code = adu.payload[0];
        return modbus_exception_to_error(exception_code);
    }

    /* Extract payload */
    *payload = adu.payload;
    *payload_len = (uint16_t)adu.payload_len;

    return MODBUS_ERROR_NONE;
}

/**
 * @brief Sends a Modbus frame using the configured transport.
 *
 * This function attempts to send the provided Modbus RTU frame through the
 * configured transport interface. It ensures that the entire frame is sent.
 * The behavior is non-blocking and depends on the transport implementation.
 *
 * @param[in]  ctx        Pointer to the Modbus context.
 * @param[in]  frame      Pointer to the complete Modbus RTU frame (including CRC).
 * @param[in]  frame_len  Length of the frame in bytes.
 *
 * @return modbus_error_t `MODBUS_ERROR_NONE` on successful send, or an error code.
 *
 * @retval MODBUS_ERROR_NONE          Frame sent successfully.
 * @retval MODBUS_ERROR_TRANSPORT     Transport layer encountered an error.
 * @retval MODBUS_ERROR_INVALID_ARGUMENT Invalid context or frame parameters.
 * @retval MODBUS_ERROR_PARTIAL_WRITE Partial frame was written (if transport returns fewer bytes).
 * @retval Others                      Various error codes as defined in `modbus_error_t`.
 *
 * @warning
 * - Ensure that the transport's write function is properly implemented and initialized.
 * - The function does not handle retries; implement retry logic if necessary.
 * 
 * @example
 * ```c
 * uint8_t frame[] = {0x01, 0x03, 0x00, 0x01, 0x00, 0x02, 0xC4, 0x0B};
 * modbus_error_t error = modbus_send_frame(&ctx, frame, sizeof(frame));
 * if (error != MODBUS_ERROR_NONE) {
 *     // Handle send error
 * }
 * ```
 */
modbus_error_t modbus_send_frame(modbus_context_t *ctx, const uint8_t *frame, uint16_t frame_len) {
    if (!ctx || !frame || frame_len == 0U) {
        return MODBUS_ERROR_INVALID_ARGUMENT; // Invalid arguments
    }

    const mb_transport_if_t *iface = &ctx->transport_iface;
    mb_transport_io_result_t io = {0};
    const mb_err_t status = mb_transport_send(iface, frame, (mb_size_t)frame_len, &io);
    if (status != MODBUS_ERROR_NONE) {
        return status;
    }

    if (io.processed == (mb_size_t)frame_len) {
        ctx->tx_reference_time = mb_transport_now(iface);
    }

    return (io.processed == (mb_size_t)frame_len) ? MODBUS_ERROR_NONE : MODBUS_ERROR_TRANSPORT;
}

/**
 * @brief Receives a Modbus frame using the configured transport.
 *
 * This function attempts to receive a complete Modbus RTU frame from the transport.
 * It reads data into the provided buffer and performs basic timeout handling.
 * The exact behavior depends on the transport's read implementation.
 *
 * @param[in]  ctx         Pointer to the Modbus context.
 * @param[out] out_buffer  Buffer to store the received Modbus RTU frame.
 * @param[in]  out_size    Size of the `out_buffer` in bytes.
 * @param[out] out_length  Pointer to store the length of the received frame.
 *
 * @return modbus_error_t `MODBUS_ERROR_NONE` if a complete and valid frame is received, or an error code.
 *
 * @retval MODBUS_ERROR_NONE          Frame received and validated successfully.
 * @retval MODBUS_ERROR_TIMEOUT       Timeout occurred while waiting for frame.
 * @retval MODBUS_ERROR_CRC           CRC check failed.
 * @retval MODBUS_ERROR_TRANSPORT     Transport layer encountered an error.
 * @retval MODBUS_ERROR_INVALID_ARGUMENT Invalid context or buffer parameters.
 * @retval Others                      Various error codes as defined in `modbus_error_t`.
 *
 * @warning
 * - Ensure that `out_buffer` has enough space to hold the expected frame size.
 * - The function relies on the transport's read implementation for timeout and blocking behavior.
 * 
 * @example
 * ```c
 * uint8_t response_frame[256];
 * uint16_t response_length;
 * modbus_error_t error = modbus_receive_frame(&ctx, response_frame, sizeof(response_frame), &response_length);
 * if (error == MODBUS_ERROR_NONE) {
 *     // Process received frame
 * }
 * ```
 */
modbus_error_t modbus_receive_frame(modbus_context_t *ctx, uint8_t *out_buffer, uint16_t out_size, uint16_t *out_length) {
    if (!ctx || !out_buffer || !out_length || out_size < 4U) {
        return MODBUS_ERROR_INVALID_ARGUMENT; // Invalid arguments
    }

    const mb_transport_if_t *iface = &ctx->transport_iface;
    mb_size_t bytes_read = 0U;
    uint16_t expected_length = 0U;
    uint16_t last_activity_tick = (uint16_t)mb_transport_now(iface);
    const uint16_t frame_origin_tick = last_activity_tick;

    while (bytes_read < (mb_size_t)out_size) {
        mb_transport_io_result_t io = {0};
        const mb_err_t status = mb_transport_recv(iface,
                                                  &out_buffer[bytes_read],
                                                  (mb_size_t)(out_size - (uint16_t)bytes_read),
                                                  &io);

        if (status == MODBUS_ERROR_NONE && io.processed > 0U) {
            bytes_read += io.processed;
            last_activity_tick = (uint16_t)mb_transport_now(iface);

            if (bytes_read >= 3U && expected_length == 0U) {
                const uint8_t function_code = out_buffer[1];
                if ((function_code & MODBUS_FUNC_ERROR_FRAME_HEADER) != 0U) {
                    expected_length = 1U + 1U + 1U + 2U;
                } else {
                    switch (function_code) {
                    case MODBUS_FUNC_READ_COILS:
                    case MODBUS_FUNC_READ_DISCRETE_INPUTS:
                    case MODBUS_FUNC_READ_HOLDING_REGISTERS:
                    case MODBUS_FUNC_READ_INPUT_REGISTERS:
                    case MODBUS_FUNC_WRITE_MULTIPLE_COILS:
                    case MODBUS_FUNC_WRITE_MULTIPLE_REGISTERS:
                    case MODBUS_FUNC_READ_WRITE_MULTIPLE_REGISTERS: {
                        const uint8_t byte_count = out_buffer[2];
                        expected_length = (uint16_t)(3U + byte_count + 2U);
                        break;
                    }
                    case MODBUS_FUNC_WRITE_SINGLE_COIL:
                    case MODBUS_FUNC_WRITE_SINGLE_REGISTER:
                        expected_length = 1U + 1U + 2U + 2U;
                        break;
                    case MODBUS_FUNC_READ_DEVICE_INFORMATION:
                        expected_length = 1U + 1U + 1U + 2U;
                        break;
                    default:
                        expected_length = 1U + 1U + 2U;
                        break;
                    }
                }
            }

            if (expected_length > 0U && bytes_read >= expected_length) {
                break;
            }

            continue;
        }

        if (status == MODBUS_ERROR_TIMEOUT || (status == MODBUS_ERROR_NONE && io.processed == 0U)) {
            const uint16_t now_tick = (uint16_t)mb_transport_now(iface);
            if (((uint16_t)(now_tick - last_activity_tick) > MODBUS_BYTE_TIMEOUT_MS) ||
                ((uint16_t)(now_tick - frame_origin_tick) > MODBUS_INTERFRAME_TIMEOUT_MS)) {
                return MODBUS_ERROR_TIMEOUT;
            }
            mb_transport_yield(iface);
            continue;
        }

        return status;
    }

    if (bytes_read == 0U) {
        return MODBUS_ERROR_TIMEOUT; // No data received
    }

    *out_length = (uint16_t)bytes_read;
    return MODBUS_ERROR_NONE;
}
#endif /* MB_CONF_TRANSPORT_RTU */

/**
 * @brief Converts a Modbus exception code to a `modbus_error_t`.
 *
 * This function maps Modbus exception codes to the corresponding `modbus_error_t`
 * enumeration values. It facilitates the interpretation of error responses from
 * Modbus devices.
 *
 * @param[in]  exception_code The exception code from the Modbus frame.
 * @return A corresponding `modbus_error_t`.
 *
 * @retval MODBUS_EXCEPTION_ILLEGAL_FUNCTION         Exception code 1: Illegal Function
 * @retval MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS     Exception code 2: Illegal Data Address
 * @retval MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE       Exception code 3: Illegal Data Value
 * @retval MODBUS_EXCEPTION_SERVER_DEVICE_FAILURE    Exception code 4: Server Device Failure
 * @retval MODBUS_ERROR_OTHER                        Unknown or unsupported exception codes
 *
 * @warning
 * - Ensure that all relevant exception codes are handled appropriately.
 * 
 * @example
 * ```c
 * uint8_t exception_code = received_payload[0];
 * modbus_error_t error = modbus_exception_to_error(exception_code);
 * if (modbus_error_is_exception(error)) {
 *     // Handle the specific exception
 * }
 * ```
 */
modbus_error_t modbus_exception_to_error(uint8_t exception_code) {
    switch (exception_code) {
        case 1U:
            return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
        case 2U:
            return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
        case 3U:
            return MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE;
        case 4U:
            return MODBUS_EXCEPTION_SERVER_DEVICE_FAILURE;
        default:
            return MODBUS_ERROR_OTHER; // Unknown exception code
    }
}

/**
 * @brief Convenience function to reset internal RX/TX buffers in the context.
 *
 * This function clears the receive and transmit buffers within the Modbus context,
 * effectively resetting the state of any ongoing or previous transactions. It can be
 * used when starting a new transaction or after encountering an error to ensure that
 * residual data does not interfere with subsequent communications.
 *
 * @param[in,out] ctx Pointer to the Modbus context.
 *
 * @note
 * - This function assumes that the buffers are part of the `modbus_context_t` structure.
 * - After resetting, ensure that any necessary initialization for new transactions is performed.
 * 
 * @example
 * ```c
 * // Reset buffers before starting a new transaction
 * modbus_reset_buffers(&ctx);
 * ```
 */
void modbus_reset_buffers(modbus_context_t *ctx) {
    if (!ctx) {
        return; // Invalid context pointer
    }

    /* Reset RX buffer indices and counters */
    ctx->rx_count = 0U;
    ctx->rx_index = 0U;

    /* Reset TX buffer indices and counters */
    ctx->tx_index = 0U;
    ctx->tx_raw_index = 0U;

    /* Clear RX and TX buffers */
    if (ctx->rx_buffer != NULL && ctx->rx_capacity > 0U) {
        memset(ctx->rx_buffer, 0, ctx->rx_capacity);
    }

    if (ctx->rx_raw_buffer != NULL && ctx->rx_raw_capacity > 0U) {
        memset(ctx->rx_raw_buffer, 0, ctx->rx_raw_capacity);
    }

    if (ctx->tx_buffer != NULL && ctx->tx_capacity > 0U) {
        memset(ctx->tx_buffer, 0, ctx->tx_capacity);
    }

    if (ctx->tx_raw_buffer != NULL && ctx->tx_raw_capacity > 0U) {
        memset(ctx->tx_raw_buffer, 0, ctx->tx_raw_capacity);
    }
}

/* ===== End modbus/src/core.c ===== */

/* ===== Begin modbus/src/observe.c ===== */

#include <string.h>

mb_diag_err_slot_t mb_diag_slot_from_error(mb_err_t err)
{
    switch (err) {
    case MB_OK:
        return MB_DIAG_ERR_SLOT_OK;
    case MB_ERR_INVALID_ARGUMENT:
        return MB_DIAG_ERR_SLOT_INVALID_ARGUMENT;
    case MB_ERR_TIMEOUT:
        return MB_DIAG_ERR_SLOT_TIMEOUT;
    case MB_ERR_TRANSPORT:
        return MB_DIAG_ERR_SLOT_TRANSPORT;
    case MB_ERR_CRC:
        return MB_DIAG_ERR_SLOT_CRC;
    case MB_ERR_INVALID_REQUEST:
        return MB_DIAG_ERR_SLOT_INVALID_REQUEST;
    case MB_ERR_OTHER_REQUESTS:
    case MODBUS_OTHERS_REQUESTS:
        return MB_DIAG_ERR_SLOT_OTHER_REQUESTS;
    case MB_ERR_OTHER:
        return MB_DIAG_ERR_SLOT_OTHER;
    case MB_ERR_CANCELLED:
        return MB_DIAG_ERR_SLOT_CANCELLED;
    case MB_ERR_NO_RESOURCES:
        return MB_DIAG_ERR_SLOT_NO_RESOURCES;
    case MB_ERR_BUSY:
        return MB_DIAG_ERR_SLOT_OTHER; /* Map to OTHER as BUSY is a transient state */
    case MB_EX_ILLEGAL_FUNCTION:
        return MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_FUNCTION;
    case MB_EX_ILLEGAL_DATA_ADDRESS:
        return MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_DATA_ADDRESS;
    case MB_EX_ILLEGAL_DATA_VALUE:
        return MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_DATA_VALUE;
    case MB_EX_SERVER_DEVICE_FAILURE:
        return MB_DIAG_ERR_SLOT_EXCEPTION_SERVER_DEVICE_FAILURE;
    case MB_EX_ACKNOWLEDGE:
        return MB_DIAG_ERR_SLOT_EXCEPTION_ACKNOWLEDGE;
    case MB_EX_SERVER_DEVICE_BUSY:
        return MB_DIAG_ERR_SLOT_EXCEPTION_SERVER_DEVICE_BUSY;
    case MB_EX_NEGATIVE_ACKNOWLEDGE:
        return MB_DIAG_ERR_SLOT_EXCEPTION_NEGATIVE_ACKNOWLEDGE;
    case MB_EX_MEMORY_PARITY_ERROR:
        return MB_DIAG_ERR_SLOT_EXCEPTION_MEMORY_PARITY_ERROR;
    case MB_EX_GATEWAY_PATH_UNAVAILABLE:
        return MB_DIAG_ERR_SLOT_EXCEPTION_GATEWAY_PATH_UNAVAILABLE;
    case MB_EX_GATEWAY_TARGET_FAILED:
        return MB_DIAG_ERR_SLOT_EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED;
    default:
        break;
    }

    return MB_DIAG_ERR_SLOT_OTHER;
}

void mb_diag_reset(mb_diag_counters_t *diag)
{
    if (diag == NULL) {
        return;
    }
    memset(diag, 0, sizeof(*diag));
}

void mb_diag_record_fc(mb_diag_counters_t *diag, mb_u8 function)
{
    if (diag == NULL) {
        return;
    }
    diag->function[function] += 1U;
}

void mb_diag_record_error(mb_diag_counters_t *diag, mb_err_t err)
{
    if (diag == NULL) {
        return;
    }
    const mb_diag_err_slot_t slot = mb_diag_slot_from_error(err);
    if (slot < MB_DIAG_ERR_SLOT_MAX) {
        diag->error[slot] += 1U;
    }
}

const char *mb_diag_err_slot_str(mb_diag_err_slot_t slot)
{
    switch (slot) {
    case MB_DIAG_ERR_SLOT_OK:
        return "ok";
    case MB_DIAG_ERR_SLOT_INVALID_ARGUMENT:
        return "invalid-argument";
    case MB_DIAG_ERR_SLOT_TIMEOUT:
        return "timeout";
    case MB_DIAG_ERR_SLOT_TRANSPORT:
        return "transport";
    case MB_DIAG_ERR_SLOT_CRC:
        return "crc";
    case MB_DIAG_ERR_SLOT_INVALID_REQUEST:
        return "invalid-request";
    case MB_DIAG_ERR_SLOT_OTHER_REQUESTS:
        return "other-requests";
    case MB_DIAG_ERR_SLOT_OTHER:
        return "other";
    case MB_DIAG_ERR_SLOT_CANCELLED:
        return "cancelled";
    case MB_DIAG_ERR_SLOT_NO_RESOURCES:
        return "no-resources";
    case MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_FUNCTION:
        return "ex-illegal-function";
    case MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_DATA_ADDRESS:
        return "ex-illegal-data-address";
    case MB_DIAG_ERR_SLOT_EXCEPTION_ILLEGAL_DATA_VALUE:
        return "ex-illegal-data-value";
    case MB_DIAG_ERR_SLOT_EXCEPTION_SERVER_DEVICE_FAILURE:
        return "ex-server-device-failure";
    case MB_DIAG_ERR_SLOT_EXCEPTION_ACKNOWLEDGE:
        return "ex-acknowledge";
    case MB_DIAG_ERR_SLOT_EXCEPTION_SERVER_DEVICE_BUSY:
        return "ex-server-device-busy";
    case MB_DIAG_ERR_SLOT_EXCEPTION_NEGATIVE_ACKNOWLEDGE:
        return "ex-negative-acknowledge";
    case MB_DIAG_ERR_SLOT_EXCEPTION_MEMORY_PARITY_ERROR:
        return "ex-memory-parity-error";
    case MB_DIAG_ERR_SLOT_EXCEPTION_GATEWAY_PATH_UNAVAILABLE:
        return "ex-gateway-path-unavailable";
    case MB_DIAG_ERR_SLOT_EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED:
        return "ex-gateway-target-device-failed";
    case MB_DIAG_ERR_SLOT_MAX:
        return "invalid";
    default:
        break;
    }
    return "unknown";
}

void mb_diag_state_init(mb_diag_state_t *state)
{
    if (state == NULL) {
        return;
    }

#if MB_CONF_DIAG_ENABLE_COUNTERS
    mb_diag_reset(&state->counters);
#endif

#if MB_CONF_DIAG_ENABLE_TRACE
    state->trace.head = 0U;
    state->trace.count = 0U;
#endif
}

void mb_diag_state_reset(mb_diag_state_t *state)
{
    mb_diag_state_init(state);
}

void mb_diag_state_record_fc(mb_diag_state_t *state, mb_u8 function)
{
#if MB_CONF_DIAG_ENABLE_COUNTERS
    if (state == NULL) {
        return;
    }
    mb_diag_record_fc(&state->counters, function);
#else
    (void)state;
    (void)function;
#endif
}

void mb_diag_state_record_error(mb_diag_state_t *state, mb_err_t err)
{
#if MB_CONF_DIAG_ENABLE_COUNTERS
    if (state == NULL) {
        return;
    }
    mb_diag_record_error(&state->counters, err);
#else
    (void)state;
    (void)err;
#endif
}

void mb_diag_state_capture_event(mb_diag_state_t *state, const mb_event_t *event)
{
#if MB_CONF_DIAG_ENABLE_TRACE
    if (state == NULL || event == NULL || MB_CONF_DIAG_TRACE_DEPTH == 0) {
        return;
    }

    mb_diag_trace_buffer_t *trace = &state->trace;
    const mb_u16 capacity = (mb_u16)MB_CONF_DIAG_TRACE_DEPTH;

    mb_u16 write_index;
    if (trace->count >= capacity) {
        write_index = trace->head;
        trace->head = (mb_u16)((trace->head + 1U) % capacity);
    } else {
        write_index = (mb_u16)((trace->head + trace->count) % capacity);
        trace->count = (mb_u16)(trace->count + 1U);
    }

    trace->entries[write_index].timestamp = event->timestamp;
    trace->entries[write_index].source = event->source;
    trace->entries[write_index].type = event->type;
    trace->entries[write_index].function = 0U;
    trace->entries[write_index].status = MB_OK;

    switch (event->type) {
    case MB_EVENT_CLIENT_TX_SUBMIT:
    case MB_EVENT_CLIENT_TX_COMPLETE:
        trace->entries[write_index].function = event->data.client_txn.function;
        trace->entries[write_index].status = event->data.client_txn.status;
        break;
    case MB_EVENT_SERVER_REQUEST_ACCEPT:
    case MB_EVENT_SERVER_REQUEST_COMPLETE:
        trace->entries[write_index].function = event->data.server_req.function;
        trace->entries[write_index].status = event->data.server_req.status;
        break;
    default:
        break;
    }
#else
    (void)state;
    (void)event;
#endif
}

void mb_diag_snapshot(const mb_diag_state_t *state, mb_diag_snapshot_t *out_snapshot)
{
    if (state == NULL || out_snapshot == NULL) {
        return;
    }

    memset(out_snapshot, 0, sizeof(*out_snapshot));

#if MB_CONF_DIAG_ENABLE_COUNTERS
    out_snapshot->counters = state->counters;
#else
    (void)state;
#endif

#if MB_CONF_DIAG_ENABLE_TRACE
    const mb_u16 capacity = (mb_u16)MB_CONF_DIAG_TRACE_DEPTH;
    mb_u16 count = state->trace.count;
    if (count > capacity) {
        count = capacity;
    }
    out_snapshot->trace_len = count;
    for (mb_u16 i = 0U; i < count; ++i) {
        const mb_u16 index = (mb_u16)((state->trace.head + i) % capacity);
        out_snapshot->trace[i] = state->trace.entries[index];
    }
    for (mb_u16 i = count; i < capacity; ++i) {
        out_snapshot->trace[i] = (mb_diag_trace_entry_t){0};
    }
#endif
}
/* ===== End modbus/src/observe.c ===== */

/* ===== Begin modbus/src/client.c ===== */

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>


#if MB_CONF_ENABLE_POWER_MANAGEMENT
#endif

#define MB_CLIENT_TIMEOUT_DEFAULT MB_CLIENT_DEFAULT_TIMEOUT_MS
#define MB_CLIENT_BACKOFF_DEFAULT MB_CLIENT_DEFAULT_RETRY_BACKOFF_MS

#if MB_CONF_TRANSPORT_RTU
static void mb_client_rtu_callback(mb_rtu_transport_t *rtu,
                                   const mb_adu_view_t *adu,
                                   mb_err_t status,
                                   void *user);
#endif
#if MB_CONF_TRANSPORT_TCP
static void mb_client_tcp_callback(mb_tcp_transport_t *tcp,
                                   const mb_adu_view_t *adu,
                                   mb_u16 transaction_id,
                                   mb_err_t status,
                                   void *user);
#endif
static mb_err_t client_transport_submit(mb_client_t *client, mb_client_txn_t *txn);
static mb_err_t client_transport_poll(mb_client_t *client);
static void client_retry(mb_client_t *client);
#if MB_CONF_TRANSPORT_TCP
static mb_client_txn_t *client_find_by_tid(mb_client_t *client, mb_u16 tid);
#endif

static void client_reset_txn_phases(mb_client_txn_t *txn)
{
    if (txn == NULL) {
        return;
    }

    txn->tx_phase = MB_POLL_TX_PHASE_IDLE;
    txn->rx_phase = MB_POLL_RX_PHASE_IDLE;
    txn->tx_deadline_ms = 0U;
    txn->rx_deadline_ms = 0U;
    txn->rx_pending = false;
    txn->rx_status = MB_OK;
    txn->rx_view.unit_id = 0U;
    txn->rx_view.function = 0U;
    txn->rx_view.payload = NULL;
    txn->rx_view.payload_len = 0U;
}

static void client_jitter_sample(mb_client_t *client, mb_time_ms_t now)
{
    if (client == NULL) {
        return;
    }

    mb_poll_jitter_t *jitter = &client->poll_jitter;
    if (jitter->last_timestamp != 0U && now >= jitter->last_timestamp) {
        const mb_time_ms_t delta = now - jitter->last_timestamp;
        if (delta > jitter->max_delta_ms) {
            jitter->max_delta_ms = delta;
            client->metrics.step_max_jitter_ms = delta;
        }
        jitter->total_delta_ms += delta;
        jitter->samples += 1U;
        if (jitter->samples > 0U) {
            client->metrics.step_avg_jitter_ms = (mb_time_ms_t)(jitter->total_delta_ms / jitter->samples);
        }
    }

    jitter->last_timestamp = now;
}

static inline mb_size_t client_normalize_budget(mb_size_t steps)
{
    return (steps == 0U) ? (mb_size_t)SIZE_MAX : steps;
}

static mb_time_ms_t client_now(const mb_client_t *client)
{
    return mb_transport_now(client->iface);
}

static mb_size_t client_total_inflight(const mb_client_t *client)
{
    if (client == NULL) {
        return 0U;
    }

    mb_size_t count = 0U;
    if (client->current != NULL && client->current->in_use && !client->current->cancelled) {
        count = 1U;
    }

    const mb_client_txn_t *node = client->pending_head;
    while (node != NULL) {
        if (node->in_use && !node->cancelled) {
            count += 1U;
        }
        node = node->next;
    }

    return count;
}

static void client_trace_hex_buffer(const mb_client_t *client,
                                    const char *label,
                                    const mb_u8 *buffer,
                                    mb_size_t length)
{
#if MB_LOG_ENABLED
    if (client == NULL || !client->trace_hex || buffer == NULL || length == 0U) {
        return;
    }

    char line[16U + (MB_PDU_MAX * 3U)];
    int written = snprintf(line, sizeof(line), "%s:", (label != NULL) ? label : "client");
    if (written < 0) {
        return;
    }

    size_t pos = (size_t)written;
    for (mb_size_t i = 0U; i < length && pos + 4U < sizeof(line); ++i) {
        int rv = snprintf(&line[pos], sizeof(line) - pos, " %02X", buffer[i]);
        if (rv < 0) {
            break;
        }
        pos += (size_t)rv;
    }

    line[sizeof(line) - 1U] = '\0';
    MB_LOG_DEBUG("%s", line);
#else
    (void)client;
    (void)label;
    (void)buffer;
    (void)length;
#endif
}

static void client_trace_request(const mb_client_t *client, const mb_client_txn_t *txn, const char *label)
{
#if MB_LOG_ENABLED
    if (client == NULL || txn == NULL || !client->trace_hex) {
        return;
    }

    mb_u8 scratch[MB_PDU_MAX + 1U];
    scratch[0] = txn->request_view.function;
    mb_size_t len = 1U;
    if (txn->request_view.payload_len > 0U && txn->request_view.payload != NULL) {
        mb_size_t copy_len = txn->request_view.payload_len;
        if (copy_len > MB_PDU_MAX) {
            copy_len = MB_PDU_MAX;
        }
        memcpy(&scratch[1], txn->request_view.payload, copy_len);
        len += copy_len;
    }

    client_trace_hex_buffer(client, (label != NULL) ? label : "client.tx", scratch, len);
#else
    (void)client;
    (void)txn;
    (void)label;
#endif
}

static void client_trace_response(const mb_client_t *client, const mb_adu_view_t *adu, const char *label)
{
#if MB_LOG_ENABLED
    if (client == NULL || adu == NULL || !client->trace_hex) {
        return;
    }

    mb_u8 scratch[MB_PDU_MAX + 1U];
    scratch[0] = adu->function;
    mb_size_t len = 1U;
    if (adu->payload_len > 0U && adu->payload != NULL) {
        mb_size_t copy_len = adu->payload_len;
        if (copy_len > MB_PDU_MAX) {
            copy_len = MB_PDU_MAX;
        }
        memcpy(&scratch[1], adu->payload, copy_len);
        len += copy_len;
    }

    client_trace_hex_buffer(client, (label != NULL) ? label : "client.rx", scratch, len);
#else
    (void)client;
    (void)adu;
    (void)label;
#endif
}

static void client_emit_state_event(mb_client_t *client,
                                    mb_event_type_t type,
                                    mb_client_state_t state)
{
    if (client == NULL) {
        return;
    }

    mb_event_t event = {
        .source = MB_EVENT_SOURCE_CLIENT,
        .type = type,
        .timestamp = client_now(client),
    };
    event.data.client_state.state = (mb_u8)state;
    mb_diag_state_capture_event(&client->diag, &event);

    if (client->observer_cb != NULL) {
        client->observer_cb(&event, client->observer_user);
    }
}

static void client_emit_tx_event(mb_client_t *client,
                                 mb_event_type_t type,
                                 const mb_client_txn_t *txn,
                                 mb_err_t status)
{
    if (client == NULL || txn == NULL) {
        return;
    }

    mb_event_t event = {
        .source = MB_EVENT_SOURCE_CLIENT,
        .type = type,
        .timestamp = client_now(client),
    };
    event.data.client_txn.function = txn->request_view.function;
    event.data.client_txn.status = status;
    event.data.client_txn.expect_response = txn->expect_response;
    mb_diag_state_capture_event(&client->diag, &event);

    if (client->observer_cb != NULL) {
        client->observer_cb(&event, client->observer_user);
    }
}

static void client_transition_state(mb_client_t *client, mb_client_state_t next)
{
    if (client == NULL || client->state == next) {
        return;
    }

    const mb_client_state_t previous = client->state;
    client_emit_state_event(client, MB_EVENT_CLIENT_STATE_EXIT, previous);
    client->state = next;
    client_emit_state_event(client, MB_EVENT_CLIENT_STATE_ENTER, next);
}

static mb_time_ms_t client_base_timeout_ms(const mb_client_txn_t *txn)
{
    const mb_time_ms_t base = (txn->base_timeout_ms == 0U) ? MB_CLIENT_TIMEOUT_DEFAULT : txn->base_timeout_ms;
    return (base == 0U) ? MB_CLIENT_TIMEOUT_DEFAULT : base;
}

static mb_time_ms_t client_current_timeout_ms(const mb_client_txn_t *txn)
{
    mb_time_ms_t timeout = client_base_timeout_ms(txn);
    mb_u8 retries = txn->retry_count;
    while (retries > 0U && timeout < MB_CLIENT_MAX_TIMEOUT_MS) {
        if (timeout > (MB_CLIENT_MAX_TIMEOUT_MS / 2U)) {
            timeout = MB_CLIENT_MAX_TIMEOUT_MS;
            break;
        }
        timeout *= 2U;
        retries -= 1U;
    }
    if (timeout > MB_CLIENT_MAX_TIMEOUT_MS) {
        timeout = MB_CLIENT_MAX_TIMEOUT_MS;
    }
    return timeout;
}

static mb_time_ms_t client_base_backoff_ms(const mb_client_txn_t *txn)
{
    const mb_time_ms_t base = (txn->retry_backoff_ms == 0U) ? MB_CLIENT_BACKOFF_DEFAULT : txn->retry_backoff_ms;
    return (base == 0U) ? MB_CLIENT_BACKOFF_DEFAULT : base;
}

static mb_time_ms_t client_retry_backoff_ms(const mb_client_txn_t *txn)
{
    mb_time_ms_t backoff = client_base_backoff_ms(txn);
    if (backoff == 0U) {
        backoff = 1U;
    }

    if (txn->retry_count == 0U) {
        return backoff;
    }

    mb_u8 exponent = txn->retry_count - 1U;
    while (exponent > 0U && backoff < MB_CLIENT_MAX_TIMEOUT_MS) {
        if (backoff > (MB_CLIENT_MAX_TIMEOUT_MS / 2U)) {
            backoff = MB_CLIENT_MAX_TIMEOUT_MS;
            break;
        }
        backoff *= 2U;
        exponent -= 1U;
    }

    if (backoff > MB_CLIENT_MAX_TIMEOUT_MS) {
        backoff = MB_CLIENT_MAX_TIMEOUT_MS;
    }

    return backoff;
}

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
static mb_time_ms_t client_backoff_with_jitter(const mb_client_txn_t *txn,
                                               mb_time_ms_t base_backoff,
                                               mb_time_ms_t now)
{
    if (base_backoff <= 1U) {
        return 1U;
    }

    mb_time_ms_t spread = base_backoff / 2U;
    if (spread == 0U) {
        spread = 1U;
    }

    const uintptr_t salt = (uintptr_t)txn;
    const mb_time_ms_t pseudo = (now ^ (now >> 7)) ^ ((mb_time_ms_t)(salt >> 3)) ^ ((mb_time_ms_t)txn->retry_count * 131U);
    const mb_time_ms_t offset = pseudo % (spread + 1U);
    mb_time_ms_t delay = (base_backoff - spread) + offset;
    if (delay == 0U) {
        delay = 1U;
    }
    if (delay > MB_CLIENT_MAX_TIMEOUT_MS) {
        delay = MB_CLIENT_MAX_TIMEOUT_MS;
    }
    return delay;
}
// NOLINTEND(bugprone-easily-swappable-parameters)

static bool client_start_next(mb_client_t *client);

static void client_enqueue(mb_client_t *client, mb_client_txn_t *txn)
{
    txn->next = NULL;
    if (txn->high_priority) {
        txn->next = client->pending_head;
        client->pending_head = txn;
        if (client->pending_tail == NULL) {
            client->pending_tail = txn;
        }
    } else {
        if (client->pending_tail) {
            client->pending_tail->next = txn;
        } else {
            client->pending_head = txn;
        }
        client->pending_tail = txn;
    }
    client->pending_count += 1U;
}

static bool client_remove_from_queue(mb_client_t *client, mb_client_txn_t *target)
{
    if (client == NULL || target == NULL) {
        return false;
    }

    mb_client_txn_t *prev = NULL;
    mb_client_txn_t *node = client->pending_head;
    while (node != NULL) {
        if (node == target) {
            if (prev != NULL) {
                prev->next = node->next;
            } else {
                client->pending_head = node->next;
            }

            if (client->pending_tail == node) {
                client->pending_tail = prev;
            }

            node->next = NULL;
            node->queued = false;
            if (client->pending_count > 0U) {
                client->pending_count -= 1U;
            }
            return true;
        }

        prev = node;
        node = node->next;
    }

    return false;
}

static mb_client_txn_t *client_dequeue(mb_client_t *client)
{
    while (client->pending_head && (client->pending_head->cancelled || !client->pending_head->in_use)) {
        mb_client_txn_t *discard = client->pending_head;
        client->pending_head = discard->next;
        if (client->pending_head == NULL) {
            client->pending_tail = NULL;
        }
        discard->next = NULL;
        discard->queued = false;
        discard->in_use = false;
        discard->next_attempt_ms = 0U;
        if (client->pending_count > 0U) {
            client->pending_count -= 1U;
        }
    }

    mb_client_txn_t *txn = client->pending_head;
    if (txn != NULL) {
        client->pending_head = txn->next;
        if (client->pending_head == NULL) {
            client->pending_tail = NULL;
        }
        txn->next = NULL;
        txn->queued = false;
        if (client->pending_count > 0U) {
            client->pending_count -= 1U;
        }
    }
    return txn;
}

#if MB_CONF_TRANSPORT_TCP
static mb_client_txn_t *client_find_by_tid(mb_client_t *client, mb_u16 tid)
{
    if (client == NULL) {
        return NULL;
    }

    for (mb_size_t i = 0U; i < client->pool_size; ++i) {
        mb_client_txn_t *candidate = &client->pool[i];
        if (!candidate->in_use) {
            continue;
        }
        if (candidate->tid == tid) {
            return candidate;
        }
    }

    return NULL;
}
#endif

static void client_finalize(mb_client_t *client,
                            mb_client_txn_t *txn,
                            mb_err_t status,
                            const mb_adu_view_t *response)
{
    const mb_time_ms_t now = client_now(client);

    client->metrics.completed += 1U;
    if (status == MB_OK) {
        client->metrics.response_count += 1U;
        if (txn->start_time > 0U && now >= txn->start_time) {
            client->metrics.response_latency_total_ms += (now - txn->start_time);
        }
    } else if (status == MB_ERR_TIMEOUT) {
        client->metrics.timeouts += 1U;
    } else if (status == MB_ERR_CANCELLED) {
        client->metrics.cancelled += 1U;
    } else {
        client->metrics.errors += 1U;
    }

    if (txn->poison) {
        client->metrics.poison_triggers += 1U;
    }

    if (response && response->payload) {
        (void)response;
    }

    txn->status = status;
    txn->completed = true;
    txn->callback_pending = true;

    mb_diag_state_record_error(&client->diag, status);
    client_emit_tx_event(client, MB_EVENT_CLIENT_TX_COMPLETE, txn, status);

    if (txn->cfg.callback) {
        txn->cfg.callback(client, txn, status, response, txn->cfg.user_ctx);
    }

    txn->callback_pending = false;
    txn->completed = false;
    txn->cancelled = false;
    txn->in_use = false;
    txn->next = NULL;
    txn->queued = false;
    txn->next_attempt_ms = 0U;
    txn->deadline = 0U;
    txn->watchdog_deadline = 0U;
    txn->tid = 0U;
    txn->high_priority = false;
    txn->poison = false;
    txn->start_time = 0U;
    client_reset_txn_phases(txn);
}

static void client_prepare_response(mb_client_txn_t *txn, const mb_adu_view_t *adu)
{
    if (!txn->expect_response || adu == NULL) {
        txn->response_view.payload_len = 0U;
        txn->response_view.payload = NULL;
        return;
    }

    txn->response_view.unit_id = adu->unit_id;
    txn->response_view.function = adu->function;
    txn->response_view.payload_len = adu->payload_len;
    if (adu->payload && adu->payload_len > 0U) {
        if (adu->payload_len > MB_PDU_MAX) {
            txn->response_view.payload_len = MB_PDU_MAX;
        }
        memcpy(txn->response_storage, adu->payload, txn->response_view.payload_len);
        txn->response_view.payload = txn->response_storage;
    } else {
        txn->response_view.payload = NULL;
    }
}

static mb_err_t client_transport_submit(mb_client_t *client, mb_client_txn_t *txn)
{
    if (client == NULL || txn == NULL) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    mb_err_t status = MB_ERR_INVALID_ARGUMENT;
    mb_size_t frame_len = 0U;

    client_trace_request(client, txn, "client.tx");

    switch (client->transport) {
#if MB_CONF_TRANSPORT_RTU
    case MB_CLIENT_TRANSPORT_RTU:
        frame_len = 1U + 1U + txn->request_view.payload_len + 2U;
        status = mb_rtu_submit(&client->rtu, &txn->request_view);
        break;
#else
    case MB_CLIENT_TRANSPORT_RTU:
        return MB_ERR_INVALID_ARGUMENT;
#endif
#if MB_CONF_TRANSPORT_TCP
    case MB_CLIENT_TRANSPORT_TCP:
        if (txn->tid == 0U) {
            txn->tid = client->next_tid++;
            if (client->next_tid == 0U) {
                client->next_tid = 1U;
            }
        }
        frame_len = MB_TCP_HEADER_SIZE + 1U + txn->request_view.payload_len;
        status = mb_tcp_submit(&client->tcp, &txn->request_view, txn->tid);
        break;
#else
    case MB_CLIENT_TRANSPORT_TCP:
        return MB_ERR_INVALID_ARGUMENT;
#endif
    default:
        return MB_ERR_INVALID_ARGUMENT;
    }

    if (status == MB_OK) {
        client->metrics.bytes_tx += frame_len;
    }

    return status;
}

static mb_err_t client_transport_poll(mb_client_t *client)
{
    if (client == NULL) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    switch (client->transport) {
#if MB_CONF_TRANSPORT_RTU
    case MB_CLIENT_TRANSPORT_RTU:
        return mb_rtu_poll(&client->rtu);
#else
    case MB_CLIENT_TRANSPORT_RTU:
        return MB_ERR_INVALID_ARGUMENT;
#endif
#if MB_CONF_TRANSPORT_TCP
    case MB_CLIENT_TRANSPORT_TCP: {
        mb_err_t status = mb_tcp_poll(&client->tcp);
        return (status == MB_ERR_TIMEOUT) ? MB_OK : status;
    }
#else
    case MB_CLIENT_TRANSPORT_TCP:
        return MB_ERR_INVALID_ARGUMENT;
#endif
    default:
        return MB_ERR_INVALID_ARGUMENT;
    }
}

#if MB_CONF_TRANSPORT_TCP
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
static void mb_client_tcp_callback(mb_tcp_transport_t *tcp,
                                   const mb_adu_view_t *adu,
                                   mb_u16 transaction_id,
                                   mb_err_t status,
                                   void *user)
{
    (void)tcp;
    mb_client_t *client = (mb_client_t *)user;
    if (client == NULL) {
        return;
    }

    mb_client_txn_t *txn = NULL;
    if (transaction_id != 0U) {
        txn = client_find_by_tid(client, transaction_id);
    }
    if (txn == NULL && transaction_id == 0U) {
        txn = client->current;
    }

    if (txn == NULL) {
        return;
    }

    if (txn->queued) {
        client_remove_from_queue(client, txn);
    }

    if (status == MB_OK && adu != NULL) {
        const mb_size_t adu_len = MB_TCP_HEADER_SIZE + 1U + adu->payload_len;
        client->metrics.bytes_rx += adu_len;
        client_trace_response(client, adu, "client.rx");
        mb_size_t payload_len = (adu->payload_len > MB_PDU_MAX) ? MB_PDU_MAX : adu->payload_len;
        if (payload_len > 0U && adu->payload != NULL) {
            memcpy(txn->response_storage, adu->payload, payload_len);
        }
        txn->rx_view.unit_id = adu->unit_id;
        txn->rx_view.function = adu->function;
        txn->rx_view.payload = (payload_len > 0U) ? txn->response_storage : NULL;
        txn->rx_view.payload_len = payload_len;
        txn->rx_phase = MB_POLL_RX_PHASE_HEADER;
    } else {
        txn->rx_phase = MB_POLL_RX_PHASE_DISPATCH;
    }

    txn->rx_status = status;
    txn->rx_pending = true;
    txn->tx_phase = MB_POLL_TX_PHASE_DRAIN;
    txn->rx_deadline_ms = client_now(client) + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;

    if (client->state != MB_CLIENT_STATE_BACKOFF) {
        client_transition_state(client, MB_CLIENT_STATE_WAITING);
    }
}
// NOLINTEND(bugprone-easily-swappable-parameters)
#endif

static bool client_start_next(mb_client_t *client)
{
    if (client == NULL) {
        return false;
    }

    while (true) {
        mb_client_txn_t *next = client_dequeue(client);
        if (next == NULL) {
            client->current = NULL;
            client_transition_state(client, MB_CLIENT_STATE_IDLE);
            return false;
        }

        const mb_time_ms_t now = client_now(client);
        client->current = next;
        client_reset_txn_phases(next);
        next->tx_phase = MB_POLL_TX_PHASE_BUILD;
        if (next->expect_response) {
            next->rx_phase = MB_POLL_RX_PHASE_HEADER;
            next->rx_deadline_ms = now + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
        }
        next->tx_deadline_ms = now + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
        client_transition_state(client, MB_CLIENT_STATE_PREPARING);
        return true;
    }
}

static bool client_process_tx_phase(mb_client_t *client, mb_client_txn_t *txn, mb_time_ms_t now)
{
    if (client == NULL || txn == NULL) {
        return false;
    }

    switch (txn->tx_phase) {
    case MB_POLL_TX_PHASE_BUILD:
        txn->timeout_ms = client_current_timeout_ms(txn);
        txn->deadline = now + txn->timeout_ms;
        txn->watchdog_deadline = (client->watchdog_ms > 0U) ? (now + client->watchdog_ms) : 0U;
        txn->next_attempt_ms = 0U;
        txn->start_time = now;
        if (txn->poison) {
            client_finalize(client, txn, MB_ERR_CANCELLED, NULL);
            client->current = NULL;
            client_transition_state(client, MB_CLIENT_STATE_IDLE);
            (void)client_start_next(client);
            return true;
        }
        txn->tx_phase = MB_POLL_TX_PHASE_SEND;
        txn->tx_deadline_ms = now + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
        client_transition_state(client, MB_CLIENT_STATE_SENDING);
        return true;

    case MB_POLL_TX_PHASE_SEND: {
        mb_err_t status = client_transport_submit(client, txn);
        txn->tx_deadline_ms = now + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
        if (status != MB_OK) {
            client_finalize(client, txn, status, NULL);
            client->current = NULL;
            client_transition_state(client, MB_CLIENT_STATE_IDLE);
            (void)client_start_next(client);
            return true;
        }

        if (!txn->expect_response) {
            client_finalize(client, txn, MB_OK, NULL);
            client->current = NULL;
            client_transition_state(client, MB_CLIENT_STATE_IDLE);
            (void)client_start_next(client);
        } else {
            txn->tx_phase = MB_POLL_TX_PHASE_DRAIN;
            txn->rx_phase = MB_POLL_RX_PHASE_HEADER;
            txn->rx_deadline_ms = now + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
            client_transition_state(client, MB_CLIENT_STATE_WAITING);
        }
        return true;
    }

    case MB_POLL_TX_PHASE_DRAIN:
    case MB_POLL_TX_PHASE_IDLE:
    default:
        break;
    }

    return false;
}

static bool client_process_rx_phase(mb_client_t *client, mb_client_txn_t *txn, mb_time_ms_t now)
{
    if (client == NULL || txn == NULL || !txn->rx_pending) {
        return false;
    }

    switch (txn->rx_phase) {
    case MB_POLL_RX_PHASE_HEADER:
        txn->rx_phase = MB_POLL_RX_PHASE_BODY;
        txn->rx_deadline_ms = now + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
        return true;

    case MB_POLL_RX_PHASE_BODY:
        if (txn->rx_status == MB_OK) {
            client_prepare_response(txn, &txn->rx_view);
        }
        txn->rx_phase = MB_POLL_RX_PHASE_VALIDATE;
        txn->rx_deadline_ms = now + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
        return true;

    case MB_POLL_RX_PHASE_VALIDATE:
        if (txn->rx_status == MB_OK && (txn->rx_view.function & MB_PDU_EXCEPTION_BIT) != 0U) {
            mb_u8 buffer[2] = {txn->rx_view.function, 0U};
            if (txn->rx_view.payload != NULL && txn->rx_view.payload_len >= 1U) {
                buffer[1] = txn->rx_view.payload[0];
                mb_u8 fc = 0U;
                mb_u8 code = 0U;
                if (mb_err_is_ok(mb_pdu_parse_exception(buffer, 2U, &fc, &code))) {
                    txn->rx_status = modbus_exception_to_error(code);
                } else {
                    txn->rx_status = MB_ERR_INVALID_REQUEST;
                }
            } else {
                txn->rx_status = MB_ERR_INVALID_REQUEST;
            }
        }
        txn->rx_phase = MB_POLL_RX_PHASE_DISPATCH;
        txn->rx_deadline_ms = now + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
        return true;

    case MB_POLL_RX_PHASE_DISPATCH: {
        const mb_adu_view_t *response_ptr = (txn->rx_status == MB_OK) ? &txn->response_view : NULL;
        client_finalize(client, txn, txn->rx_status, response_ptr);
        txn->rx_pending = false;
        client->current = NULL;
        client_transition_state(client, MB_CLIENT_STATE_IDLE);
        (void)client_start_next(client);
        return true;
    }

    case MB_POLL_RX_PHASE_IDLE:
    default:
        break;
    }

    return false;
}

static bool client_check_waiting(mb_client_t *client, mb_client_txn_t *txn, mb_time_ms_t now)
{
    if (client == NULL || txn == NULL) {
        return false;
    }

    if (txn->deadline > 0U && now >= txn->deadline) {
        client_retry(client);
        return true;
    }

    if (client->watchdog_ms > 0U && txn->watchdog_deadline > 0U && now >= txn->watchdog_deadline) {
        client_finalize(client, txn, MB_ERR_TRANSPORT, NULL);
        client->current = NULL;
        client_transition_state(client, MB_CLIENT_STATE_IDLE);
        (void)client_start_next(client);
        return true;
    }

    return false;
}

static bool client_run_step(mb_client_t *client, mb_time_ms_t now)
{
    if (client == NULL) {
        return false;
    }

    mb_client_txn_t *txn = client->current;
    if (txn == NULL) {
        return client_start_next(client);
    }

    if (client->state == MB_CLIENT_STATE_BACKOFF) {
        if (txn->next_attempt_ms > 0U && now >= txn->next_attempt_ms) {
            txn->tx_phase = MB_POLL_TX_PHASE_BUILD;
            txn->rx_phase = txn->expect_response ? MB_POLL_RX_PHASE_HEADER : MB_POLL_RX_PHASE_IDLE;
            txn->rx_pending = false;
            txn->next_attempt_ms = 0U;
            client_transition_state(client, MB_CLIENT_STATE_PREPARING);
            return true;
        }
        return false;
    }

    if (client_process_rx_phase(client, txn, now)) {
        return true;
    }

    if (client_process_tx_phase(client, txn, now)) {
        return true;
    }

    if (client->state == MB_CLIENT_STATE_WAITING) {
        return client_check_waiting(client, txn, now);
    }

    return false;
}

static void client_retry(mb_client_t *client)
{
    mb_client_txn_t *txn = client->current;
    if (txn == NULL) {
        return;
    }

    if (txn->retry_count >= txn->max_retries) {
        client_finalize(client, txn, MB_ERR_TIMEOUT, NULL);
        client->current = NULL;
        (void)client_start_next(client);
        return;
    }

    txn->retry_count += 1U;
    client->metrics.retries += 1U;
    const mb_time_ms_t now = client_now(client);
    const mb_time_ms_t base_backoff = client_retry_backoff_ms(txn);
    const mb_time_ms_t delay = client_backoff_with_jitter(txn, base_backoff, now);
    txn->next_attempt_ms = now + delay;
    txn->deadline = 0U;
    txn->watchdog_deadline = 0U;
    txn->tx_phase = MB_POLL_TX_PHASE_BUILD;
    txn->rx_phase = MB_POLL_RX_PHASE_IDLE;
    txn->rx_pending = false;

    client_transition_state(client, MB_CLIENT_STATE_BACKOFF);
}

#if MB_CONF_TRANSPORT_RTU
static void mb_client_rtu_callback(mb_rtu_transport_t *rtu,
                                   const mb_adu_view_t *adu,
                                   mb_err_t status,
                                   void *user)
{
    (void)rtu;
    mb_client_t *client = (mb_client_t *)user;
    mb_client_txn_t *txn = client->current;
    if (txn == NULL) {
        return;
    }

    if (status == MB_OK && adu != NULL) {
        const mb_size_t adu_len = 1U + adu->payload_len + 2U;
        client->metrics.bytes_rx += adu_len;
        client_trace_response(client, adu, "client.rx");
        mb_size_t payload_len = (adu->payload_len > MB_PDU_MAX) ? MB_PDU_MAX : adu->payload_len;
        if (payload_len > 0U && adu->payload != NULL) {
            memcpy(txn->response_storage, adu->payload, payload_len);
        }
        txn->rx_view.unit_id = adu->unit_id;
        txn->rx_view.function = adu->function;
        txn->rx_view.payload = (payload_len > 0U) ? txn->response_storage : NULL;
        txn->rx_view.payload_len = payload_len;
        txn->rx_phase = MB_POLL_RX_PHASE_HEADER;
    } else {
        txn->rx_phase = MB_POLL_RX_PHASE_DISPATCH;
    }

    txn->rx_status = status;
    txn->rx_pending = true;
    txn->tx_phase = MB_POLL_TX_PHASE_DRAIN;
    txn->rx_deadline_ms = client_now(client) + MB_CONF_CLIENT_SUBSTATE_DEADLINE_MS;
    if (client->state != MB_CLIENT_STATE_BACKOFF) {
        client_transition_state(client, MB_CLIENT_STATE_WAITING);
    }
}
#endif

static mb_err_t mb_client_init_common(mb_client_t *client,
                                      const mb_transport_if_t *iface,
                                      mb_client_txn_t *txn_pool,
                                      mb_size_t txn_pool_len)
{
    if (client == NULL || iface == NULL || txn_pool == NULL || txn_pool_len == 0U) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    if (iface->send == NULL || iface->recv == NULL || iface->now == NULL) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    memset(client, 0, sizeof(*client));
    client->iface = iface;
    client->pool = txn_pool;
    client->pool_size = txn_pool_len;
    client->state = MB_CLIENT_STATE_IDLE;
    client->watchdog_ms = MB_CLIENT_DEFAULT_WATCHDOG_MS;
    client->next_tid = 1U;
    client->queue_capacity = txn_pool_len;
    client->pending_count = 0U;
    memset(client->fc_timeouts, 0, sizeof(client->fc_timeouts));
    memset(&client->metrics, 0, sizeof(client->metrics));
    mb_diag_state_reset(&client->diag);

    for (mb_size_t i = 0U; i < txn_pool_len; ++i) {
        memset(&txn_pool[i], 0, sizeof(mb_client_txn_t));
        client_reset_txn_phases(&txn_pool[i]);
    }

    return MB_OK;
}

#if MB_CONF_TRANSPORT_RTU
mb_err_t mb_client_init(mb_client_t *client,
                        const mb_transport_if_t *iface,
                        mb_client_txn_t *txn_pool,
                        mb_size_t txn_pool_len)
{
    mb_err_t status = mb_client_init_common(client, iface, txn_pool, txn_pool_len);
    if (!mb_err_is_ok(status)) {
        return status;
    }

    client->transport = MB_CLIENT_TRANSPORT_RTU;
    return mb_rtu_init(&client->rtu, iface, mb_client_rtu_callback, client);
}
#endif

#if MB_CONF_TRANSPORT_TCP
mb_err_t mb_client_init_tcp(mb_client_t *client,
                            const mb_transport_if_t *iface,
                            mb_client_txn_t *txn_pool,
                            mb_size_t txn_pool_len)
{
    mb_err_t status = mb_client_init_common(client, iface, txn_pool, txn_pool_len);
    if (!mb_err_is_ok(status)) {
        return status;
    }

    client->transport = MB_CLIENT_TRANSPORT_TCP;
    return mb_tcp_init(&client->tcp, iface, mb_client_tcp_callback, client);
}
#endif

mb_err_t mb_client_submit(mb_client_t *client,
                          const mb_client_request_t *request,
                          mb_client_txn_t **out_txn)
{
    if (client == NULL || request == NULL) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    if (request->request.payload_len > MB_PDU_MAX) {
        mb_diag_state_record_error(&client->diag, MB_ERR_INVALID_ARGUMENT);
        return MB_ERR_INVALID_ARGUMENT;
    }

    const bool is_poison = ((request->flags & MB_CLIENT_REQUEST_POISON) != 0U);
    if (!is_poison && client->queue_capacity > 0U) {
        const mb_size_t inflight = client_total_inflight(client);
        if (inflight >= client->queue_capacity) {
            mb_diag_state_record_error(&client->diag, MB_ERR_NO_RESOURCES);
            return MB_ERR_NO_RESOURCES;
        }
    }

    mb_client_txn_t *txn = NULL;
    for (mb_size_t i = 0U; i < client->pool_size; ++i) {
        if (!client->pool[i].in_use) {
            txn = &client->pool[i];
            break;
        }
    }

    if (txn == NULL) {
        mb_diag_state_record_error(&client->diag, MB_ERR_NO_RESOURCES);
        return MB_ERR_NO_RESOURCES;
    }

    memset(txn, 0, sizeof(*txn));
    client_reset_txn_phases(txn);
    txn->in_use = true;
    txn->queued = true;
    txn->cfg = *request;
    txn->poison = is_poison;
    txn->high_priority = ((request->flags & MB_CLIENT_REQUEST_HIGH_PRIORITY) != 0U) || txn->poison;
    txn->expect_response = ((request->flags & MB_CLIENT_REQUEST_NO_RESPONSE) == 0U) && !txn->poison;

    mb_time_ms_t base_timeout = request->timeout_ms;
    if (base_timeout == 0U) {
        const mb_u8 function = request->request.function;
        const mb_time_ms_t fc_override = client->fc_timeouts[function];
        base_timeout = (fc_override != 0U) ? fc_override : MB_CLIENT_TIMEOUT_DEFAULT;
    }
    txn->timeout_ms = base_timeout;
    txn->base_timeout_ms = base_timeout;
    txn->retry_backoff_ms = (request->retry_backoff_ms == 0U) ? MB_CLIENT_BACKOFF_DEFAULT : request->retry_backoff_ms;
    txn->max_retries = request->max_retries;
    txn->retry_count = 0U;
    txn->status = MB_OK;
    txn->next_attempt_ms = 0U;

    txn->request_view.unit_id = request->request.unit_id;
    txn->request_view.function = request->request.function;
    txn->request_view.payload_len = request->request.payload_len;
    if (request->request.payload_len > 0U && request->request.payload != NULL) {
        memcpy(txn->request_storage, request->request.payload, request->request.payload_len);
        txn->request_view.payload = txn->request_storage;
    } else {
        txn->request_view.payload = NULL;
    }

    if (!txn->poison) {
        mb_diag_state_record_fc(&client->diag, txn->request_view.function);
    }
    client_emit_tx_event(client, MB_EVENT_CLIENT_TX_SUBMIT, txn, MB_OK);

    client_enqueue(client, txn);
    client->metrics.submitted += 1U;

    if (out_txn) {
        *out_txn = txn;
    }

    if (client->state == MB_CLIENT_STATE_IDLE && client->current == NULL) {
        client_start_next(client);
    }

    return MB_OK;
}

mb_err_t mb_client_submit_poison(mb_client_t *client)
{
    if (client == NULL) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    mb_client_request_t request;
    memset(&request, 0, sizeof(request));
    request.flags = MB_CLIENT_REQUEST_POISON | MB_CLIENT_REQUEST_NO_RESPONSE | MB_CLIENT_REQUEST_HIGH_PRIORITY;
    return mb_client_submit(client, &request, NULL);
}

mb_err_t mb_client_cancel(mb_client_t *client, mb_client_txn_t *txn)
{
    if (client == NULL || txn == NULL || !txn->in_use) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    if (txn == client->current) {
        client_finalize(client, txn, MB_ERR_CANCELLED, NULL);
        client->current = NULL;
        client_start_next(client);
        return MB_OK;
    }

    const bool removed = client_remove_from_queue(client, txn);

    if (!removed && !txn->queued) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    client_finalize(client, txn, MB_ERR_CANCELLED, NULL);

    if (client->state == MB_CLIENT_STATE_IDLE && client->current == NULL) {
        client_start_next(client);
    }

    return MB_OK;
}

mb_err_t mb_client_poll_with_budget(mb_client_t *client, mb_size_t steps)
{
    if (client == NULL) {
        return MB_ERR_INVALID_ARGUMENT;
    }

    MB_CONF_CLIENT_POLL_HOOK(client, MB_CONF_CLIENT_POLL_PHASE_ENTER);

    mb_err_t status = client_transport_poll(client);

    MB_CONF_CLIENT_POLL_HOOK(client, MB_CONF_CLIENT_POLL_PHASE_AFTER_TRANSPORT);

    mb_size_t remaining = client_normalize_budget(steps);
    while (remaining-- > 0U) {
        const mb_time_ms_t now = client_now(client);
        if (!client_run_step(client, now)) {
            break;
        }
        client_jitter_sample(client, now);
    }

    MB_CONF_CLIENT_POLL_HOOK(client, MB_CONF_CLIENT_POLL_PHASE_AFTER_STATE);
    MB_CONF_CLIENT_POLL_HOOK(client, MB_CONF_CLIENT_POLL_PHASE_EXIT);

#if MB_CONF_ENABLE_POWER_MANAGEMENT
    // Invoke idle callback if client is idle and callback is registered
    // This allows the application to enter low-power mode
    (void)mb_client_invoke_idle_callback_internal(client);
#endif

    return status;
}

mb_err_t mb_client_poll(mb_client_t *client)
{
    return mb_client_poll_with_budget(client, MB_CONF_CLIENT_POLL_BUDGET_STEPS);
}

void mb_client_set_watchdog(mb_client_t *client, mb_time_ms_t watchdog_ms)
{
    if (client == NULL) {
        return;
    }
    client->watchdog_ms = watchdog_ms;
}

bool mb_client_is_idle(const mb_client_t *client)
{
    if (client == NULL) {
        return true;
    }
    return (client->state == MB_CLIENT_STATE_IDLE) && (client->pending_head == NULL) && (client->current == NULL);
}

mb_size_t mb_client_pending(const mb_client_t *client)
{
    return client_total_inflight(client);
}

void mb_client_set_queue_capacity(mb_client_t *client, mb_size_t capacity)
{
    if (client == NULL) {
        return;
    }

    if (capacity == 0U || capacity > client->pool_size) {
        client->queue_capacity = client->pool_size;
    } else {
        client->queue_capacity = capacity;
    }
}

mb_size_t mb_client_queue_capacity(const mb_client_t *client)
{
    if (client == NULL) {
        return 0U;
    }
    return client->queue_capacity;
}

void mb_client_set_fc_timeout(mb_client_t *client, mb_u8 function, mb_time_ms_t timeout_ms)
{
    if (client == NULL) {
        return;
    }

    client->fc_timeouts[function] = timeout_ms;
}

void mb_client_get_metrics(const mb_client_t *client, mb_client_metrics_t *out_metrics)
{
    if (client == NULL || out_metrics == NULL) {
        return;
    }

    *out_metrics = client->metrics;
}

void mb_client_reset_metrics(mb_client_t *client)
{
    if (client == NULL) {
        return;
    }

    memset(&client->metrics, 0, sizeof(client->metrics));
    memset(&client->poll_jitter, 0, sizeof(client->poll_jitter));
}

void mb_client_get_diag(const mb_client_t *client, mb_diag_counters_t *out_diag)
{
    if (client == NULL || out_diag == NULL) {
        return;
    }

#if MB_CONF_DIAG_ENABLE_COUNTERS
    *out_diag = client->diag.counters;
#else
    memset(out_diag, 0, sizeof(*out_diag));
#endif
}

void mb_client_get_diag_snapshot(const mb_client_t *client, mb_diag_snapshot_t *out_snapshot)
{
    if (client == NULL || out_snapshot == NULL) {
        return;
    }

    mb_diag_snapshot(&client->diag, out_snapshot);
}

void mb_client_reset_diag(mb_client_t *client)
{
    if (client == NULL) {
        return;
    }

    mb_diag_state_reset(&client->diag);
}

void mb_client_set_event_callback(mb_client_t *client, mb_event_callback_t callback, void *user_ctx)
{
    if (client == NULL) {
        return;
    }

    client->observer_cb = callback;
    client->observer_user = (callback != NULL) ? user_ctx : NULL;

    if (callback != NULL) {
        client_emit_state_event(client, MB_EVENT_CLIENT_STATE_ENTER, client->state);
    }
}

void mb_client_set_trace_hex(mb_client_t *client, bool enable)
{
    if (client == NULL) {
        return;
    }

    client->trace_hex = enable;
}
/* ===== End modbus/src/client.c ===== */

