#!/usr/bin/env python3
"""Generate drop-in amalgamated sources for baseline Modbus client + RTU."""
from __future__ import annotations

import argparse
import datetime as _dt
import textwrap
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]
EMBEDDED_ROOT = REPO_ROOT / "embedded" / "quickstarts" / "drop_in"

HEADER_ORDER = [
    "modbus/include/modbus/mb_types.h",
    "modbus/include/modbus/conf.h",
    "modbus/include/modbus/mb_err.h",
    "modbus/include/modbus/transport_if.h",
    "modbus/include/modbus/transport.h",
    "modbus/include/modbus/base.h",
    "modbus/include/modbus/utils.h",
    "modbus/include/modbus/ringbuf.h",
    "modbus/include/modbus/mempool.h",
    "modbus/include/modbus/log.h",
    "modbus/include/modbus/mb_log.h",
    "modbus/include/modbus/pdu.h",
    "modbus/include/modbus/frame.h",
    "modbus/include/modbus/transport/rtu.h",
    "modbus/include/modbus/core.h",
    "modbus/include/modbus/fsm.h",
    "modbus/include/modbus/observe.h",
    "modbus/include/modbus/client.h",
    "modbus/include/modbus/modbus.h",
]

SOURCE_ORDER = [
    "modbus/src/mb_err.c",
    "modbus/src/mb_log.c",
    "modbus/src/log.c",
    "modbus/src/utils.c",
    "modbus/src/ringbuf.c",
    "modbus/src/mempool.c",
    "modbus/src/pdu.c",
    "modbus/src/frame.c",
    "modbus/src/transport.c",
    "modbus/src/transport/rtu/rtu.c",
    "modbus/src/fsm.c",
    "modbus/src/core.c",
    "modbus/src/observe.c",
    "modbus/src/client.c",
]

# Append any additional sources referenced above if they are missing.
_SOURCE_BASE = REPO_ROOT / "modbus" / "src"
for source in sorted(_SOURCE_BASE.rglob("*.c")):
    rel = source.relative_to(REPO_ROOT).as_posix()
    if rel not in SOURCE_ORDER and "transport/rtu" in rel:
        SOURCE_ORDER.append(rel)

HEADER_BANNER = textwrap.dedent(
    """
    /*
     * modbus_amalgamated.h - generated drop-in header
     *
     * This file is generated by scripts/amalgamate.py.
     * It contains the public Modbus API required for the baseline RTU client
     * configuration so that embedded projects can integrate without the full
     * repository layout.
     *
     * Generation timestamp: {timestamp}
     */
    """
)

SOURCE_BANNER = textwrap.dedent(
    """
    /*
     * modbus_amalgamated.c - generated drop-in translation unit
     *
     * This file is generated by scripts/amalgamate.py.
     * It bundles the Modbus core, baseline client implementation and RTU
     * transport into a single compilation unit suitable for embedded builds.
     *
     * Generation timestamp: {timestamp}
     */
    """
)

# Profile configurations
PROFILE_CONFIGS = {
    "TINY": {
        "MB_CONF_PROFILE": "0",  # TINY
        "MB_CONF_BUILD_CLIENT": "1",
        "MB_CONF_BUILD_SERVER": "0",
        "MB_CONF_TRANSPORT_RTU": "1",
        "MB_CONF_TRANSPORT_ASCII": "0",
        "MB_CONF_TRANSPORT_TCP": "0",
        "MB_CONF_ENABLE_FC01": "0",
        "MB_CONF_ENABLE_FC02": "0",
        "MB_CONF_ENABLE_FC03": "1",
        "MB_CONF_ENABLE_FC04": "0",
        "MB_CONF_ENABLE_FC05": "0",
        "MB_CONF_ENABLE_FC06": "1",
        "MB_CONF_ENABLE_FC07": "0",
        "MB_CONF_ENABLE_FC0F": "0",
        "MB_CONF_ENABLE_FC10": "1",
        "MB_CONF_ENABLE_FC11": "0",
        "MB_CONF_ENABLE_FC16": "0",
        "MB_CONF_ENABLE_FC17": "0",
        "MB_CONF_DIAG_ENABLE_COUNTERS": "0",
        "MB_CONF_DIAG_ENABLE_TRACE": "0",
    },
    "LEAN": {
        "MB_CONF_PROFILE": "1",  # LEAN
        "MB_CONF_BUILD_CLIENT": "1",
        "MB_CONF_BUILD_SERVER": "1",
        "MB_CONF_TRANSPORT_RTU": "1",
        "MB_CONF_TRANSPORT_ASCII": "0",
        "MB_CONF_TRANSPORT_TCP": "1",
        "MB_CONF_ENABLE_FC01": "1",
        "MB_CONF_ENABLE_FC02": "0",
        "MB_CONF_ENABLE_FC03": "1",
        "MB_CONF_ENABLE_FC04": "0",
        "MB_CONF_ENABLE_FC05": "1",
        "MB_CONF_ENABLE_FC06": "1",
        "MB_CONF_ENABLE_FC07": "0",
        "MB_CONF_ENABLE_FC0F": "1",
        "MB_CONF_ENABLE_FC10": "1",
        "MB_CONF_ENABLE_FC11": "0",
        "MB_CONF_ENABLE_FC16": "0",
        "MB_CONF_ENABLE_FC17": "0",
        "MB_CONF_DIAG_ENABLE_COUNTERS": "1",
        "MB_CONF_DIAG_ENABLE_TRACE": "0",
    },
    "FULL": {
        "MB_CONF_PROFILE": "2",  # FULL
        "MB_CONF_BUILD_CLIENT": "1",
        "MB_CONF_BUILD_SERVER": "1",
        "MB_CONF_TRANSPORT_RTU": "1",
        "MB_CONF_TRANSPORT_ASCII": "1",
        "MB_CONF_TRANSPORT_TCP": "1",
        "MB_CONF_ENABLE_FC01": "1",
        "MB_CONF_ENABLE_FC02": "1",
        "MB_CONF_ENABLE_FC03": "1",
        "MB_CONF_ENABLE_FC04": "1",
        "MB_CONF_ENABLE_FC05": "1",
        "MB_CONF_ENABLE_FC06": "1",
        "MB_CONF_ENABLE_FC07": "1",
        "MB_CONF_ENABLE_FC0F": "1",
        "MB_CONF_ENABLE_FC10": "1",
        "MB_CONF_ENABLE_FC11": "1",
        "MB_CONF_ENABLE_FC16": "1",
        "MB_CONF_ENABLE_FC17": "1",
        "MB_CONF_DIAG_ENABLE_COUNTERS": "1",
        "MB_CONF_DIAG_ENABLE_TRACE": "1",
    }
}

# Default configuration (LEAN profile, RTU-only client)
DROP_IN_DEFAULTS = PROFILE_CONFIGS["LEAN"].copy()
DROP_IN_DEFAULTS.update({
    "MB_CONF_BUILD_SERVER": "0",
    "MB_CONF_TRANSPORT_TCP": "0",
    "MB_CONF_TRANSPORT_ASCII": "0",
})


def _scrub_modbus_includes(text: str, comment: bool = False) -> str:
    result: list[str] = []
    for line in text.splitlines():
        stripped = line.strip()
        if stripped.startswith("#include") and ("\"modbus/" in stripped or "<modbus/" in stripped):
            if comment:
                # Use // to avoid nested comment issues when the original line contains
                # Doxygen-style annotations such as /**< ... */.
                cleaned = line.strip()
                if "/*" in cleaned:
                    cleaned = cleaned.split("/*", 1)[0].strip()
                result.append(f"// {cleaned} (amalgamated)")
            continue
        result.append(line)
    return "\n".join(result) + "\n"


def _scrub_conf_defaults(text: str, config: dict) -> str:
    """Replace configuration macros with specified values."""
    for macro, value in config.items():
        # Replace both 0 and 1 definitions
        text = text.replace(f"#define {macro} 1", f"#define {macro} {value}")
        text = text.replace(f"#define {macro} 0", f"#define {macro} {value}")
    return text


def _get_configuration(args) -> dict:
    """Build configuration dictionary from command-line arguments."""
    # Start with profile defaults
    if args.profile:
        config = PROFILE_CONFIGS[args.profile].copy()
    else:
        config = DROP_IN_DEFAULTS.copy()
    
    # Override with specific options
    if args.client_only:
        config["MB_CONF_BUILD_CLIENT"] = "1"
        config["MB_CONF_BUILD_SERVER"] = "0"
    elif args.server_only:
        config["MB_CONF_BUILD_CLIENT"] = "0"
        config["MB_CONF_BUILD_SERVER"] = "1"
    
    if args.rtu_only:
        config["MB_CONF_TRANSPORT_RTU"] = "1"
        config["MB_CONF_TRANSPORT_TCP"] = "0"
        config["MB_CONF_TRANSPORT_ASCII"] = "0"
    elif args.tcp_only:
        config["MB_CONF_TRANSPORT_RTU"] = "0"
        config["MB_CONF_TRANSPORT_TCP"] = "1"
        config["MB_CONF_TRANSPORT_ASCII"] = "0"
    
    # Function code selection
    if args.fc:
        # Disable all FCs first
        for fc_num in ["01", "02", "03", "04", "05", "06", "07", "0F", "10", "11", "16", "17"]:
            config[f"MB_CONF_ENABLE_FC{fc_num}"] = "0"
        # Enable selected FCs
        for fc in args.fc:
            fc_str = fc if len(fc) == 2 else f"0{fc}"
            config[f"MB_CONF_ENABLE_FC{fc_str}"] = "1"
    
    return config


def _get_stats(config: dict) -> dict:
    """Estimate footprint based on configuration."""
    # Base footprint
    rom = 12000  # Core + PDU
    ram = 4096   # Minimal buffers
    
    # Client adds ~5KB, Server adds ~6KB
    if config.get("MB_CONF_BUILD_CLIENT") == "1":
        rom += 5000
        ram += 2048
    if config.get("MB_CONF_BUILD_SERVER") == "1":
        rom += 6000
        ram += 2048
    
    # Transport layers
    if config.get("MB_CONF_TRANSPORT_RTU") == "1":
        rom += 3000
    if config.get("MB_CONF_TRANSPORT_TCP") == "1":
        rom += 4000
    if config.get("MB_CONF_TRANSPORT_ASCII") == "1":
        rom += 3500
    
    # Function codes (~500 bytes each)
    fc_count = sum(1 for k, v in config.items() if k.startswith("MB_CONF_ENABLE_FC") and v == "1")
    rom += fc_count * 500
    
    # Diagnostics
    if config.get("MB_CONF_DIAG_ENABLE_COUNTERS") == "1":
        rom += 1000
        ram += 128
    if config.get("MB_CONF_DIAG_ENABLE_TRACE") == "1":
        rom += 2000
        ram += 2048
    
    return {"rom": rom, "ram": ram}


def generate_header(config: dict, output_name: str = "modbus_amalgamated") -> None:
    EMBEDDED_ROOT.mkdir(parents=True, exist_ok=True)
    header_path = EMBEDDED_ROOT / f"{output_name}.h"
    timestamp = _dt.datetime.now(_dt.timezone.utc).isoformat(timespec="seconds")
    
    # Build configuration summary
    profile = {v: k for k, v in {"TINY": "0", "LEAN": "1", "FULL": "2"}.items()}.get(config.get("MB_CONF_PROFILE", "1"), "CUSTOM")
    features = []
    if config.get("MB_CONF_BUILD_CLIENT") == "1":
        features.append("Client")
    if config.get("MB_CONF_BUILD_SERVER") == "1":
        features.append("Server")
    transports = []
    if config.get("MB_CONF_TRANSPORT_RTU") == "1":
        transports.append("RTU")
    if config.get("MB_CONF_TRANSPORT_TCP") == "1":
        transports.append("TCP")
    if config.get("MB_CONF_TRANSPORT_ASCII") == "1":
        transports.append("ASCII")
    
    banner = textwrap.dedent(f"""
    /*
     * {output_name}.h - generated drop-in header
     *
     * This file is generated by scripts/amalgamate.py.
     *
     * Configuration:
     *   Profile: {profile}
     *   Features: {', '.join(features) if features else 'None'}
     *   Transports: {', '.join(transports) if transports else 'None'}
     *
     * Generation timestamp: {timestamp}
     */
    """)
    
    pieces: list[str] = [banner]
    guard = f"{output_name.upper().replace('.', '_')}_H"
    pieces.append(f"#ifndef {guard}\n#define {guard}\n\n")
    pieces.append("#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n")

    seen = set()
    for rel_path in HEADER_ORDER:
        if rel_path in seen:
            continue
        seen.add(rel_path)
        path = REPO_ROOT / rel_path
        content = path.read_text()
        content = _scrub_modbus_includes(content, comment=True)
        if path.name == "conf.h":
            content = _scrub_conf_defaults(content, config)
        pieces.append(f"/* ===== Begin {rel_path} ===== */\n")
        pieces.append(content)
        pieces.append(f"/* ===== End {rel_path} ===== */\n\n")

    pieces.append(f"#endif /* {guard} */\n")
    header_path.write_text("".join(pieces))
    return header_path


def generate_source(config: dict, output_name: str = "modbus_amalgamated") -> None:
    source_path = EMBEDDED_ROOT / f"{output_name}.c"
    timestamp = _dt.datetime.now(_dt.timezone.utc).isoformat(timespec="seconds")
    
    banner = textwrap.dedent(f"""
    /*
     * {output_name}.c - generated drop-in translation unit
     *
     * This file is generated by scripts/amalgamate.py.
     * It bundles the Modbus core into a single compilation unit suitable
     * for embedded builds.
     *
     * Generation timestamp: {timestamp}
     */
    """)
    
    pieces: list[str] = [banner]
    pieces.append("#define MB_LOG_ENABLED 1\n")
    for macro, value in config.items():
        pieces.append(f"#ifndef {macro}\n#define {macro} {value}\n#endif\n")
    pieces.append(f"\n#include \"{output_name}.h\"\n\n")

    seen = set()
    for rel_path in SOURCE_ORDER:
        if rel_path in seen:
            continue
        seen.add(rel_path)
        path = REPO_ROOT / rel_path
        content = path.read_text()
        content = _scrub_modbus_includes(content)
        pieces.append(f"/* ===== Begin {rel_path} ===== */\n")
        pieces.append(content)
        if not content.endswith("\n"):
            pieces.append("\n")
        pieces.append(f"/* ===== End {rel_path} ===== */\n\n")

    source_path.write_text("".join(pieces))
    return source_path


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate amalgamated Modbus sources",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent("""
        Examples:
          # Default LEAN profile, RTU client only
          python scripts/amalgamate.py
          
          # TINY profile for minimal footprint
          python scripts/amalgamate.py --profile TINY
          
          # FULL profile with all features
          python scripts/amalgamate.py --profile FULL
          
          # Custom: Client-only with specific function codes
          python scripts/amalgamate.py --client-only --fc 03,06,16
          
          # Custom output name
          python scripts/amalgamate.py --profile TINY --output my_modbus
        """)
    )
    
    parser.add_argument("--profile", choices=["TINY", "LEAN", "FULL"],
                        help="Configuration profile (default: LEAN)")
    parser.add_argument("--client-only", action="store_true",
                        help="Enable client only (disable server)")
    parser.add_argument("--server-only", action="store_true",
                        help="Enable server only (disable client)")
    parser.add_argument("--rtu-only", action="store_true",
                        help="Enable RTU transport only")
    parser.add_argument("--tcp-only", action="store_true",
                        help="Enable TCP transport only")
    parser.add_argument("--fc", type=lambda s: s.split(','),
                        help="Function codes to enable (comma-separated, e.g., 03,06,16)")
    parser.add_argument("--output", default="modbus_amalgamated",
                        help="Output file name prefix (default: modbus_amalgamated)")
    parser.add_argument("--check", action="store_true",
                        help="Fail if generated files are out of date")
    parser.add_argument("--stats", action="store_true",
                        help="Print estimated footprint statistics")
    
    args = parser.parse_args()
    
    # Validate conflicting options
    if args.client_only and args.server_only:
        parser.error("--client-only and --server-only are mutually exclusive")
    if args.rtu_only and args.tcp_only:
        parser.error("--rtu-only and --tcp-only are mutually exclusive")
    
    # Get configuration
    config = _get_configuration(args)
    
    # Check mode
    if args.check:
        header_path = EMBEDDED_ROOT / f"{args.output}.h"
        source_path = EMBEDDED_ROOT / f"{args.output}.c"
        previous_header = header_path.read_text() if header_path.exists() else None
        previous_source = source_path.read_text() if source_path.exists() else None
        
        generate_header(config, args.output)
        generate_source(config, args.output)
        
        if previous_header is not None and previous_header != header_path.read_text():
            raise SystemExit(f"{args.output}.h is out of date; run scripts/amalgamate.py")
        if previous_source is not None and previous_source != source_path.read_text():
            raise SystemExit(f"{args.output}.c is out of date; run scripts/amalgamate.py")
        return
    
    # Generate files
    print(f"Amalgamating Modbus library...")
    print(f"Configuration:")
    
    # Display configuration
    profile_name = {v: k for k, v in {"TINY": "0", "LEAN": "1", "FULL": "2"}.items()}.get(
        config.get("MB_CONF_PROFILE", "1"), "CUSTOM"
    )
    print(f"  Profile: {profile_name}")
    
    features = []
    if config.get("MB_CONF_BUILD_CLIENT") == "1":
        features.append("Client")
    if config.get("MB_CONF_BUILD_SERVER") == "1":
        features.append("Server")
    print(f"  Features: {', '.join(features) if features else 'None'}")
    
    transports = []
    if config.get("MB_CONF_TRANSPORT_RTU") == "1":
        transports.append("RTU")
    if config.get("MB_CONF_TRANSPORT_TCP") == "1":
        transports.append("TCP")
    if config.get("MB_CONF_TRANSPORT_ASCII") == "1":
        transports.append("ASCII")
    print(f"  Transports: {', '.join(transports) if transports else 'None'}")
    
    enabled_fcs = [k.replace("MB_CONF_ENABLE_FC", "") for k, v in config.items() 
                   if k.startswith("MB_CONF_ENABLE_FC") and v == "1"]
    print(f"  Function Codes: {', '.join(enabled_fcs) if enabled_fcs else 'None'}")
    
    header_path = generate_header(config, args.output)
    source_path = generate_source(config, args.output)
    
    # Count lines
    header_lines = len(header_path.read_text().splitlines())
    source_lines = len(source_path.read_text().splitlines())
    print(f"\nOutput:")
    print(f"  {header_path.name} ({header_lines:,} lines)")
    print(f"  {source_path.name} ({source_lines:,} lines)")
    
    # Print statistics if requested
    if args.stats or True:  # Always show stats
        stats = _get_stats(config)
        print(f"\nEstimated footprint:")
        print(f"  ROM: ~{stats['rom'] // 1024}KB ({stats['rom']:,} bytes)")
        print(f"  RAM: ~{stats['ram'] // 1024}KB ({stats['ram']:,} bytes)")
    
    print("\nDone!")


if __name__ == "__main__":
    main()
